{"pages":[{"title":"关于鲲鹏","text":"什么是鲲鹏计算产业？ 鲲鹏计算产业是基于Kunpeng处理器构建的全栈IT基础设施、行业应用及服务，包括PC、服务器、存储、操作系统、中间件、虚拟化、数据库、云服务、行业应用以及咨询管理服务等。 华为作为鲲鹏计算产业的成员，聚焦于发展华为鲲鹏+昇腾双引擎芯片族，通过“硬件开放、软件开源、使能合作伙伴”来推动计算产业的发展。硬件厂商基于开放的服务器主板和PC主板发展自有品牌的产品和解决方案，软件厂商基于 openEuler的开源OS以及配套的数据库、中间件等平台软件发展应用软件和服务。 鲲鹏计算产业目标是建立完善的开发者和产业人才体系，通过产业联盟、开源社区、OpenLab、行业标准组织一起完善产业链，打通行业全栈，使鲲鹏生态成为开发者和用户的首选。","link":"/about/index.html"},{"title":"ARM生态使能Landscape","text":"Apache Hadoop 分类: 大数据 Hadoop ARM CI已在社区正式支持，并于Hadoop 3.3.0版本发布首个ARM Release。 Apache Spark 分类: 大数据 Spark是专为大规模数据处理而设计的快速通用的计算引擎。Spark ARM CI已经在社区正式启用。 Apache Hive 分类: 大数据 Hive是一个基于Hadoop的数据仓库平台，Hive ARM CI已经在社区正式启用。 Apache HBase 分类: 大数据 HBase是一个分布式的、面向列的开源数据库，HBase ARM CI已经在社区正式启用。 Apache Flink 分类: 大数据 Flink是一个框架和分布式处理引擎，Flink ARM CI已经在社区正式启用。 Apache Kudu 分类: 大数据 Kudu旨在完善Hadoop生态的存储层，用于对快速数据进行快速分析。 MariaDB 分类: 数据库 MariaDB数据库管理系统是MySQL的一个分支，ARM CI已在社区正式启用。 Greenplum 分类: 数据库 GreenPlum是面向数据仓库应用的关系型数据库，基于PostgreSQL开发。ARM CI已在社区正式启用。 TensorFlow 分类: AI TensorFlow是一个端到端开源机器学习平台，ARM Build CI已在社区每日构建。 PyTorch 分类: AI PyTorch是一个开源的Python机器学习库，ARM Build CI已在社区每日构建。 .project { width: 100%; min-height: 150px; margin: 20px 0px; display: block; clear: both; } .project aside img { width: 132px; height: 132px; float: left; background-color: white; padding: 6px; border-radius: 8px; border: 1px solid #dedede; margin: -5px 10px 5px 0px; } .project .intro { margin: 5px 10px 5px 0px; width: 100%; } .project .intro ul { list-style: none; margin-left: 0; } .project .intro ul li { line-height: 20px; } .project .intro ul li:first-child { font-size: 20px; padding-bottom: 5px; margin-bottom: 10px; border-bottom: 1px #eee solid; } .project .intro ul li:before { content: none; }","link":"/projects/index.html"}],"posts":[{"title":"ARM CPU Vendor 及 Part ID 映射关系（持续更新）","text":"作者：郑振宇 根据ARM CPU官方技术手册，ARM CPU的CPU型号、Vendor、版本等信息存于MIDR_EL1寄存器中:其中从低至高第0-3 bit表示revision，代表固件版本的小版本号，如r1p3中的p3；第4-15 bit表示part number(id)，代表这款CPU在所在vendor产品中定义的产品代码，如在HiSilicon产品中，part_id=0xd01代表Kunpeng-920芯片；第16-19 bit表示architecture，即架构版本，0x8即ARMv8；第20-23 bit表示variant，即固件版本的大版本号，如r1p3中的r1；第24-31 bit表示implementer，即vendor id，如vendor_id=0x48表示HiSilicon。 想要知道一款ARM CPU的具体型号，则需要首先解析vendor_id(implementer) 然后再在该Vendor的所有型号中匹配part_id，才能获取到具体的信息；这里列出目前系统中已有的Vendor列表和其ID对应关系，以及主流厂商的主要型号映射关系： Vendor映射关系： Vendor Name Vendor ID ARM 0x41 Broadcom 0x42 Cavium 0x43 DigitalEquipment 0x44 HiSilicon 0x48 Infineon 0x49 Freescale 0x4D NVIDIA 0x4E APM 0x50 Qualcomm 0x51 Marvell 0x56 Intel 0x69 型号映射关系ARM Part ID Model Name 0xd03 Cortex-a53 0xd07 Cortex-a57 0xd08 Cortex-a72 Broadcom Part ID Model Name 0x0f Brahma B15 0x100 Brahma B53 Cavium Part ID Model Name 0x0af Thunder X2 29xx Qualcomm Part ID Model Name 0xc00 Falkor HiSilicon Part ID Model Name 0xd01 Kunpeng-920","link":"/2020/04/03/arm-cpu-vendor-ji-part-id-ying-she-guan-xi-chi-xu-geng-xin/"},{"title":"ARM: Points to be noted","text":"作者： Amit Dattatray Khandekar原文链接：https://amitdkhan-pg.blogspot.com/ The story of ARM began in 1993 with a joint venture of Apple with ARM (then Acorn RISC Machines) to launch the “Apple Newton” handheld PC. And the story continues today with news that Apple is going to switch their MACs to ARM processors. What has not changed in the story is ARM’s reputation as a power-efficient processor. This is the primary reason why it is so popular in smarthphones, and why it has made its way into smart cars, drones and other internet-of-things devices where it is crucial to preserve battery life and minimize heat generation. Today even data centers can run on ARM. Due to such widespread market disruption happening, I thought about putting some specific points which I think are good-to-know for users and software developers who have just begun using the ARM ecosystem … The reason why ARM power consumption is less has to do with the inherent nature of RISC architecture on which ARM is based. RISC instructions are so simple that each of them requires only one clock cycle to execute; so they require less transistors, and hence less power is required and less heat is generated. Ok, but then why ARM processors started making their way into data centers? After all, mobile phones and data centers don’t have anything in common. Or do they? Well, both consume power, and both need to perform well for a given price. Even though data centers are huge as compared to the size of a mobile phone, their CPU usage is also huge. So power efficiency is equally important. And so is the price for a given performance. Divide and conquer So, just replace the existing expensive processors with more number of cheaper ARM processors, so that the total CPU power will be equal to the existing power ? Yes, this does work. Suppose, there are 4 CPUs serving 16 parallel processes, it’s better for them to be instead served by 8 or 16 lower performing CPUs. Overall throughput will likely be higher. But what if there is a single long database query which needs high CPU power ? Even here, the database query can make use of multiple CPUs to run a parallelized query. Here we see that even the software needs to adapt to this paradigm shift: divide the task into number of parallel tasks wherever possible. We need to understand the fact that more than the power of a single CPU, what counts is the total power of all the CPUs. Another thing is that, the worloads are not always high. For instance, cloud service workloads are always mixed, frequently with numerous small tasks, where again a server with large number of low power CPUs fits well. big.LITTLE In the ARM’s big.LITTLE architecture, there can be two or more cores of different performance capacity in the same SoC. And if the workload processed by one of them changes, the other one can take over that workload on the fly if it is more suitable for the changed workload. This way unnecessary power usage and heat generation is prevented because the low-power processor type gets chosen. There has been support for doing such scheduling particularly for big.LITTLE in the linux kernel. ARM’s licensing model As many of you might know, ARM does not manufacture chips; it designs them. And it’s clients buy its license to manufacture chips based on ARM’s design. Now, there are two kinds of licenses. One is the core license. When a company buys the core license, it has to manufacture the complete CPU core using ARM’s in-house core design without modifying it. The ARM’s family of core designs that it licenses, are named Cortex-A**. E.g. in Qualcomm’s Snapdragon 855 chipset, all CPU cores are based on Cortex-A series; it means they used the ARM core license. The other is the ARM architecture license. When a company buys this license and not the core license, it has to design it’s own core, but the core design has to be compatible with the ARM instruction set. Such cores are often called custom cores, because they have their own micro-architecture that is not designed by ARM. This provides flexibility to the big companies to build cores as per their own needs. Companies like Qualcomm, Huawei, Apple and Samsung have built such custom cores. The beauty of this licensing model is : the ready-made core design is available to just anybody (of course a license has to be bought). And hence there are a number of vendors who all have manufactured compatibile chips. This drives innovation and competition. Applications Applications for mobile devices were already written from scratch on ARM processers. But what about the software running on servers ? Well, Linux kernel has support for ARM, so OSes like Ubuntu, CentOS and Debian already have officially supported ARM images. Furthermore, if you are running on, say Ubuntu, almost all the usual x86 packages that are present in the Ubuntu repository are already there for ARM as well, at least for ARMv8. I was able to install the PostgreSQL database package, and have been running pgbench with high contention, and it runs just fine. (Probably in later blogs, I will elaborate on PostgreSQL further) Also, the compilers like gcc/g++ are already tuned for ARM architecture, so most of the hardware-specific compiler optimizations are transparently done for ARM. But when it comes to running software meant for data servers, a lot of adaptation might be required to have a reasonable performance. For instance, applications have to be aware of the implications of the ARM’s weak memory model, especially for code synchronizatoin. Secondly, they should leverage in-built ARM capabilities like NEON (which is the ARM’s brand name for SIMD) to parallelize same operation on multiple data; and so on. A lot of research and analysis is going on to optimize sofware running in the ARM ecosystem as a whole. But we are already seeing a gradual transition and adaptation to this ecosystem.","link":"/2020/04/24/arm-points-to-be-noted/"},{"title":"ARM's LSE (for atomics) and MySQL","text":"译者: bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/ARM-LSE-and-MySQL/ 来看Mysql大牛Krunal带你分析LSE在Mysql上的情况。 中文 English ARM’s LSE (for atomics) and MySQLARM 在其 ARMv8.1规范中引入了 LSE (Large System Extensions)。这意味着如果你的处理器是兼容 ARMv8.1的，它将支持 LSE。LSE 的目的是优化原子指令，通过使用单个 CAS (比较并交换)或 SWP (用于交换)等替换旧式的独占负载存储… … 众所周知，上述扩展本质上会提高使用原子的应用程序的性能。 理解LSE为了更好地理解 LSE，让我们看一个工作示例，看看代码是如何生成的，以及可能的优化。 LSE turned off 正如您所看到的，有一个用于执行 CAS 的循环。加载值，检查期望值，如果不同，然后存储值。主循环是一个5步进程与2个独占指令与各自的内存顺序。SWAP 也有一个检查存储是否成功的循环。 ARM 有多种不同的加载/存储指令，因此在继续之前，让我们花一分钟理解这些变体。 stlxrb: 与发布语义/排序互斥的存储。提供对上述cacheline的独占访问权。“b”表示字节。（其他 half-word (2), word(4), double-word (8))。 stlrb: 与发布语义/排序互斥的存储。帮助建议只进行语义排序，而不进行独占访问。 strb: 非原子变量的普通存储(没有排序语义) 自然有人会问，为什么 seq-cst 和 release memory order 都会产生相同的asm指令。这是因为 ARM-v8中的store-release in ARM-v8 is multi-copy atomic，也就是说，如果一个agent看到了存储-释放，那么所有agent 都看到了存储-释放。没有要求普通存储为多拷贝原子存储。[类似于 x86_64中的 mov+fence 或 xchg ]。 LSE 开启所以现在让我们看看如果我们现在打开 lse 会发生什么。LSE 支持是在 ARM-v8.1规范中添加的，因此如果默认编译已经完成，gcc 将尝试使二进制文件与更广泛的 aarch64处理器兼容，并且可能无法启用特定的功能。为了支持 lse 用户需要指定额外的编译标志: 有多种方式打开lse: 使用 gcc-6+ 编译，指定 lse 标志为-march = armv8-a+lse 通过指定 ARMv8.1(或更高版本)使用 gcc-6+ 编译(这将自动启用所有 ARMv8.1功能)。-march = ARMv8.1-a 不再有 while 循环。单条指令(CASALB)执行比较和交换(负责加载和存储) ，与 SWAPLB 执行交换的方法相同。看起来是进行了优化。更多关于性能的信息请见下文。 但是有一个问题，如果二进制文件是用 +lse 支持编译的，但是目标计算机不支持 lse，因为它只与 arm-v8兼容。通过引入 -moutline-atomics ，gcc-9.4+ 解决了这个问题(使用-mno-outline-atomics禁用 gcc-10.1启用的默认值)。GCC 自动匹配带有动态检查变量(lse 和 non-lse)的代码。运行时作出决定，并执行相应的变量。 让我们看看如果使用 gcc-10(使用 -moutline-atomic使其在所有 aarch64机器上兼容)编译会发生什么) code asm (perf output) bool expected = true; flag.compare_exchange_strong(expected, false); &lt;aarch64_cas1_acq_rel&gt;: __aarch64_cas1_acq_rel(): │ adrp x16, 11000 &lt;data_start&gt; │ ldrb w16, [x16, #25] │ ↓ cbz w16, 14 │ casalb w0, w1, [x2] │ ← ret │14: uxtb w16, w0 │ 18: ldaxrb w0, [x2] │ cmp w0, w16 │ ↓ b.ne 2c │ stlxrb w17, w1, [x2] │ ↑ cbnz w17, 18 │2c: ← ret 请注意用于选择适当逻辑的分支指令(用绿色突出显示)。 LSE 的表现虽然这些听起来很有趣，但是真的有帮助吗？如果新的指令需要更多的周期怎么办。只有一种方法可以找到答案: 基准测试。 基准测试: 每个线程(总共 n 个线程)都尝试获得锁，这会导致严重的争用。一旦线程拥有了互斥锁，它就会执行基于 crc32的软件，在释放它之前让 cpu 一直处于繁忙状态。每个线程都执行这个流程 m 次。 Machine: Bare-Metal with 128 cores ARM Kunpeng 920 2.6 Ghz. 用例表示一个严重的争用，每个线程主要花费时间获得锁。这样的工作负载非常快(crc32在16KB 块上) 这清楚地证明，LSE严重争用的条件下起到帮助作用。 但是微基准测试由于应用本身的特性，包括其他重叠部分，如 IO、其他处理元素等，有时不能显示原始应用所需的增益。.现在让我们评估一下lse使能在 MySQL 性能。 MySQL benchmarking with LSE环境描述: Server: MySQL-8.0.21, OS: CentOS-7 Sysbench based point-select, read-only, read-write, update-index and update-non-index workload. Executed for higher scalability (&gt;= 64) to explore contention. Configuration: 32 cores (single NUMA) ARM Kunpeng 920 2.6 Ghz (28 cores for server, 4 for sysbench) Tried 2 use-cases uniform, zipfian (more contention) baseline=lse-disabled, lse=lse-enabled (-march=armv8-a+lse). 观察结果: 在Uniform cases ，使用LSE下，我们几乎看不到任何区别 在Zipfian cases, LSE对于更新用例，会略微退化，但是始终如一(2-4%). 总结LSE 作为特性看起来很有前途，但在 MySQL 用例中确实没有多少提升。可能一旦 MySQL 被调整到使用更多的原子，LSE 可能会显示 +ve 的差异。在那之前，如果不启用 LSE，我们在Mysql不会失去任何性能。 如果有疑问，请联系我，或在下方留言 ARM introduced LSE (Large System Extensions) as part of its ARMv8.1 specs. This means if your processor is ARMv8.1 compatible it would support LSE. LSE are meant to optimize atomic instructions by replacing the old styled exclusive load-store using a single CAS (compare-and-swap) or SWP (for exchange), etc…. Said extensions are known to inherently increase performance of applications using atomics. Understanding LSETo better understand LSE let’s take a working example to see how the code is generated and possible optimization. LSE turned off As you can see there is a loop for doing CAS. Load the value, check with expected value and if different then store the value. Main loop is a 5 step process with 2 exclusive instructions with respective memory ordering. SWAP too has a loop for checking if the store is successful. ARM has multiple variant of load/store instructions so before we proceed let’s take a minute to understand these variants. stlxrb: store exclusive with release semantics/ordering. Provide exclusive access to the said cache line. “b” represents byte. (other variant half-word (2), word(4), double-word (8)). stlrb: store with release semantics/ordering helping suggest ordering semantics only but not exclusive access. strb: normal store to a non-atomic variable (no ordering semantics) Naturally one may ask how come both seq-cst and release memory order generate the same asm instruction. This is because store-release in ARM-v8 is multi-copy atomic, that is, if one agent has seen a store-release, then all agents have seen the store-release. There are no requirements for ordinary stores to be multi-copy atomic. [Something similar to mov+fence or xchg in x86_64 domain]. LSE turned onSo let’s now see what would happen if we now turn-lse on. LSE support was added with ARM-v8.1 specs and so if the default compilation is done, gcc will try to make binary compatible with a wider aarch64 processors and may not enable the specific functionality. In order to enable lse user need to specify extra compilation flags: There are multiple ways to turn-on lse: Compile with gcc-6+ by specifying lse flag as -march=armv8-a+lse Compile with gcc-6+ by specifying ARMv8.1 (or higher) (that will auto-enable all ARMv8.1 functionalities). -march=armv8.1-a No more while loop. Single instruction (CASALB) to do the compare and swap (that takes care of load and store) and same way SWAPLB to do the exchange. Sounds optimized. More about performance below. But there is one problem, what if binaries are compiled with +lse support but the target machine doesn’t support lse as it is only arm-v8 compatible. This problem is solved with gcc-9.4+ by introducing -moutline-atomics (default enabled with gcc-10.1 can be disabled with -mno-outline-atomics). GCC auto emits a code with dynamic check with both variants (lse and non-lse). Runtime a decision is taken and accordingly said variant is executed. Let’s see what is emitted if compiled with gcc-10 (with -moutline-atomic making it compatible on all aarch64 machines) code asm (perf output) bool expected = true; flag.compare_exchange_strong(expected, false); &lt;aarch64_cas1_acq_rel&gt;: __aarch64_cas1_acq_rel(): │ adrp x16, 11000 &lt;data_start&gt; │ ldrb w16, [x16, #25] │ ↓ cbz w16, 14 │ casalb w0, w1, [x2] │ ← ret │14: uxtb w16, w0 │ 18: ldaxrb w0, [x2] │ cmp w0, w16 │ ↓ b.ne 2c │ stlxrb w17, w1, [x2] │ ↑ cbnz w17, 18 │2c: ← ret Notice the branching instruction (highlighted in green) to select appropriate logic. LSE in actionWhile all this sounds interesting but does it really help? What if the new instruction takes more cycles. Only one way to find out: Benchmark. Benchmark: Simple spin-mutex with each thread (total N threads) trying to get the lock there-by causing heavy contention. Once the thread has the mutex it performs software based crc32 keeping the cpu bit busy before releasing it. Each thread does this M times. Machine: Bare-Metal with 128 cores ARM Kunpeng 920 2.6 Ghz. Use-case represent a serious contention with each thread mostly spending time for obtaining lock. Workload as such is pretty quick (crc32 on 16KB block). This clearly proves that LSE helps in heavily contented cases. But micro-benchmark sometime fails to show the needed gain with original application due to nature of application including other overlap components like IO, other processing element, etc… So let’s now evaluate MySQL performance with lse-enabled. MySQL benchmarking with LSEWorkload: Server: MySQL-8.0.21, OS: CentOS-7 Sysbench based point-select, read-only, read-write, update-index and update-non-index workload. Executed for higher scalability (&gt;= 64) to explore contention. Configuration: 32 cores (single NUMA) ARM Kunpeng 920 2.6 Ghz (28 cores for server, 4 for sysbench) Tried 2 use-cases uniform, zipfian (more contention) baseline=lse-disabled, lse=lse-enabled (-march=armv8-a+lse). Observations: With Uniform we hardly see any difference with use of LSE With Zipfian LSE tend to regress marginally but consistently (by 2-4%) for update use-cases. ConclusionLSE as feature looks promising but fails to perform in MySQL use-case. May be once MySQL is tuned to use more atomics, LSE could show a +ve difference. Till then nothing we would not loose if LSE is not enabled. If you have more questions/queries do let me know. Will try to answer them. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/08/04/arm-s-lse-for-atomics-and-mysql/"},{"title":"ARM vs X86 Hadoop 性能大比拼","text":"参与者：Ayush Saxena、郑振宇、刘胜 背景：2019年，本团队在 Apache Hadoop 开源社区上游完成了 ARM 平台适配并使能了 Hadoop ARM CI 以便保证 Hadoop 在后续的版本开发中均保证 ARM 平台适配，并且团队成员正在推动 Hadoop 开源社区发布 ARM 平台的软件包，以便用户可以直接下载使用。在 ARM 的基本适配工作完成后，性能调优成了我们下一步的工作重心。 近期，华为计算开源生态部技术团队进行了 Apache Hadoop 在 ARM 及 X86 平台上的初步性能比拼测试及简要分析，可以为关心 ARM 数据中心大数据场景的读者提供一些参考。 测试环境及工具本次测试使用华为云，我们在华为云上搭建了两套三节点测试集群（一套ARM，一套X86），个节点均为8vCPU 16GB RAM，但在CPU指标上，由于硬件限制，X86集群使用 Intel Xeon Gold 6266C 主频为 3.0 GHz 而 ARM 节点使用 Huawei Kunpeng 920 主频为 2.6 GHz，但从成本角度来看，ARM 节点的单价仅为 X86 节点单价的 70%，在参考性能比拼结果时，需要考虑上述指标。硬盘方面，我们使用了IOPS上限4,200，IOPS突发上限5,000的500G硬盘作为系统盘；网络方面，为虚拟机配置了5Mbit/s的带宽。 本次测试分别对上述Hadoop集群进行了业界常用的TeraSort测试，结合Hadoop支持的各种压缩算法，对50GB数据进行TeraSort对比测试，并对测试结果进行简要分析。 测试数据及简要分析首先，需要再次明确的是，本次测试所使用的CPU在主频方面并不相同，大约有13%的性能差距(2.6G Hz vs 3.0GHz)，我们可以对性能指标乘以一定的系数来进行平衡，但由于ARMv8以及X86指令集自身的不同，简单的系数并不能完全反映出实际情况。这里我们先通过简单系数的方式来进行初步的理论分析，来看一看Apache Hadoop在ARM运行在ARM数据中心上是否与运行在X86数据中心上有可比性，为读者提供一定的参考；后面我们也会继续探索更为合理和精确的对比方式。 从上面得测试数据可以发现，ARM平台上的表现整体比X86稍差，性能差距大约在10%-20%之间；将我们上面提到的CPU主频大约有13%的性能差距考虑在内，ARM平台上的整体表现与X86平台上的性能表现之间的差距大约在10%以内。 针对这一情况，我们进行了更进一步的分析，分析结果表明，ARM平台在Mapper阶段（包括QuickSort和压缩）表现的较X86平台要差；而在Reducer阶段（包括MergeSort和解压缩）ARM的表现较X86平台要更好；通过优化Mapper阶段的实现，ARM平台的性能有可能超越X86平台。在压缩环节，ARM耗时较X86落后的比较多，同时ZSTD是当前在ARM平台上表现的最好的压缩算法，与X86之间的性能差距最小。 除了Hadoop本身代码上的区别，我们还发现在ARM平台和X86平台上启动JVM的性能有所差距，这里我们单独编写了一份脚本来进行测试，在这个脚本中我们将启动Mapper和Reducer各1500个，然后退出，用于观察启动JVM的性能差距： 从结果可以看出，在这项对比中，ARM与X86相比也有15%-18%的性能差距，同样，CPU主频是否对该时间有影响并且有多大的影响也是需要进行进一步分析的。但是，从这个测试我们可以得到一个结论，那就是如果可以重用JVM，那么可以一定程度上缩小ARM和X86之间的性能差距。 总结及后续工作 总体来说，Apache Hadoop运行在ARM数据中心上与运行在X86数据中心上在性能上约有10%到20%的性能差距，将CPU主频差别考虑进去后，ARM与X86的整体性能差距基本在10%以内。 ARM在Mapper阶段性能较X86差，但是在Reducer阶段较X86性能好；更进一步来看，ARM在Mapper阶段的数据压缩阶段性能与X86相比差距较为明显，其中ZSTD的差距最小。 ARM和X86目前在启动JVM方面约有15%-18%的性能差距，如果可以在MR中重用JVM，那么可以一定程度上缩小ARM和X86之间的性能差距。 从性价比角度考虑，当前测试所使用的ARM集群成本仅为X86集群成本的70%，但性能差距只有10%-20%。可以预见，同等成本的ARM集群将能够提供与X86集群同等性能、甚至更好的性能，因此ARM数据中心在大数据领域还是十分有实用价值的。 后续，我们将持续进行更为细致的测试，并且根据测试结果推动社区上游进行有针对性的改进，逐步缩小ARM与X86之间的性能差距。","link":"/2020/04/24/arm-vs-x86-hadoop-xing-neng-da-bi-pin/"},{"title":"ARM vs X86 Mysql性能大比拼","text":"译者：bzhaoopenstack 原文链接：https://mysqlonarm.github.io/MySQL-on-x86-vs-ARM/ 作者: Krunal Bauskar 在开始探索这一领域之前，我相信大家对这个话题都会非常感兴趣，包括本人在内。另外，在深入讨论具体的数据前，让我们先来了解一下两种架构之间的基本差异。除了CISC和RISC之外，让我们从Mysql的角度来看待这些重要的差异。 强 vs 弱内存模型 (弱内存模型在无锁写场景下需要适当的内存屏障). 底层硬件特定专用指令。例如：两者现在都支持crc32c硬件指令，但是底层调用它们的方式不同。更多指令差异请参看x86-SSE/ARM-ACLE。 Cache Line 差异。 大多数ARM处理器倾向于使用更大的cacheline size (所有缓存以128 bytes为单位或者 64/128字节混合的方式)。 其他系统调用级别的差异，如：ARM的PAUSE指令缺失和具有非常低延迟的替代指令无法引导硬件达到所需的延迟，sched_getcpu在ARM上引入了使用无锁构造的挑战，内存操作似乎带来更高的延迟等。 Mysql社区已经为这个领域的问题贡献了多个补丁（另一个博客的主题）。自从MySQL刚刚宣称开始支持ARM架构以来，几乎没有什么优化，大部分工作仍然没有完成。 性能现在让我们来看看最重要的方面：性能 我们在x86和ARM上测试了MySQL（当前版本8.0.19）的性能。试验步骤和机器详情如下。 测试步骤 24核/48GB Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz，用于在x86上运行MySQL数据库软件。 24核/48GB ARM @ 2.60GHz，用于在ARM上运行MySQL sysbench运行在一台专用的机器，且位于相同的数据中心。 sysbench步骤: 加载测试表. (相同的数据库被多次运行重用，所以需要预热). Checksum预热。对所有表执行checksum。对于checksum,流程中需要获取bufferpool中的行记录。 Query 预热。 如果您使用的是自适应哈希索引，可以跳过此节，但它确实有些效果。 执行测试套件 (oltp-read-write/oltp-update-index/oltp-update-non-index/oltp-read-only/oltp-point-select) 每个测试套件以多种不同的扩展性来执行。如对于24 vCPU，尝试多threads 1/2/4/8/16/32/128/256. 在切换测试套件中间，引入一些睡眠操作确保之前的测试套件完全运行完毕。虽然这不能保证所有的数据库刷新都完成了，但是X秒的睡眠可以保证对后续测试套件的影响最小。 MySQL-Server Configuration: 足够大的BP(bufferpool) ，以保证可以存储完整的数据 了解更多配置详情，参看 以下配置 运行脚本和调用sysbench的自动化测试脚本细节在 这里 测试运行具体细节: Table: 96-tables * 150万数据 (data-size= 34GB) Buffer Pool: 36GB Redo-Log: 4GB*2 TC-run-time: 300 secs TC-warmup: 60 (sysbench –warmup-time) workload-query-based warmup: 600 change-over-sleep: 180 checksum-based-warmup: enabled data-storage: 300GB (支持16500 IOPS(对Burst IOPS无效果).) 注: Frequency Scaling (FS)频率缩放. 所述ARM 主频规格2.6 GHz vs x86主频规格3.0 GHz。直接比较它们的数据是不公平的。为了补偿频率差，下面的图还为ARM添加了频率调整 tps/qps（ARM-fscaled简单地按(3/2.6）的算法基于原始数据算出ARM tps/qps数据)。在现实生活中，考虑到CPU频率的增加会影响争用曲线图和等待周期，这个影响因素可能会稍微高一些。 1. Point Select: threads ARM (qps) x86 (qps) ARM (qps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 6696 6439 7726 4 20 2 12482 11774 14402 6 22 4 23881 21308 27555 12 29 8 45993 42110 53069 9 26 16 88517 81239 102135 9 26 32 142974 136724 164970 5 21 64 198839 212484 229430 -6 8 128 217778 241555 251282 -10 4 256 209797 224009 242073 -6 8 分析: ARM在较低扩展性上性能比X86要好，但是在扩展到与cpu数目相近的threads时，性能就开始下降了 在频率缩放下，尽管存在扩展性问题，ARM仍然击败X86 2. Read Only: threads ARM (qps) x86 (qps) ARM (qps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 5222 5259 6025 -1 15 2 10333 10200 11923 1 17 4 19176 19349 22126 -1 14 8 36881 37035 42555 0 15 16 70337 67065 81158 5 21 32 109207 113210 126008 -4 11 64 139294 164148 160724 -15 -2 128 151382 175872 174672 -14 -1 256 149136 164382 172080 -9 5 分析: 在低扩展性上，ARM与X86基本持平，在较高扩展性败于X86 应用频率缩放，ARM在大多数场景下继续击败X86 3. Read Write: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 137 149 158 -8 6 2 251 273 290 -8 6 4 462 502 533 -8 6 8 852 920 983 -7 7 16 1539 1678 1776 -8 6 32 2556 2906 2949 -12 1 64 3770 5158 4350 -27 -16 128 5015 8131 5787 -38 -29 256 5676 8562 6549 -34 -24 分析: 在read-write测试套件中情况有些不同。ARM开始落后了。在低扩展性情况下，频率缩放会减缓这种落后，在高扩展性则持续增大了差距。 4. Update Index: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 328 373 378 -12 1 2 623 768 719 -19 -6 4 1060 1148 1223 -8 7 8 1905 2028 2198 -6 8 16 3284 3590 3789 -9 6 32 5543 6275 6396 -12 2 64 9138 10381 10544 -12 2 128 13879 16868 16014 -18 -5 256 19954 25459 23024 -22 -10 分析: 频率缩放下，ARM继续与X86处于同等/更好的状态 (除了高竞争用例) 5. Update Non-Index: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 328 373 378 -12 1 2 588 686 678 -14 -1 4 1075 1118 1240 -4 11 8 1941 2043 2240 -5 10 16 3367 3662 3885 -8 6 32 5681 6438 6555 -12 2 64 9328 10631 10763 -12 1 128 14158 17245 16336 -18 -5 256 20377 26367 23512 -23 -11 分析: 频率缩放下，ARM继续与X86处于同等/更好的状态 (除了高竞争用例) 结论基于以上的数据，我们能够得到如下结论: 在只读场景中测试Mysql, ARM和X86性能几乎一致。 在涉及写场景中测试Mysql，ARM开始有些落后，但是如果我们考虑频率缩放，情况可能会好一点。 在生活里，我们通常不会考虑频率缩放，而会考虑他们的性价比。这是一个话题，但通常是事实：ARM实例比X86实例便宜34%（我们在测试中用相同的flavor 24U48G）。 有一点我们需要持续观察，就是， ARM工作负载在达到CPU限制之前具有很好的可伸缩性。随着可伸缩性的增强，争用增加，ARM开始滞后。这是因为互斥/竞争热点都是针对x86调优的（例如：自旋锁 spin-lock）。现在MySQL正式支持ARM，并且ARM的社区和来自各地开发者的兴趣也不断增长，所以Mysql社区也会针对ARM进行调优，让我们拭目以待把。 总之，Mysql on ARM是一个值得从成本和性能角度来尝试的选择。 如果你还有问题/疑问，请告诉我。我会试着去回答。","link":"/2020/04/22/arm-vs-x86-mysql-xing-neng-da-bi-pin/"},{"title":"ARM, 真的来了！","text":"译者：bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/Why-ARM/ 中文 English ARM处理器无处不在。 很有可能你们中的一些人在阅读这篇博客时，使用的是 基于ARM 驱动的设备。 电话，物联网设备，家用电器，医疗设备，都是由 ARM 处理器驱动的。 ARM处理器以节能著称，因此大多数需要较长充电周期且处理器能力较低的设备一直在使用ARM芯片。 但在过去的几年里，这种情况已经发生了变化。 越来越多的 ARM 处理器被用于数据库服务器、 web 服务器、应用服务器、大数据场景等高端应用。 它们已经作为服务器芯片进入了数据中心。 在云上运行应用程序时，ARM芯片被视为一种具有成本效益的最佳选择。 ARM 生态之进化几年前，很难想象 ARM 会被用于运行在一些高端的服务器级的应用程序。 我可以想出两个主要原因: Arm 最适合小型手持设备 Arm 生态受到它所支持的特定产品的限制 一些主要的操作系统提供商对 ARM 生态系统提供了支持，包括 RedHat (CentOS)、 Ubuntu、 Debian 和 Windows。 这使得主流软件可以轻松地移植到 ARM。 社区推动ARM以确保大多数主流软件都可以在 ARM架构上使用。 例如IDE、 DB-server、 Hadoop 及其衍生软件，包括 Apache 基金会、 CI/CD软件、容器、虚拟化软件等等。 . 授权其他厂商和开发自己的 ARM 处理器的 ARM 商业模式进一步推动了其受欢迎的程度，吸引了更多的芯片设计师参与其中，相互合作和创新优化。 随着亚马逊等主要云供应商开始提供基于 ARM 处理器的 EC2实例(目前只允许邀请) ，这意味着现在每个人都可以启动一个 ARM 实例，并开始在 ARM 上开发 / 移植他们想要的软件。 这非常有助于ARM生态的进一步发展。 那…还缺什么?虽然大部分主流软件已经移植到 ARM 上，但它们还没有针对 ARM 进行优化。 Arm 具有弱内存模型，可以在更小的空间内安置更多的内核，底层指令的不同(软件会用这些指令)等等。 这是 ARM 生态第二阶段的开始，社区 / 开发人员 / 用户开始从“在 ARM 上运行软件”导向“在 ARM 上优化软件”。 我认为当用户开始认真思考 ARM 并开始在 ARM 上优化他们的软件时，这是 ARM 社区乃至ARM生态的一个重大胜利(大大的里程碑)。 这(尤其是优化)是一个永无止境的过程，我看的第一个目标是至少与 x86的部分性能相当。 我故意说“ 部分性能” ，因为每个架构都有自己的 USP，所以如果你将一个企业级应用程序移植到 ARM，并且你可以以 50% 的成本(运营成本 + 初始投资)外加x86芯片的75% 性能的ARM芯片提供给客户 ，我认为这对大多数客户来说仍然是极具吸引力的(特尤其是应用程序为可伸缩的场景)。 当然，这并不意味着所有的应用程序在 ARM 上运行的速度都比较低下，事实上，有些应用程序在 ARM 上运行的速度会比 x86快，而且由于ARM生态的优化阶段在未来几年才逐步开始，经过各个玩家的努力，可以推断许多应用程序在 ARM 上运行的速度将比其他架构更快、更猛。 ARM节能环保 ！ARM无处不在，尤其是数据中心运营商(无论大小)最关心的问题。 与其他架构相比，ARM 可以节省大约50% 的电力。 这有助于支持绿色环保倡议。 ARM是下一代处理器！有趣的是，我为什么这样称呼ARM。 下一代的芯片正在积极地使用 Andrino、 Raspberry Pi、 Odroid、 Banana Pi、 Asus tinker board 等工具包来构建下一代系统。 这些芯片将定义下一代计算机。 你看到它们正在使用 ARM，并且已经围绕着 ARM 成长起来，变得更加通用，在未来的几年里，将会有一大批 ARM 用户 / 开发者簇拥在一起，共建ARM生态。 一旦大量的ARM用户/开发者的支持到位，现阶段围绕 ARM正在紧锣密鼓进行的所有基础工作和有助于用户的事物将会迎来新的面貌。 ARM上台式机 / 笔记本！如果我们开始看到基于 ARM 的办公桌面 / PC工作站 / 笔记本电脑(已经有了！)被大家普遍使用时，ARM挤占台式机/笔记本市场也就不足为奇了。 总结Arm 生态系统看起来非常迷人，其中充满了新的挑战和机遇。 畅想一下近十年，从微型可穿戴设备到高端电影体验，从自动驾驶助力车 / 汽车到大型喷气式飞机 / 太空飞行器，都会被基于 ARM 的处理器主宰，它将无处不在。 现阶段据估计，每人有35个基于 ARM的设备。 这就是机会的海洋，不是吗?! 如果您有想法，请随时发送邮件交流 ARM processors are everywhere. It is quite likely some of you may be reading this blog from an ARM powered device. Phone, IoT devices, consumer and home appliances, health-care devices, all are powered by ARM processors. ARM processors are known to be power efficient and so most of these devices that demands a long recharge cycle but less processing power started using them. But this has changed in the past few years. More and more ARM processors are being used for high-end applications like database server, web server, application server, big data use-cases. They have already made their way to the data-centers as a server class machines. They are being looked upon as a cost effective option while running applications in cloud. ARM ecosystem evolutionFew years back it was difficult to imagine that ARM would be used for running some high-end server class applications. There were 2 major reasons that I could think off: ARM were best suited for small handheld devices. ARM ecosystem was limited around the specific product it supported. ARM ecosystem has really picked up well after some major OS providers added support for it including RedHat (CentOS), Ubuntu, Debian, Windows. This eased out porting of the major softwares to ARM. ARM community gave it a push to make sure most of the standard softwares are available on ARM viz. IDE, DB-server, Hadoop and all its variants from Apache Foundation, CI/CD software, Container, Virtualization, etc… The ARM model that allows other vendors to license and develop their own ARM processors further helped fueled its popularity with more chip designers joining, collaborating and innovating. Break-through came with major cloud providers like Amazon started providing ec2 instances (currently invitation only) based on ARM processors this means now everyone can boot an ARM instance and start developing/porting their software on ARM. This helped further grow the ecosystem. What was missing?Though most of these software have been ported to ARM they were not yet optimized for ARM. ARM has a weak memory model, can fit more cores in smaller space, difference in low-level instruction (for software that uses them), etc.. This was the start of the 2nd phase of ARM where the community/developer/user started moving from “running software on arm” -&gt; “optimizing software on arm”. I think this was a major win for the arm community when users started to think ARM seriously and started spending efforts on optimizing their software on ARM. This (especially optimization) is a never ending process but I see first goal is to at-least be on par with x86. I purposely say “onpar” because each of architecture has its own USP so say if you port an enterprise class application to ARM and you can offer it to customer @ 50% of the cost (operating cost + initial investment) for 75% of the performance of x86 I think that would be still be attractive fit for most of the customers (especially given application are horizontally scalable). Of-course that doesn’t mean all applications run on ARM at reduced speed, in fact there are applications that run on ARM faster than x86 and since the optimization phase has just started in next few years a lot of applications would be running on ARM faster than other architectures. Go GreenIt is everywhere and especially a matter of major concern for data-center operators (small or big). ARM being power efficient can save approximately 50% of the power compared to other architecture. This makes it help support Go-Green initiative. ARM is Next-Gen processorIt is interesting why I referred to it this way. Next generation kids are actively using kits like Andrino, Raspberry Pi, Odroid, Banana Pi, Asus tinker board, etc…. to build some of the next-gen system. These kids will be defining the next generation of computing. Given they started with ARM their social community has grown around ARM in the next few years there would be an army of ARM users/developers with a very active community. All the groundwork and good things that are being built at this stage around ARM will be pushed to the next level once this workforce becomes active. ARM in Desktop/LaptopThis is catching up fast and no wonder if we start seeing ARM based Desktop/PC workstation/Laptop (there are already few) commonly being used. ConclusionThe ARM Ecosystem looks a lot more fascinating and full of new challenges and opportunities. Current decade will be ruled by ARM based processors and it will be everywhere from tiny wearable devices to high-end movie experience, from auto-driving cycle/car to jumbo jet/space-craft. It is estimated that there would be 35 active ARM power devices per person. That’s Ocean of Opportunity. If you have any comments feel free to drop an email (check about section) .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/04/24/arm-zhen-de-lai-liao/"},{"title":"ARM: 需要了解的背景和问题","text":"译者： bzhaoopenstack作者： Amit Dattatray Khandekar原文链接：https://amitdkhan-pg.blogspot.com/ Arm 的故事始于1993年，当时苹果与 ARM (当时是 Acorn RISC Machines)组建了一家合资企业，推出了“ Apple Newton”掌上电脑。 这个故事今天还在继续，有消息称苹果将把他们的 Mac换成 ARM 处理器，在这里 ARM 仍然以节能处理器的角色出现。 这是它在智能手机中如此受欢迎，也是它进入智能汽车、无人机和其他物联网设备的主要原因，在这些设备中，电池寿命保持和硬件尽量减少热量的产生是至关重要的。 今天，甚至是数据中心也可以在 ARM 上运行。 由于市场的巨大变更，在此，我考虑抛出关于主角ARM的一些观点，这些观点对于刚刚开始接触 ARM 生态系统的用户和软件开发人员是十分有益的.. Arm 能耗较低的原因与 其所基于的 RISC的硬件架构有关。 RISC 指令非常简单，每个指令执行只需要一个CPU时钟周期; 因此它们需要更少的晶体管，更少的功率，从而产生更少的热量。 OK，是什么促使ARM 处理器开始进入数据中心市场呢？ 毕竟，移动电话和数据中心没有任何共同点。 不是吗？ 好吧，两者都消耗电力，并且都需要在拟定的成本下表现良好。 尽管数据中心与手机相比是巨大的，同时它们对 CPU需求和 使用量也是巨大的。 对于两个场景功率效率非常重要，能达到市场需求的性能成本也是一样。 分而治之 那么，我们就用更多的，又便宜的 ARM 处理器来替换现有的数据中心中昂贵的处理器不就好了，这样总的 CPU 功耗不就等于现有的功耗了吗？ 是的，这确实有用。 假设有4个 cpu 承载16个并行进程，那么最好的办法是将4个高性能CPU替换为8到16个性能较差的 cpu ，这样总吞吐量可能会更高。 但是，当有一个数据库长查询，需要消耗高性能 CPU 的能力时？ 即便在这个时候，这个数据库查询请求也可以使用多个 较低性能的cpu 来并行查询。 这里我们看到，即使是软件也需要适应这种范式转换: 就是尽可能地将任务划分为多个并行任务。 我们需要理解这样一个事实: 重要的不仅仅是单个 CPU 的能力，而是所有 CPU 的总能力。 big.LITTLE架构 在 ARM 的big.LITTLE架构中，在同一个 SoC 中可以有两个或多个具有不同性能的核。 如果其中一个处理的工作负载发生变化，如果另一个核更适合已变化的工作负载的话，那么它可以动态地接管工作负载。 这种方式避免消耗不必要的电力和热量的产生，因为ARM定位是低功耗处理器，成本成本！！ 在 linux 内核中，这种调度已经得到了支持，特别是针对 big.LITTLE架构。 ARM的商业许可模式 正如我们许多人知道的那样，ARM 公司本身并不生产芯片，而是设计芯片。 它的客户购买了基于 ARM 架构设计的芯片制造许可证。 目前为止，有两种这样的许可证。 一种是核心许可证。 当一家公司购买核心许可证时，它必须使用 ARM 的内部核心设计制造完整的 CPU 核心，而不能做任何更改。 Arm 授权的核心系列名为 Cortex-A * * 。 例如，在高通的 Snapdragon 855芯片组中，所有的 CPU 核心都基于 Cortex-A 系列; 这意味着它们使用了 ARM 的核心许可证。 另一个是 ARM 架构许可证。 当一家公司购买这个许可证而不是核心许可证时，它必须设计自己的核心，但核心的设计必须与 ARM 指令集兼容。 这样的核心通常被称为定制核心，因为它们有自己的微结构，而不是由 ARM 设计的。 这为某些大公司根据自己的需要生产核心提供了灵活的条件。 高通(Qualcomm)、华为(huawei)、苹果(Apple)和三星(Samsung)等公司都制造了这种定制的核心。 这种许可模式的优点在于: 现成的核心设计可供任何人使用(当然需要购买许可证)。 因此，有许多厂商都制造了兼容的芯片。 从而进一步推动了芯片创新和竞争。 基于ARM的应用程序 移动设备的应用程序已经基于ARM 处理器上编写了。 但是在服务器上运行的软件呢？ 好吧，Linux 内核支持 ARM，所以像 Ubuntu，CentOS 和 Debian 这样的操作系统已经正式支持 ARM 镜像。 另外，如果你使用的是 Ubuntu，在Ubuntu 官方库中几乎所有常用的 x86依赖库都已经能安装在 ARM 上了，至少对于 ARMv8来说已经做了该做的porting。 我能够安装 PostgreSQL 数据库包，并且一直在高竞争的情况下运行 pgbench，并且运行得很好。 (可能在以后的博客中，我将进一步阐述 PostgreSQL)此外，gcc / g + + 等编译器已经针对 ARM 架构进行了调优，因此大多数硬件专用编译器都已完成了ARM架构相关的优化。 但是，当涉及到那些运行在数据服务器的软件时，可能需要进行大量的适配工作才能获得比较nice的性能。 例如，在做代码同步的时候，应用程序必须特别注意ARM 的弱内存模型。 其次，应用程序应该利用内置的 ARM 硬件方面的能力，比如 NEON (这是 ARM 对 SIMD 的品牌名称) 指令，以便在多数据流上并行操作等等。 对此，目前已经有很多开发者和团队正投身于大量的研究和分析，以优化整个 ARM 生态系统中的软件。 同时我们已经看到了这个ARM生态系统正在逐渐过渡、完善和适应市场。","link":"/2020/04/24/arm-xu-yao-liao-jie-de-bei-jing-he-wen-ti/"},{"title":"ARM上跑Mysql, 能行吗？","text":"译者：bzhaoopenstack 作者: Krunal Bauskar 原文链接: https://mysqlonarm.github.io/Running-MySQL-on-ARM/ 我相信在座的大多数都会有这个问题。事实上，在我开始主动开始#mysqlonarm 相关工作之前，我也有过同样的经历。在ARM上运行MySQL需要什么？真的有用吗？包依赖关系呢？它有什么样的表现？支持什么功能呢？社区支持这么玩吗？还有很多悬而未决的问题。。 让我们试着用简单的问答形式来回答这些问题。 Q: Mysql支持ARM架构吗?A:支持，Mysql官方支持ARM。可以从mysql.com站点下载可用的软件包。 Q: 支持啥OS?A: 目前支持RHEL-7 &amp; 8/Oracle-Linux- 7 &amp; 8，还没有发现发布其他OS的包。 Q: 我们能在ARM架构下从源代码在OS上(如ubuntu)构建Mysql吗?A: 可以，能玩。我一直在源码构建二进制包，使用的是当前mysql的release tag mysql-8.0.19。同样也可以在CentOS上玩。这也意味着所有需要的包依赖性问题都得到了解决，或已经可用。 Q: ARM上的工具链可用吗?A: 因为软件包是可用的，而且我能够从源代码构建它，所以默认的应用程序工具，如mysql shell/mysqladmin/mysqlslap/mysqldump/etc…，以及大量其他的默认程序都随二进制文件一起发布了。如果你关心某个特定的工具，告诉我，我会检查它们。现在，我尝试了一些我认为比较重要的工具，它们工作正常。 Q: MariaDB和Percona在ARM上是否支持各自的服务器规格?A: MariaDB Community Server软件包（来自MariaDB公司）在ARM (CentOS7/Ubuntu-16.04/18.04)上可用，MariaDB服务器工具在ARM上暂未正式发布。 Percona尚未正式支持ARM ，但我能够从源代码构建它（ MyRocks / TokuDB不可用）。 Q: 如果工具不可用。这能阻止我在ARM上尝试MySQL(或其衍生软件)吗？A: 不会，因为大多数工具都是符合mysql标准的，不是所谓的强绑定特定平台。所以你当然既可以把它们安装在X86，同时安装在ARM上(除非工具还没有移植到ARM上)。 Q: 社区支持这么玩吗?A: MySQL on ARM 已经有一段时间了。ARM、高通、华为等多家厂商积极贡献，Mysql社区发展迅速。在对Mysql ARM优化方面，社区呈现很大的兴趣，非常多的开发者想参与其中。挑战极具吸引力，然而最麻烦的是ARM硬件资源短缺。如果你有兴趣参与，和我聊聊（给我发一封电子邮件）。 Q: 看起来都还行。性能咋样?A: 这是一个大话题，所以我会在未来几天内发布多个关于这个话题的博文，但把它在一定范围内的表现是可比的。另一方面，ARM实例提供更好的价格比。 Q:可以从哪里获取帮助?由于软件包可以从MySQL官方下载，我假定他们的服务提供也应涵盖ARM。和MariaDB一样。当然，除了官方支持之外，还有普通团体和独立开发者。 Command to build MySQL on ARM12cmake .. -DWITH_NUMA=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=&lt;boost-dir&gt; -DCMAKE_INSTALL_PREFIX=&lt;dir-to-install&gt;make -j &lt;num-of-cores&gt; 因此，在ARM上构建Mysql不需要什么特殊的flag。(假设你已经安装了标准依赖). 它会默认使用”CMAKE_BUILD_TYPE=RelWithDebInfo”来编译。 结论MySQL on ARM已为事实，并且得到了日益增长的生态系统/社区来支持。可以来试试。当你不考虑性能或功能时，它可以成为你节约成本这个大目标的必选项。 如果你还有问题/疑问，请告诉我。我会尝试回答","link":"/2020/04/22/arm-shang-pao-mysql-neng-xing-ma/"},{"title":"ARM优化和Java Math库有关的那些坑","text":"作者：姜逸坤 1. 起初最近在进行ARM切换的过程中发现了很多因为Java Math库在不同的平台上的精度不同导致用例失败，我们以Math.log为例，做一下简单的分析。下面是一个简单的计算log(3)的示例： 123456public class Hello { public static void main(String[] args) { System.out.println(\"Math.log(3): \" + Math.log(3)); System.out.println(\"StrictMath.log(3): \" + StrictMath.log(3)); }} 我们发现，在x86下，Math的结果为1.0986122886681098。 1234# on x86$ java HelloMath.log(3): 1.0986122886681098StrictMath.log(3): 1.0986122886681096 而aarch64的结果为1.0986122886681096。 1234# on aarch64$ java HelloMath.log(3): 1.0986122886681096StrictMath.log(3): 1.0986122886681096 而在Java 8的官方文档中，对此有明确说明： Unlike some of the numeric methods of class StrictMath, all implementations of the equivalent functions of class Math are not defined to return the bit-for-bit same results. This relaxation permits better-performing implementations where strict reproducibility is not required. 因此，结论是：Math的结果有可能是不精确的，如果结果对精度有苛求，那么请使用StrictMath。 在此，我们留下2个疑问： 为什么说Math的实现不是the bit-for-bit same results？ Math是怎么实现在各个架构下better-performing implementations的？ 2. 深度探索一下Math的实现为了能够更清晰的看到StrictMath的实现，我们深入的看了下JDK的实现。 2.1 Math和StrictMath的基本实现我们从Math.log和StrictMath.log的实现为例，进行深入学习： Math.log的代码表面上很简单，就是直接调用StrictMath.log。123public static double log(double a) { return StrictMath.log(a); // default impl. delegates to StrictMath} StrictMath的代码，会调用StrictMath.c中的方法，最终会调用fdlibm的e_log.c的实现。 总体的实现和下图类似： 对于StrictMath来说，没有什么黑科技，最终的实现就是e_log.c的ieee754标准实现，是通过C语言实现的，所以在各个平台的表现是一样的，整个流程如图中蓝色部分。感兴趣的同学可以看e_log.c的源码实现即可。 2.2 Math的黑科技回到我们最初的起点，再加上一个问题： 为什么说Math的实现不是the bit-for-bit same results？ Math是怎么实现在各个架构下better-performing implementations的？ 既然Math的实现，也是直接调用StrictMath，为什么结果确不一样呢？ 原来，JVM为了让各个arch的CPU能够充分的发挥自己CPU的优势，会根据架构不同，会通过Hotspot intrinsics替换掉Math函数的实现，我们可以从代码vmSymbols.hpp看到，Math的很多实现都被替换掉了。log的替换类似于： 1do_intrinsic(_dlog, java_lang_Math, log_name, double_double_signature, F_S) 最终，Math的调用为下图红色部分： log的实现: 在x86下，最终其实调用的是assembler_x86.cpp中的flog实现:12345void Assembler::flog() { fldln2(); fxch(); fyl2x();} 而在aarch64下，我们可以从src/hotspot/cpu/目录下看到，aarch64并未实现优化版本。因此，实际aarch64调用的就是标准的StrictMath。 正因如此，x86汇编的计算结果的差异导致了x86和aarch64结果在Math.log差异。 当然，aarch64也在JDK 11中，对部分的Math接口做了加速实现，有兴趣可以看看JEP 315: Improve Aarch64 Intrinsics的实现。 3. toRadians的小插曲在ARM优化过程中，有的是因为Math库和StrictMath不同的实现造成结果不同，所以我们如果对精度要求非常高，直接切到StrictMath即可。 但有的函数，由于在Java大版本升级的过程中，出现了一些实现的差异，先看一个简单的Java程序 123456public class Hello { public static void main(String[] args) { System.out.println(\"Math.toRadians(0.33): \" + Math.toRadians(0.33)); System.out.println(\"StrictMath.toRadians(0.33): \" + StrictMath.toRadians(0.33)); }} 我们分别看看在Java11和Java8的结果： 123$ /usr/lib/jvm/java-11-openjdk-amd64/bin/java HelloMath.toRadians(0.33): 0.005759586531581287StrictMath.toRadians(0.33): 0.005759586531581287 123$ /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin/java HelloMath.toRadians(0.33): 0.005759586531581288StrictMath.toRadians(0.33): 0.005759586531581288 最后一位很奇怪的差了1，我们继续深入进去看到toRadians的实现： Java8的实现为：1234// Java 8 public static double toDegrees(double angrad) { return angrad * 180.0 / PI;} Java11的实现为：1234private static final double DEGREES_TO_RADIANS = 0.017453292519943295;public static double toRadians(double angdeg) { return angdeg * DEGREES_TO_RADIANS;} 原来在Java11的实现中，为了优化性能，将* 180.0 / PI提前算好了，这样每次只用乘以乘数即可，从而化简了计算。这也最终导致了，Java8和Java11在精度上有一些差别。 4. 总结 Math在各个arch下的实现不同，精度也不同，如果对精度要求很高，可以使用StrictMath。 Java不同版本的优化，也有可能导致Math库的精度不同 Math库在实现时，利用intrinsics机制，把各个arch下Math的实现换掉了，从而充分的发挥各个CPU自身的优势。","link":"/2020/04/08/arm-you-hua-he-java-math-ku-you-guan-de-na-xie-keng/"},{"title":"ARM使能Landscape","text":"ARM使能Landscape Field Project Status Links Big Data Hadoop ARM CI https://ci-hadoop.apache.org/job/hadoop-qbt-linux-ARM-trunk/ Big Data Hadoop 软件包发布 https://hadoop.apache.org/docs/r3.3.0/index.html Big Data Spark ARM CI https://amplab.cs.berkeley.edu/jenkins/label/spark-arm/ Big Data Hive ARM CI https://ci-hadoop.apache.org/job/Hive-trunk-linux-ARM/ Big Data HBase ARM CI https://ci-hadoop.apache.org/job/HBase/job/HBase-Nightly-ARM/ Big Data Flink ARM CI https://status.openlabtesting.org/builds?project=apache%2Fflink Big Data Kudu ARM CI http://status.openlabtesting.org/builds?project=apache%2Fkudu Database MariaDB ARM CI https://buildbot.mariadb.org/#/builders Database Greenplum ARM CI https://github.com/greenplum-db/gpdb AI TensorFlow ARM CI https://github.com/tensorflow/tensorflow#community-supported-builds AI Pytorch ARM CI https://github.com/pytorch/pytorch","link":"/2020/08/04/arm-shi-neng-landscape/"},{"title":"Aarch64服务器应用软件开发需要添加的编译参数","text":"作者： zhaorenhai 本文简单总结了一下，在aarch64服务器平台进行应用软件开发或者移植工作，编译代码时，编译器应该添加哪些选项。网上类似文章不少，但是由于arm平台涉及了移动开发，嵌入式开发，服务器开发各个领域，编译方式也有交叉编译，本地编译等，而且编译器也有gcc，armcc，armclang，clang等等多种，再加上arm平台历史版本众多，又分了32位，64位，网上这些文档一般都不明确说明文档涉及的开发平台，对应指令集版本，需要的编译器之类的情况，让人看上去比较头疼。 本文涉及的范围：aarch64 Linux 服务器平台应用软件开发，不涉及交叉编译，只讨论本地编译情况， 只讨论可以免费使用的开源gcc编译器（clang也是可以免费可以使用的开源编译器，但是编译参数全面兼容gcc，所以本文只讨论gcc）。 另外本文也只讨论和aarch64平台强相关的参数，通用的编译参数讨论的文章比较多，本文不再赘述。 最主要的参考资料来自于这篇文档：https://gcc.gnu.org/onlinedocs/gcc/AArch64-Options.html。 本文主要讨论最主要的也是最容易引起混淆的-march，-mtune，-mcpu参数。其余参数一般都是在一些极特殊的场景下才用到，比如需要改变代码模型，需要改变数据模型，需要指定字节序为大端字节序等等，或者开发特殊的软件比如gcc编译器之类的时候才用到，一般服务器应用软件开发很少用到，所以一般保持默认值即可，后续如果有实际遇到的场景，会再补充到本文中。 先看-march参数，原文描述：-march=nameSpecify the name of the target architecture and, optionally, one or more feature modifiers. This option has the form -march=arch{+[no]feature}*.The table below summarizes the permissible values for arch and the features that they enable by default: arch value Architecture Includes by default ‘armv8-a’ Armv8-A ‘+fp’, ‘+simd’ ‘armv8.1-a’ Armv8.1-A ‘armv8-a’, ‘+crc’, ‘+lse’, ‘+rdma’ ‘armv8.2-a’ Armv8.2-A ‘armv8.1-a’ ‘armv8.3-a’ Armv8.3-A ‘armv8.2-a’ ‘armv8.4-a’ Armv8.4-A ‘armv8.3-a’, ‘+fp16fml’, ‘+dotprod’ ‘armv8.5-a’ Armv8.5-A ‘armv8.4-a’, ‘+sb’, ‘+ssbs’, ‘+predres’ ‘armv8.6-a’ Armv8.6-A ‘armv8.5-a’, ‘+bf16’, ‘+i8mm’ The value ‘native’ is available on native AArch64 GNU/Linux and causes the compiler to pick the architecture of the host system. This option has no effect if the compiler is unable to recognize the architecture of the host system,The permissible values for feature are listed in the sub-section on -march and -mcpu Feature Modifiers. Where conflicting feature modifiers are specified, the right-most feature is used.GCC uses name to determine what kind of instructions it can emit when generating assembly code. If -march is specified without either of -mtune or -mcpu also being specified, the code is tuned to perform well across a range of target processors implementing the target architecture. 这个参数可以指定编译的目标架构，这里的架构指得是ARM CPU的指令集架构，那我们应该指定哪个版本的指令集架构，才能做到最好的兼容性，能兼容市场上所有的ARM CPU，或者既能兼顾兼容性，又能兼顾一部分性能，毕竟新版本的指令集架构能用上更新的具有特定功能的指令集。 这个需要看一下目前市场上所有的ARM服务器CPU的情况，网上目前已有的相关文档要么比较老，信息不全，要么就是出现把移动CPU和服务器CPU都放到一起的情况，比较混乱。所以本文重新搜集了目前所有ARM服务器CPU的信息，如下表（资料来源于互联网）： 厂商 型号 技术指标 微架构 指令集架构 发布时间 Ampere X-gene-1 8c 2.4GHz 40nm Storm ARMv8.0-A 2012 Ampere X-gene-2 8c 2.4GHz 28nm Shadowcat ARMv8.0-A 2015 Ampere eMag8180 (X-gene-3) 32c 2.8GHz-3.3GHz 16nm Skylark ARMv8.0-A 2018 Ampere Altra 32-80c 1.7-3.3GHz Quicksilver (Neoverse N1) ARMv8.2-A 2020年3月 Ampere Altra Max 128c 7nm Quicksilver (Neoverse N1) ARMv8.2-A 2020年6月 Cavium (被Marvell收购) ThunderX (CN8890) 48c 1.9GHz 28nm ThunderX1 ARMv8.1-A 2016 Cavium (被Marvell收购) ThunderX2 (CN99xx系列) 32-54c 1.6-2.5GHz 14nm 16nm Vulcan (从Broadcom收购) ARMv8.1-A 2018年5月 Cavium (被Marvell收购) ThunderX3 96c 3.1GHz 7nm Triton ARMv8.3-A 2020 Qualcomm Centriq 2400系列 40-48c 2.2-2.6GHz 10nm Falkor ARMv8.0-A 2017 Phytium FT1500 16c 1.6GHz 28nm Earth ARMv8.0-A 2017 Phytium FT2000+ 64c 2.3GHz 16nm Mars ARMv8.0-A 2017 Phytium S2500 64c 2.0-2.2GHz 16nm ARMv8.0-A 2020 HiSilicon Hi1616 32c 2.4GHz 16nm Cortex-A72 ARMv8.0-A 2017 HiSilicon Kunpeng 920 (Hi1620) 48c 3.0GHz 7nm Taishan V110 ARMv8.2-A 2019 Annapurna Labs （被AWS收购） Gravtion 16c 2.3GHz 16nm Cortex-A72 ARMv8.0-A 2018年11月 Annapurna Labs （被AWS收购） Gravtion2 64c 2.5GHz 7nm Neoverse N1 ARMv8.2-A 2019年12月 Nuvia Phoenix 备注1：此表仅搜集了64位的arm cpu相关信息，32位的arm服务器cpu比较老，实际应用也不多，可以不用再考虑兼容工作。备注2: 此表仅包含通用arm服务器cpu相关信息，不包含移动平台的cpu以及超算cpu，更不包含嵌入式以及实时计算cpu。 可以看出来市场上还是有不少ARMv8.0-A指令集架构的CPU，所以如果要做到最佳兼容性，-march参数的name的值就要指定为armv8-a。但是也要看到，高通实际上已经退出服务器CPU市场，Cavium，Ampere，Phytium各有一部分市场，但都不大，Nuvia是新晋厂商，还没有产品问世，市场规模最大的应该主要是海思的Kunpeng920和亚马逊的Gravition2，依托于华为云和亚马逊云，应用较广泛。而且从上图中可以看出各厂商最近两年新出的CPU，基本都已经支持了ARMv8.2-A指令集，考虑到近两年ARM服务器应用刚刚开始大规模普及，特别是华为云和亚马逊云上刚刚开始大规模上线ARM的云服务器实例，所以一些新开发的应用软件或者新迁移的应用软件，甚至可以指定为armv8.2-a，这样可以做到兼容性和性能兼顾。另外-march参数还支持指定一些扩展选项，下面我们来逐个看下这些扩展选项： 扩展选项 描述 crc 从ARMv8.1-a之后就默认包含了此扩展选项，所以当-march参数的name值为armv8-a的时候，才需要添加此选项，如果代码中涉及crc相关功能和指令，建议加上此选项 crypto 加密选项，这个是个额外扩展，没有哪个版本的指令集默认包含此选项，所以如果代码中涉及加密相关功能和指令，都要加上此选项。一般的应用开发涉及这个的比较少，所以这个看实际应用情况来决定要不要加 fp 浮点指令，从ARMv8-a就开始默认支持，可以忽略 simd 高级单指令多数据流指令，从ARMv8-a就开始默认支持，可以忽略 sve 目前已出的cpu支持此功能的较少，当前还不能加 lse 最新的原子指令集需要此选项，从ARMv8.1-a之后就默认包含，当-march参数的name值为armv8-a的时候，而且确定CPU支持此扩展选项的情况下可以添加。 rdma 乘积累加指令，在一些特殊场景会用到，使用较少。不过从ARMv8.1-a之后就默认包含。 fp16 半精度浮点指令，在一些图形软件中会用到，用途较少，建议视使用情况添加。 还有一些其他的扩展选项，不过都是在更新版本的指令集中才支持，当前已经问世的CPU都不支持，这里就不再讨论。 再来看-mtune参数，原文描述：-mtune=nameSpecify the name of the target processor for which GCC should tune the performance of the code. Permissible values for this option are: ‘generic’, ‘cortex-a35’, ‘cortex-a53’, ‘cortex-a55’, ‘cortex-a57’, ‘cortex-a72’, ‘cortex-a73’, ‘cortex-a75’, ‘cortex-a76’, ‘cortex-a76ae’, ‘cortex-a77’, ‘cortex-a65’, ‘cortex-a65ae’, ‘cortex-a34’, ‘ares’, ‘exynos-m1’, ‘emag’, ‘falkor’, ‘neoverse-e1’,‘neoverse-n1’,‘qdf24xx’, ‘saphira’, ‘phecda’, ‘xgene1’, ‘vulcan’, ‘octeontx’, ‘octeontx81’, ‘octeontx83’, ‘octeontx2’, ‘octeontx2t98’, ‘octeontx2t96’ ‘octeontx2t93’, ‘octeontx2f95’, ‘octeontx2f95n’, ‘octeontx2f95mm’, ‘a64fx’, ‘thunderx’, ‘thunderxt88’, ‘thunderxt88p1’, ‘thunderxt81’, ‘tsv110’, ‘thunderxt83’, ‘thunderx2t99’, ‘thunderx3t110’, ‘zeus’, ‘cortex-a57.cortex-a53’, ‘cortex-a72.cortex-a53’, ‘cortex-a73.cortex-a35’, ‘cortex-a73.cortex-a53’, ‘cortex-a75.cortex-a55’, ‘cortex-a76.cortex-a55’ ‘native’.The values ‘cortex-a57.cortex-a53’, ‘cortex-a72.cortex-a53’, ‘cortex-a73.cortex-a35’, ‘cortex-a73.cortex-a53’, ‘cortex-a75.cortex-a55’, ‘cortex-a76.cortex-a55’ specify that GCC should tune for a big.LITTLE system.Additionally on native AArch64 GNU/Linux systems the value ‘native’ tunes performance to the host system. This option has no effect if the compiler is unable to recognize the processor of the host system.Where none of -mtune=, -mcpu= or -march= are specified, the code is tuned to perform well across a range of target processors.This option cannot be suffixed by feature modifiers.这个参数比较简单，实际上就是指定目标CPU微架构，让gcc编译的时候，根据目标cpu的微架构进行特定的优化，比如指定为tsv110时，gcc就会根据鲲鹏920的微架构，进行一些指令的流水线重排，会提高一些性能。但是指定这个，同时也就意味着牺牲了兼容性，编译后的软件只能在目标CPU平台上运行。 最后看一下-mcpu参数，原文描述：-mcpu=nameSpecify the name of the target processor, optionally suffixed by one or more feature modifiers. This option has the form -mcpu=cpu{+[no]feature}*, where the permissible values for cpu are the same as those available for -mtune. The permissible values for feature are documented in the sub-section on -march and -mcpu Feature Modifiers. Where conflicting feature modifiers are specified, the right-most feature is used.GCC uses name to determine what kind of instructions it can emit when generating assembly code (as if by -march) and to determine the target processor for which to tune for performance (as if by -mtune). Where this option is used in conjunction with -march or -mtune, those options take precedence over the appropriate part of this option.可以看出来，这个参数实际上就是前面两个参数的综合，而且指定两个参数的优先级会高于这个参数。据说后续这个参数会被干掉。建议可以忽略此参数，只用前面两个参数即可。 总结：在aarch64服务器平台，进行应用软件开发，编译时，除了通用的编译选项之外，一般只需要添加-march=armv8-a即可，考虑到crc扩展选项应用比较多，可以加上crc扩展选项，比如-march=armv8-a+crc，这样可以做到最好的兼容性。 如果确定平台支持最新的原子指令，可以再加上+lse，其余的扩展选项建议根据实际应用情况添加。 如果既想兼顾兼容性和性能，建议直接指定-march=armv8.2-a，这样不仅包含了crc和lse扩展选项，而且最两年新出的CPU都可以做到兼容。 如果想做到最佳性能，还可以添加-mtune参数，但是这个要确保编译出来的软件只在目标平台运行。另外，由于编译器的习惯， ARM平台上char的默认类型为unsigned char，这与x86正好相反（x86的char默认是有符号的），在x86上运行稳定的代码，移植过来将遇到char类型的变化，会带来不少问题。由于x86上的char类型与我们的编程习惯更一致，所以我们一般将ARM平台上的程序的char类型指定为signed char。所以还需要添加编译选项-fsigned-char。 最后，上述编译选项和扩展是在不同的gcc版本里逐步得到支持的，所以添加这些选项还要注意gcc的版本，对于-march的 name和扩展选项的支持情况，可以参考ARM官方的这个文档：https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/architecture-support 对于-mtune选项的支持建议参考不同版本的gcc文档，主要看AArch64-Options这个章节就行。 参考资料：https://gcc.gnu.org/onlinedocs/gcc/AArch64-Options.htmlhttps://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/architecture-supporthttps://clang.llvm.org/docs/ClangCommandLineReference.htmlhttp://www.semiinsights.com/s/electronic_components/23/39697.shtmlhttp://news.eeworld.com.cn/qrs/2019/ic-news011452649.htmlhttp://news.eeworld.com.cn/xfdz/ic497298.htmlhttps://www.cirmall.com/articles/31558https://koolshare.cn/thread-147215-1-3.htmlhttp://www.360doc.com/content/20/0101/18/99071_883541215.shtmlhttps://en.wikichip.org/wiki/https://blog.csdn.net/u014470361/article/details/85988772https://www.cnblogs.com/panda-w/p/11003389.htmlhttps://developer.arm.com/ip-products/processors/cortex-a/cortex-a78https://en.wikipedia.org/wiki/Comparison_of_ARMv8-A_coreshttps://aijishu.com/a/1060000000133361http://phytium.com.cn/article/5https://www.sohu.com/a/361552782_163726?scm=1002.44003c.fe021c.PC_ARTICLE_REChttps://www.infoq.cn/article/34moxVRHI8qprbh9I1mp","link":"/2020/08/29/aarch64-fu-wu-qi-ying-yong-ruan-jian-kai-fa-xu-yao-tian-jia-de-bian-yi-can-shu/"},{"title":"Apache Tomcat X86 vs ARM64 性能比拼","text":"译者: wangxiyuan作者: Martin Grigorov原文链接: https://medium.com/@martin.grigorov/compare-apache-tomcat-performance-on-x86-64-and-arm64-cpu-architectures-aacfbb0b5bb6 Tomcat PMC Martin Grigorov带来的Tomcat X86 VS ARM64性能测试。 中文 English 大多数软件开发人员通常不会考虑他们的软件将在何种 CPU 架构上运行。 尽管没有官方的统计数据，但根据我的经验，大多数桌面和后端应用软件都运行在 x86_64架构(英特尔和 AMD 处理器)上，大多数移动和物联网设备都运行在 ARM 架构上。 开发人员使用一些高级编程语言为各自的 CPU 架构编写软件，并不考虑在运行时执行何种汇编指令。 而这正是高级编程语言的目的—- 让编译器处理低级硬件指令，并简化我们的任务，使其只专注于高级业务相关问题。 生活简单而美好，但有时候，笔记本电脑和台式机硬件及软件制造业的巨头会说，我们的软件必须在不同的架构上运行——先是从 PowerPC 到英特尔，现在从英特尔到 ARM64(消息来源: Bloomberg &amp; AppleInsider)。 由于电力消耗较低，甚至一些较大的云供应商也开始提供 ARM64虚拟机(如亚马逊 AWS、华为云、 Linaro)。 但还有以下不确定性: 我的软件能在新的 CPU 架构上运行吗? 我需要做出什么样的改变才能让它发挥作用 它会像以前一样表现出色吗 为了能够回答这些问题，你必须撸起袖子进行测试！ 您可以在任何云供应商上部署软件。 有些还提供免费试用期！ 或者如果你的预算很少，你可以试试 RaspberryPi。 根据您编写软件所使用的编程语言，您可能需要进行一些更改，或者根本不需要更改！ 如果你使用一个直译语言文件(例如 Python，Perl，Ruby，JVM，…) ，那么解释器已经支持 ARM64的可能性相当高，你可以不做任何改变就继续使用它！ 但是，如果你的软件需要被编译，那么你需要调整你的工具链，并确保有 ARM64二进制文件为你所有的依赖！ 根据您的软件开发堆栈，您的修改量可能会有所不同！ 一旦我们的软件在新架构上运行良好，我们将能够检查它是否像以前那样执行良好。 最近一些用户在 Apache Tomcat 邮件列表中询问是否支持 ARM64架构。 因为 Apache Tomcat 大部分代码是用 Java 编写的，所以它可以基本的运行在ARM64上。 如果您需要使用 libtcnative 和 / 或 mod_jk，那么您需要自己在 ARM64上构建它们。 Apache Tomcat 团队使用 TravisCI 在 ARM64上测试 Java 和 C 代码，目前还没有已知的问题！ 为了比较某些软件的两个版本的性能，通常您将在同一个硬件上运行测试，但在这种情况下，由于我们使用不同的 CPU 架构，这是不可能的。 在我的测试中，我使用了两个具有类似规范的 vm： X86_64处理器是： 123456789101112131415161718192021222324Architecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 2Core(s) per socket: 4Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 85Model name: Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHzStepping: 7CPU MHz: 3000.000BogoMIPS: 6000.00Hypervisor vendor: KVMVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 1024KL3 cache: 30976KNUMA node0 CPU(s): 0-7Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat avx512_vnni md_clear flush_l1d arch_capabilities Arm64处理器是： 123456789101112131415161718Architecture: aarch64Byte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 1Core(s) per socket: 8Socket(s): 1NUMA node(s): 1Vendor ID: 0x48Model: 0Stepping: 0x1BogoMIPS: 200.00L1d cache: 64KL1i cache: 64KL2 cache: 512KL3 cache: 32768KNUMA node0 CPU(s): 0-7Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp asimdfhm 两个虚拟机具有相同数量的 RAM、磁盘和网络连接。 测试应用程序基于 Spring Boot (2.2.7) ，运行嵌入式 Apache Tomcat 9.0.x + OpenSSL 1.1.1h-dev 和 Apache Apr 1.7.x。 每晚构建，并且有一个单独的 REST 客户端，该客户端公开一个用于创建实体的 PUT Endpoint、一个用于读取它的 GET Endpoint、一个用于更新它的 POST Endpoint和一个用于删除它的 DELETE Endpoint。 它使用 Memcached 作为数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package info.mgsolutions.testbed.rest;import info.mgsolutions.testbed.domain.Error;import info.mgsolutions.testbed.domain.Person;import info.mgsolutions.testbed.domain.Response;import lombok.extern.slf4j.Slf4j;import net.rubyeye.xmemcached.MemcachedClient;import net.rubyeye.xmemcached.exception.MemcachedException;import net.rubyeye.xmemcached.transcoders.SerializingTranscoder;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.http.server.ServletServerHttpRequest;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.util.UriComponents;import org.springframework.web.util.UriComponentsBuilder;import javax.servlet.http.HttpServletRequest;import java.net.URI;import java.nio.charset.StandardCharsets;import java.util.Base64;import java.util.concurrent.TimeoutException;/** * A REST endpoint that uses Memcached to get its data. */@RestController@RequestMapping(&quot;testbed/memcached&quot;)@Slf4jpublic class MemcachedTestController { public static final int TTL_IN_SECONDS = 1000; private final SerializingTranscoder coder = new SerializingTranscoder(); private final MemcachedClient client; public MemcachedTestController(MemcachedClient client) { this.client = client; } @PutMapping(value =&quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Response&gt; create(@RequestBody Person person, HttpServletRequest servletRequest) throws InterruptedException, MemcachedException, TimeoutException { final String base64Name = base64(person.name); Person existing = client.get(base64Name); if (existing != null) { log.info(&quot;Create: Person with name {} already exists!&quot;, person.name); Error error = new Error(&quot;Person with name &quot; + person.name + &quot; already exists!&quot;); return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE) .body(error); } log.info(&quot;Create: Going to create '{}'&quot;, person); client.set(base64Name, TTL_IN_SECONDS, person, coder); ServletServerHttpRequest request = new ServletServerHttpRequest(servletRequest); final UriComponents uriComponents = UriComponentsBuilder.fromHttpRequest(request).build(); final URI uri = uriComponents.encode(StandardCharsets.UTF_8).toUri(); return ResponseEntity.created(uri).contentType(MediaType.APPLICATION_JSON).body(person); } @GetMapping(value =&quot;&quot;, consumes = MediaType.ALL_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Person&gt; get(@RequestParam String name) throws InterruptedException, MemcachedException, TimeoutException { Person person = (Person) client.get(base64(name), coder); if (person == null) { log.info(&quot;Get: Cannot find a person with name {}!&quot;, name); return ResponseEntity.notFound().build(); } log.info(&quot;Get: Found person with name: {}!&quot;, name); return ResponseEntity.ok().body(person); } @PostMapping(value =&quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Person&gt; update(@RequestBody Person person) throws InterruptedException, MemcachedException, TimeoutException { final String name = person.name; final String base64Name = base64(name); final Person existing = (Person) client.get(base64Name, coder); if (existing != null) { log.info(&quot;Update: Going to update: {}&quot;, person); client.set(base64Name, TTL_IN_SECONDS, person, coder); return ResponseEntity.ok().build(); } log.info(&quot;Update: Cannot find a person with name {}!&quot;, person.name); return ResponseEntity.notFound().build(); } @DeleteMapping(value =&quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Person&gt; delete(@RequestParam String name) throws InterruptedException, MemcachedException, TimeoutException { final String base64Name = base64(name); final Person person = client.get(base64Name); if (person != null) { log.info(&quot;Delete: Going to delete: {}&quot;, person); client.delete(base64Name); return ResponseEntity.ok().build(); } log.info(&quot;Delete: Cannot find a person with name {}!&quot;, name); return ResponseEntity.notFound().build(); } private String base64(String name) { return Base64.getEncoder().encodeToString(name.getBytes(StandardCharsets.UTF_8)); }} 对于负载测试，我使用了 Apache JMeter 5.2.1和基于主干代码的 wrk。 Jmeter 用于一个真实的情况场景，有1000个并发用户，在 HTTP 请求之间有一个适应期和一段思考时间。 然后用 wrk 测试最大吞吐量。 使用以下参数执行 JMeter: 1234567891011121314151617jmeter.sh \\ --testfile JMeter_plan.jmx \\ --logfile $RESULTS_FILE \\ --reportoutputfolder $RESULTS_FOLDER \\ --reportatendofloadtests \\ --nongui \\ --forceDeleteResultFile \\ --jmeterproperty httpclient4.validate_after_inactivity=4900 \\ --jmeterproperty httpclient4.time_to_live=120000 \\ -Jhost=$JMETER_HOST \\ -Jport=$JMETER_PORT \\ -Jprotocol=$JMETER_PROTOCOL \\ -JresourceFolder=$JMETER_RESOURCE_FOLDER \\ -Jusers=1000 \\ -JrampUpSecs=5 \\ -Jloops=10 \\ -JrequestPath=/testbed/memcached 重用 HTTPS 连接需要 httpclient4. * * 属性，否则 Keep-Alive 不会有效。 Jmeter 和 wrk 的结果与存储在 Elasticsearch 的 Logstash 一起解析，并由 Kibana 进行可视化。 Jmeter 的响应时间: 正如你所看到的，在5月8日之前 HTTPS 的结果并不是很好。 没有重用 HTTPS 连接，每个请求都进行了 TLS 握手，尽管请求头“ Connection: keep-alive”。 因为 wrk 没有这样的问题，我在 JMeter 邮件列表中询问过，他们给了我上面提到的 httpclient4参数。 (谢谢你，菲利普 · 穆瓦德!) . 不管有没有 HttpClient 的调整，我们看到 x8664和 arm64的响应时间非常相似。 太棒了！ 对于 wrk 的吞吐量测试，我使用以下参数运行它: 1wrk -c96 -t8 -d30s -s /scripts/wrk-report-to-csv.lua $HOST:$PORT 例如，8个线程将使用96个 HTTP (s)连接访问服务器30秒。 为了收集 CSV 文件中的摘要，我使用了这个自定义 Lua 脚本: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125-- Initialize the pseudo random number generator-- Resource: http://lua-users.org/wiki/MathLibraryTutorialmath.randomseed(os.time())math.random(); math.random(); math.random()local _request = {}method = ''-- Load URL config from the filefunction load_request_objects_from_file(csvFile) local data = {} for line in io.lines(csvFile) do local idx = string.find(line, &quot;:&quot;) local key = string.sub(line, 0, idx-1) local value = string.sub(line, idx+1, string.len(line)) data[key] = value end return dataendfunction trim(s) return s:match &quot;^%s*(.-)%s*$&quot;endfunction readMethod() local method = '' local f = io.open('/data/method.txt',&quot;r&quot;) if f ~= nil then method = f:read(&quot;*all&quot;) io.close(f) return trim(method) else print('Cannot read the method name from /data/method.txt') os.exit(123) endendfunction init(args) local method = readMethod() -- Load request config from file _request = load_request_objects_from_file(&quot;/data/&quot; .. method ..&quot;.conf&quot;) --for i, val in pairs(_request) do -- print('Request:\\t', i, val) --end if _request[method] ~= nil then print(&quot;multiplerequests: No requests found.&quot;) os.exit() end print(&quot;multiplerequests: Found a &quot; .. _request.method .. &quot; request&quot;)endrequest = function() local request_object = _request -- Return the request object with the current URL path local headers = {} headers[&quot;Content-type&quot;] = &quot;application/json&quot; local url = wrk.format(request_object.method, request_object.path, headers, request_object.body) return urlendfunction done(summary, latency, reqs) local date_table = os.date(&quot;*t&quot;) local ms = string.match(tostring(os.clock()), &quot;%d%.(%d+)&quot;) / 1000 local hour, minute, second = date_table.hour, date_table.min, date_table.sec local year, month, day = date_table.year, date_table.month, date_table.day local timeStamp = string.format(&quot;%04d-%02d-%02dT%02d:%02d:%02d.%03d&quot;, year, month, day, hour, minute, second, ms) print(&quot;Timestamp: &quot; .. timeStamp) local method = readMethod() file = io.open('/results/today/' .. method .. '.csv', 'w') io.output(file) -- summary io.write(&quot;timeStamp,&quot;) io.write(&quot;duration_microseconds,&quot;) io.write(&quot;num_requests,&quot;) io.write(&quot;total_bytes,&quot;) io.write(&quot;connect_errors,&quot;) io.write(&quot;read_errors,&quot;) io.write(&quot;write_errors,&quot;) io.write(&quot;error_status_codes,&quot;) io.write(&quot;timeouts,&quot;) io.write(&quot;requests_per_sec,&quot;) io.write(&quot;bytes_per_sec,&quot;) -- latency io.write(&quot;lat_min_microseconds,&quot;) io.write(&quot;lat_max_microseconds,&quot;) io.write(&quot;lat_mean_microseconds,&quot;) io.write(&quot;lat_stdev_microseconds,&quot;) io.write(&quot;lat_percentile_90_microseconds,&quot;) io.write(&quot;lat_percentile_95_microseconds,&quot;) io.write(&quot;lat_percentile_99_microseconds\\n&quot;) -- summary io.write(string.format(&quot;%s,&quot;, timeStamp)) io.write(string.format(&quot;%d,&quot;, summary.duration)) io.write(string.format(&quot;%d,&quot;, summary.requests)) io.write(string.format(&quot;%d,&quot;, summary.bytes)) io.write(string.format(&quot;%d,&quot;, summary.errors.connect)) io.write(string.format(&quot;%d,&quot;, summary.errors.read)) io.write(string.format(&quot;%d,&quot;, summary.errors.write)) io.write(string.format(&quot;%d,&quot;, summary.errors.status)) io.write(string.format(&quot;%d,&quot;, summary.errors.timeout)) io.write(string.format(&quot;%.2f,&quot;, summary.requests/(summary.duration / 1000 / 1000))) io.write(string.format(&quot;%.2f,&quot;, summary.bytes/summary.duration)) -- latency io.write(string.format(&quot;%.2f,&quot;, latency.min)) io.write(string.format(&quot;%.2f,&quot;, latency.max)) io.write(string.format(&quot;%.2f,&quot;, latency.mean)) io.write(string.format(&quot;%.2f,&quot;, latency.stdev)) io.write(string.format(&quot;%.2f,&quot;, latency:percentile(90.0))) io.write(string.format(&quot;%.2f,&quot;, latency:percentile(95.0))) io.write(string.format(&quot;%.2f\\n&quot;, latency:percentile(99.0)))end 结果显示，x86_64上的 Tomcat 比 arm64快两倍: 我将试图找出这种差异的原因，并在后续的帖子中与你分享。 如果你有什么想法和建议，我很乐意试试！ 祝你黑客生活愉快，注意安全！ The majority of the software developers usually do not think about the CPU architecture their software will run on. I do not have official statistics but in my experience most of the software for desktop and backend applications run on x86_64 architecture (Intel and AMD processors) and most of the mobile and IoT devices run on ARM architecture. The developers write their software for the respective CPU architecture using some high level programming language and do not think what kind of Assembly instructions are being executed at runtime. And this is the purpose of the high level programming languages — to let the compiler deal with the low level hardware instructions and simplify our task to focus only on the high level business related problems. Life is simple and beautiful but there are times when a big player in the laptop and desktop hardware and software manufacturing comes and says that our software will have to run on a different architecture — first from PowerPC to Intel and now from Intel to ARM64 (sources: Bloomberg &amp; AppleInsider). Due to the lower consumption of electricity even several of the bigger cloud providers started providing ARM64 virtual machines (e.g. Amazon AWS, HuaweiCloud, Linaro). And here comes the uncertainty — Will my software run on the new CPU architecture ?! What kind of changes I will have to do to make it work ?! Will it perform as good as before ?! To be able to answer these questions you will have to roll up your sleeves and test! You can deploy your software on any of the cloud providers. Some of them give free trial period! Or if you are on a low budget you can experiment on RaspberryPi. Depending on what programming language you use to write your software you might need to do some changes or not at all! If you use an interpreted language (e.g. Python, Perl, Ruby, JVM, …) then the chances the interpreter already supports ARM64 are pretty high and you are good to go without any changes! But if your software needs to be compiled then you will need to adapt your toolchain and make sure that there are ARM64 binaries for all your dependencies! Depending on your software development stack your mileage may vary! Once our software runs fine on the new architecture we will be able to check whether it performs as good as before. Recently some users have asked in Apache Tomcat mailing lists whether ARM64 architecture is supported. Since Apache Tomcat is written mostly in Java it “Just Works”. If you need to use libtcnative and/or mod_jk then you will need to build them yourself on ARM64. Apache Tomcat team uses TravisCI to test both Java and C code on ARM64 and there are no known issues at the moment! To compare the performance of two versions of some software usually you will run it on the same hardware but in this case since we use different CPU architectures this makes it impossible. For my tests I have used two VMs with similar specifications: The x86_64 processor is: 123456789101112131415161718192021222324Architecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 2Core(s) per socket: 4Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 85Model name: Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHzStepping: 7CPU MHz: 3000.000BogoMIPS: 6000.00Hypervisor vendor: KVMVirtualization type: fullL1d cache: 32KL1i cache: 32KL2 cache: 1024KL3 cache: 30976KNUMA node0 CPU(s): 0-7Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx512cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat avx512_vnni md_clear flush_l1d arch_capabilities The ARM64 processor is: 123456789101112131415161718Architecture: aarch64Byte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 1Core(s) per socket: 8Socket(s): 1NUMA node(s): 1Vendor ID: 0x48Model: 0Stepping: 0x1BogoMIPS: 200.00L1d cache: 64KL1i cache: 64KL2 cache: 512KL3 cache: 32768KNUMA node0 CPU(s): 0-7Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp asimdfhm Both VMs have same amount of RAM, disk and network connectivity. The test application is based on Spring Boot (2.2.7) running an embedded Apache Tomcat 9.0.x nightly builds and has a single REST controller that exposes a PUT endpoint for creating an entity, a GET endpoint to read it, a POST endpoint to update it and a DELETE endpoint to remove it. It uses Memcached as a database. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package info.mgsolutions.testbed.rest;import info.mgsolutions.testbed.domain.Error;import info.mgsolutions.testbed.domain.Person;import info.mgsolutions.testbed.domain.Response;import lombok.extern.slf4j.Slf4j;import net.rubyeye.xmemcached.MemcachedClient;import net.rubyeye.xmemcached.exception.MemcachedException;import net.rubyeye.xmemcached.transcoders.SerializingTranscoder;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.http.server.ServletServerHttpRequest;import org.springframework.web.bind.annotation.DeleteMapping;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.PutMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.util.UriComponents;import org.springframework.web.util.UriComponentsBuilder;import javax.servlet.http.HttpServletRequest;import java.net.URI;import java.nio.charset.StandardCharsets;import java.util.Base64;import java.util.concurrent.TimeoutException;/** * A REST endpoint that uses Memcached to get its data. */@RestController@RequestMapping(&quot;testbed/memcached&quot;)@Slf4jpublic class MemcachedTestController { public static final int TTL_IN_SECONDS = 1000; private final SerializingTranscoder coder = new SerializingTranscoder(); private final MemcachedClient client; public MemcachedTestController(MemcachedClient client) { this.client = client; } @PutMapping(value =&quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Response&gt; create(@RequestBody Person person, HttpServletRequest servletRequest) throws InterruptedException, MemcachedException, TimeoutException { final String base64Name = base64(person.name); Person existing = client.get(base64Name); if (existing != null) { log.info(&quot;Create: Person with name {} already exists!&quot;, person.name); Error error = new Error(&quot;Person with name &quot; + person.name + &quot; already exists!&quot;); return ResponseEntity.status(HttpStatus.NOT_ACCEPTABLE) .body(error); } log.info(&quot;Create: Going to create '{}'&quot;, person); client.set(base64Name, TTL_IN_SECONDS, person, coder); ServletServerHttpRequest request = new ServletServerHttpRequest(servletRequest); final UriComponents uriComponents = UriComponentsBuilder.fromHttpRequest(request).build(); final URI uri = uriComponents.encode(StandardCharsets.UTF_8).toUri(); return ResponseEntity.created(uri).contentType(MediaType.APPLICATION_JSON).body(person); } @GetMapping(value =&quot;&quot;, consumes = MediaType.ALL_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Person&gt; get(@RequestParam String name) throws InterruptedException, MemcachedException, TimeoutException { Person person = (Person) client.get(base64(name), coder); if (person == null) { log.info(&quot;Get: Cannot find a person with name {}!&quot;, name); return ResponseEntity.notFound().build(); } log.info(&quot;Get: Found person with name: {}!&quot;, name); return ResponseEntity.ok().body(person); } @PostMapping(value =&quot;&quot;, consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Person&gt; update(@RequestBody Person person) throws InterruptedException, MemcachedException, TimeoutException { final String name = person.name; final String base64Name = base64(name); final Person existing = (Person) client.get(base64Name, coder); if (existing != null) { log.info(&quot;Update: Going to update: {}&quot;, person); client.set(base64Name, TTL_IN_SECONDS, person, coder); return ResponseEntity.ok().build(); } log.info(&quot;Update: Cannot find a person with name {}!&quot;, person.name); return ResponseEntity.notFound().build(); } @DeleteMapping(value =&quot;&quot;, produces = MediaType.APPLICATION_JSON_VALUE) public ResponseEntity&lt;Person&gt; delete(@RequestParam String name) throws InterruptedException, MemcachedException, TimeoutException { final String base64Name = base64(name); final Person person = client.get(base64Name); if (person != null) { log.info(&quot;Delete: Going to delete: {}&quot;, person); client.delete(base64Name); return ResponseEntity.ok().build(); } log.info(&quot;Delete: Cannot find a person with name {}!&quot;, name); return ResponseEntity.notFound().build(); } private String base64(String name) { return Base64.getEncoder().encodeToString(name.getBytes(StandardCharsets.UTF_8)); }} For load testing I have used Apache JMeter 5.2.1 and wrk from its master branch. JMeter is used for a real case scenario with 1000 simultaneous users, ramp-up period and think time between the HTTP requests. And wrk is used to test the maximal throughput.JMeter is executed with these arguments: 1234567891011121314151617jmeter.sh \\ --testfile JMeter_plan.jmx \\ --logfile $RESULTS_FILE \\ --reportoutputfolder $RESULTS_FOLDER \\ --reportatendofloadtests \\ --nongui \\ --forceDeleteResultFile \\ --jmeterproperty httpclient4.validate_after_inactivity=4900 \\ --jmeterproperty httpclient4.time_to_live=120000 \\ -Jhost=$JMETER_HOST \\ -Jport=$JMETER_PORT \\ -Jprotocol=$JMETER_PROTOCOL \\ -JresourceFolder=$JMETER_RESOURCE_FOLDER \\ -Jusers=1000 \\ -JrampUpSecs=5 \\ -Jloops=10 \\ -JrequestPath=/testbed/memcached The httpclient4.** properties are needed to reuse the HTTPS connections, otherwise Keep-Alive was not effective. The results from both JMeter and wrk are parsed with Logstash, stored in Elasticsearch and visualized by Kibana. JMeter’s response times: As you can see the results for HTTPS were not very good before May 8th. The HTTPS connections were not reused and TLS handshake has been done for each request, despite request header “Connection: keep-alive”. Since there was no such issue with wrk I’ve asked at JMeter mailing lists and they gave me the httpclient4 arguments above. (Thank you, Philippe Mouawad!). With or without the HttpClient tweak we see that the response times are very similar for x86_64 and arm64. For the throughput test with wrk I have run it with these parameters: 1wrk -c96 -t8 -d30s -s /scripts/wrk-report-to-csv.lua $HOST:$PORT i.e. 8 threads will hit the server for 30 seconds using 96 HTTP(S) connections. To collect the summary in a CSV file I used this custom Lua script: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125-- Initialize the pseudo random number generator-- Resource: http://lua-users.org/wiki/MathLibraryTutorialmath.randomseed(os.time())math.random(); math.random(); math.random()local _request = {}method = ''-- Load URL config from the filefunction load_request_objects_from_file(csvFile) local data = {} for line in io.lines(csvFile) do local idx = string.find(line, &quot;:&quot;) local key = string.sub(line, 0, idx-1) local value = string.sub(line, idx+1, string.len(line)) data[key] = value end return dataendfunction trim(s) return s:match &quot;^%s*(.-)%s*$&quot;endfunction readMethod() local method = '' local f = io.open('/data/method.txt',&quot;r&quot;) if f ~= nil then method = f:read(&quot;*all&quot;) io.close(f) return trim(method) else print('Cannot read the method name from /data/method.txt') os.exit(123) endendfunction init(args) local method = readMethod() -- Load request config from file _request = load_request_objects_from_file(&quot;/data/&quot; .. method ..&quot;.conf&quot;) --for i, val in pairs(_request) do -- print('Request:\\t', i, val) --end if _request[method] ~= nil then print(&quot;multiplerequests: No requests found.&quot;) os.exit() end print(&quot;multiplerequests: Found a &quot; .. _request.method .. &quot; request&quot;)endrequest = function() local request_object = _request -- Return the request object with the current URL path local headers = {} headers[&quot;Content-type&quot;] = &quot;application/json&quot; local url = wrk.format(request_object.method, request_object.path, headers, request_object.body) return urlendfunction done(summary, latency, reqs) local date_table = os.date(&quot;*t&quot;) local ms = string.match(tostring(os.clock()), &quot;%d%.(%d+)&quot;) / 1000 local hour, minute, second = date_table.hour, date_table.min, date_table.sec local year, month, day = date_table.year, date_table.month, date_table.day local timeStamp = string.format(&quot;%04d-%02d-%02dT%02d:%02d:%02d.%03d&quot;, year, month, day, hour, minute, second, ms) print(&quot;Timestamp: &quot; .. timeStamp) local method = readMethod() file = io.open('/results/today/' .. method .. '.csv', 'w') io.output(file) -- summary io.write(&quot;timeStamp,&quot;) io.write(&quot;duration_microseconds,&quot;) io.write(&quot;num_requests,&quot;) io.write(&quot;total_bytes,&quot;) io.write(&quot;connect_errors,&quot;) io.write(&quot;read_errors,&quot;) io.write(&quot;write_errors,&quot;) io.write(&quot;error_status_codes,&quot;) io.write(&quot;timeouts,&quot;) io.write(&quot;requests_per_sec,&quot;) io.write(&quot;bytes_per_sec,&quot;) -- latency io.write(&quot;lat_min_microseconds,&quot;) io.write(&quot;lat_max_microseconds,&quot;) io.write(&quot;lat_mean_microseconds,&quot;) io.write(&quot;lat_stdev_microseconds,&quot;) io.write(&quot;lat_percentile_90_microseconds,&quot;) io.write(&quot;lat_percentile_95_microseconds,&quot;) io.write(&quot;lat_percentile_99_microseconds\\n&quot;) -- summary io.write(string.format(&quot;%s,&quot;, timeStamp)) io.write(string.format(&quot;%d,&quot;, summary.duration)) io.write(string.format(&quot;%d,&quot;, summary.requests)) io.write(string.format(&quot;%d,&quot;, summary.bytes)) io.write(string.format(&quot;%d,&quot;, summary.errors.connect)) io.write(string.format(&quot;%d,&quot;, summary.errors.read)) io.write(string.format(&quot;%d,&quot;, summary.errors.write)) io.write(string.format(&quot;%d,&quot;, summary.errors.status)) io.write(string.format(&quot;%d,&quot;, summary.errors.timeout)) io.write(string.format(&quot;%.2f,&quot;, summary.requests/(summary.duration / 1000 / 1000))) io.write(string.format(&quot;%.2f,&quot;, summary.bytes/summary.duration)) -- latency io.write(string.format(&quot;%.2f,&quot;, latency.min)) io.write(string.format(&quot;%.2f,&quot;, latency.max)) io.write(string.format(&quot;%.2f,&quot;, latency.mean)) io.write(string.format(&quot;%.2f,&quot;, latency.stdev)) io.write(string.format(&quot;%.2f,&quot;, latency:percentile(90.0))) io.write(string.format(&quot;%.2f,&quot;, latency:percentile(95.0))) io.write(string.format(&quot;%.2f\\n&quot;, latency:percentile(99.0)))end the results show that Tomcat on x86_64 is twice faster than on arm64: I will try to find out what is the reason for this difference and share it with you in a follow up post. If you have any ideas I would be happy to test them! Happy hacking and stay safe! .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/05/13/apache-tomcat-x86-vs-arm64-xing-neng-bi-pin/"},{"title":"Backtraces in PostgreSQL","text":"译者: bzhaoopenstack作者: Amit Dattatray Khandekar原文链接: https://amitdkhan-pg.blogspot.com/2020/07/backtraces-in-postgresql.html PGSQL 13引入了Backtraces特性，方便客户和管理者定位疑难问题，来看社区大牛Amit带你玩转它！ 中文 English PostgreSQL 13引入了一个简单但非常有用的功能，在发生错误时将堆栈跟踪记录到服务器日志中。让我们看看细节 有一个 GUC 可以启用 生成 stacktrace: backtrace_functions. 设置为逗号隔开的function名字。 SET backtrace_functions TO ‘func1,func2’; 如果从这些函数之一抛出错误，将生成回溯跟踪并记录到服务器日志中。 注意只有超级用户可以设置该GUC。可以在本地会话中设置，也可以在postgresql.conf文件中全局设置。 在客户报告错误消息的情况下，很容易看出它是如何起作用的。我们可以在源代码中通过 grep 找到它的来源。但除此之外，就只能靠猜测了。现在不是了，随着这个功能的出现，现在，您可以要求客户将 backtrace_functions设置为所有发出此错误消息的函数，并获取堆栈跟踪。在大多数情况下，错误的根本原因并不是发生错误的函数; 它位于堆栈中间的某个位置; 因此堆栈跟踪是关键的 这个功能已经在其他数据库中使用，比如 MySQL，Greenplum，Oracle。 但在 PostgreSQL 中仍然缺少的东西——这个问题也存在于大多数其他数据库中——是能够在服务器后端由于内存区段错误或其他类似意外信号崩溃时生成堆栈跟踪，或者当服务器由于某种原因而宕机时生成堆栈跟踪。这种能力会带来更大的不同。我们将摆脱生成核心文件的解释步骤。更重要的是，这在崩溃只是随机发生的情况下有所帮助。即使发生了单个意外的崩溃，客户也总是准备好了回溯。我希望这能在 PostgreSQL 的下一个主要版本中实现 让我们看看 PostgreSQL 堆栈跟踪日志是什么样的。我们将尝试使用一个不存在的类型来创建表。假设我们知道“ type does not exist”错误来自源代码中的 typenameType ()。所以我们这样做: postgres=# set backtrace_functions TO ‘typenameType’;postgres=# create table tab (id invalidtype);ERROR: type “invalidtype” does not existLINE 1: create table tab (id invalidtype); 以下是服务器日志中的一个片段: :2020-07-28 20:17:01.482 CST [22454] ERROR: type “invalidtype” does not exist at character 222020-07-28 20:17:01.482 CST [22454] BACKTRACE: postgres: amit postgres [local] CREATE TABLE(typenameType+0xa4) [0xaaaaafcd2ac4] postgres: amit postgres [local] CREATE TABLE(+0x20f550) [0xaaaaafcd4550] postgres: amit postgres [local] CREATE TABLE(transformCreateStmt+0x53c) [0xaaaaafcd7a10] postgres: amit postgres [local] CREATE TABLE(+0x44df20) [0xaaaaaff12f20] postgres: amit postgres [local] CREATE TABLE(standard_ProcessUtility+0x16c) [0xaaaaaff1225c] postgres: amit postgres [local] CREATE TABLE(+0x44a4e4) [0xaaaaaff0f4e4] postgres: amit postgres [local] CREATE TABLE(+0x44af88) [0xaaaaaff0ff88] postgres: amit postgres [local] CREATE TABLE(PortalRun+0x198) [0xaaaaaff10ed8] postgres: amit postgres [local] CREATE TABLE(+0x44764c) [0xaaaaaff0c64c] postgres: amit postgres [local] CREATE TABLE(PostgresMain+0x970) [0xaaaaaff0d3d4] postgres: amit postgres [local] CREATE TABLE(+0x3b3be4) [0xaaaaafe78be4] postgres: amit postgres [local] CREATE TABLE(PostmasterMain+0xdc0) [0xaaaaafe79b70] postgres: amit postgres [local] CREATE TABLE(main+0x480) [0xaaaaafb82510] /lib/aarch64-linux-gnu/libc.so.6(__libc_start_main+0xe0) [0xffffaac956e0] postgres: amit postgres [local] CREATE TABLE(+0xbd5d8) [0xaaaaafb825d8]2020-07-29 18:01:02.726 CST [28776] STATEMENT: create table tab (id invalidtype); 回溯的每一行都有函数名、该函数的偏移量和该帧的返回地址 对于某些堆栈帧，函数名不存在; 相反，函数地址存在。这些都是静态函数。对于这样的函数，函数名不会公开。但是我们可以通过 addr2line 命令行工具从他们的地址中获取他们的名字: $ addr2line 0x20f550 0x44df20 -a -f -e which postgres0x000000000020f550transformColumnDefinition:?0x000000000044df20ProcessUtilitySlow.constprop.0:? 如果是调试版本，甚至会打印文件名和偏移量 现在让我们看看这个简单的特性是如何实现的 在包括 PostgreSQL、 Greenplum、 MySQL 在内的大多数 RDBMS 中，这个特性都是通过一个简单的函数 backtrace ()来生成 stacktrace: int backtrace(void **buffer, int size); 这个函数只返回帧的所有返回地址。因此，接下来应该调用 backtrace_symbols () ，该函数将 backtrace ()返回的地址转换成字符串，如果可用的话，使用函数名来描述地址: char **backtrace_symbols(void *const *buffer, int size); 这些函数的所有细节都在其man手册页中得到了很好的描述。这些功能在大多数平台上都是可用的. 注意以下几点: \\1. 要使函数名可用于 backtrace_symbols () ，必须使用链接器选项构建可执行文件，这些链接器选项允许将所有这些符号添加到“动态符号表”中。这些选项可以通过以下方式之一给出(这些是 gcc 编译器选项) :gcc -rdynamicgcc -Wl,-E \\2. 当使用 gcc -O2或更高的优化级别编译时，有时可能会丢失特定的堆栈帧。例如，检查这个示例程序backtrace.c 反向追踪 从backtrace() man手册页. 不使用 -O2来进行编译 :amit:pg:error$ gcc -rdynamic -o backtrace backtrace.cI get the full stack :amit:pg:error$ ./backtrace 6backtrace() returned 11 addresses./backtrace(myfunc3+0x2c) [0xaaaad6b2edc0]./backtrace(+0xe84) [0xaaaad6b2ee84]./backtrace(myfunc+0x2c) [0xaaaad6b2eebc]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(main+0x60) [0xaaaad6b2ef28]/lib/aarch64-linux-gnu/libc.so.6(__libc_start_main+0xe0) [0xffff8c5ba6e0]./backtrace(+0xcc4) [0xaaaad6b2ecc4] 使用 -O2来进行编译 :amit:pg:error$ gcc -O2 -rdynamic -o backtrace backtrace.camit:pg:error$ ./backtrace 6backtrace() returned 4 addresses./backtrace(myfunc3+0x38) [0xaaaac7183e40]./backtrace(main+0x4c) [0xaaaac7183cfc]/lib/aarch64-linux-gnu/libc.so.6(__libc_start_main+0xe0) [0xffffb91286e0]./backtrace(+0xd38) [0xaaaac7183d38] myfunc2()和 myfunc ()没有框架。一种可能性是编译器用尾端调用 myfunc3()替换了 myfunc ()和 myfunc2()的递归调用，这被称为尾端调用优化. 重点是: 我们需要意识到在一些情况下这种缺失的框架 PostgreSQL 13 has introduced a simple but extremely useful capability to log a stack trace into the server logs when an error is reported. Let’s see the details. There is a GUC to enable stacktrace generation : backtrace_functions. Set it to a comma-separated function names. SET backtrace_functions TO ‘func1,func2’; If the error is thrown from one of these functions, a backtrace will be generated and logged into the server log. Note that only superusers can set the backtrace_functions GUC. It can be set locally in a session, or can be included in postgresql.conf file to globally set it. It’s easy to see how it would help in a situation where a customer reports an error message. We can find from where it came from by grep’ing for it in the source code. But beyond that, it was all guess work. Not anymore. Now, you can ask the customer to set backtrace_functions to all such functions which are emitting this error message, and get the stack trace. In most cases, the root cause of the error is not in the function which emits the error; its located somewhere in the middle of the stack; hence the stack trace is critical. This capability is already available in many other databases like MySQL, Greenplum, Oracle. What’s still missing in PostgreSQL - and is present in most of these other databases - is being able to generate stack trace when a server backend crashes with a segmentation fault or other such unexpected signals, or when the server PANICs due to some reason. This capability would make a much bigger difference. We will get rid of having to explain steps to generate core file. More importantly, this helps in situations where the crash happens only randomly. Even with a single unexpected crash, the customer would always be ready with a backtrace. I am hopeful this would be implemented in the next major release of PostgreSQL. Let’s see how a PostgreSQL stack trace log looks like. We will try to use a non-existent type to create a table. Supposing we know that the “type does not exist” error comes from typenameType() in the source code. So we do this : postgres=# set backtrace_functions TO ‘typenameType’;postgres=# create table tab (id invalidtype);ERROR: type “invalidtype” does not existLINE 1: create table tab (id invalidtype); Here’s a snippet from the server log :2020-07-28 20:17:01.482 CST [22454] ERROR: type “invalidtype” does not exist at character 222020-07-28 20:17:01.482 CST [22454] BACKTRACE: postgres: amit postgres [local] CREATE TABLE(typenameType+0xa4) [0xaaaaafcd2ac4] postgres: amit postgres [local] CREATE TABLE(+0x20f550) [0xaaaaafcd4550] postgres: amit postgres [local] CREATE TABLE(transformCreateStmt+0x53c) [0xaaaaafcd7a10] postgres: amit postgres [local] CREATE TABLE(+0x44df20) [0xaaaaaff12f20] postgres: amit postgres [local] CREATE TABLE(standard_ProcessUtility+0x16c) [0xaaaaaff1225c] postgres: amit postgres [local] CREATE TABLE(+0x44a4e4) [0xaaaaaff0f4e4] postgres: amit postgres [local] CREATE TABLE(+0x44af88) [0xaaaaaff0ff88] postgres: amit postgres [local] CREATE TABLE(PortalRun+0x198) [0xaaaaaff10ed8] postgres: amit postgres [local] CREATE TABLE(+0x44764c) [0xaaaaaff0c64c] postgres: amit postgres [local] CREATE TABLE(PostgresMain+0x970) [0xaaaaaff0d3d4] postgres: amit postgres [local] CREATE TABLE(+0x3b3be4) [0xaaaaafe78be4] postgres: amit postgres [local] CREATE TABLE(PostmasterMain+0xdc0) [0xaaaaafe79b70] postgres: amit postgres [local] CREATE TABLE(main+0x480) [0xaaaaafb82510] /lib/aarch64-linux-gnu/libc.so.6(__libc_start_main+0xe0) [0xffffaac956e0] postgres: amit postgres [local] CREATE TABLE(+0xbd5d8) [0xaaaaafb825d8]2020-07-29 18:01:02.726 CST [28776] STATEMENT: create table tab (id invalidtype); Each line of the backtrace has the function name, an offset into that function, and the return address of that frame. For some stack frames, the function name is not present; instead, the function address is present. These are static functions. For such functions, the function names are not exposed. But we may be able to get their names from their addresses, with the help of addr2line command-line tool : $ addr2line 0x20f550 0x44df20 -a -f -e which postgres0x000000000020f550transformColumnDefinition:?0x000000000044df20ProcessUtilitySlow.constprop.0:? If it’s a debug build, even the file name and offset is printed. Now let’s see how this simple feature is implemented. In most of the RDBMS’s including PostgreSQL, Greenplum, MySQL, the feature is implemented using a simple function backtrace() to generate the stacktrace: int backtrace(void **buffer, int size); This function only returns all the return addresses of the frames. So it should be followed by a call to backtrace_symbols() that converts the addresses returned by backtrace() into strings that describe the addresses using the function names if available : char **backtrace_symbols(void *const *buffer, int size); All the details of these functions are nicely described in their man pages. These functions are available in most of the platforms. Note a couple of points : For the function names to be available for backtrace_symbols(), the executable has to be built using linker options that allow adding all these symbols into a “dynamic symbol table”. These options can be given with one of the following ways (these are gcc compiler options) :gcc -rdynamicgcc -Wl,-E Sometimes particular stack frames might be missing, when compiled with gcc -O2 or higher optimization level. E.g. check this sample program backtrace.c from the backtrace() man pages. I compile it without -O2 :amit:pg:error$ gcc -rdynamic -o backtrace backtrace.cI get the full stack :amit:pg:error$ ./backtrace 6backtrace() returned 11 addresses./backtrace(myfunc3+0x2c) [0xaaaad6b2edc0]./backtrace(+0xe84) [0xaaaad6b2ee84]./backtrace(myfunc+0x2c) [0xaaaad6b2eebc]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(myfunc+0x24) [0xaaaad6b2eeb4]./backtrace(main+0x60) [0xaaaad6b2ef28]/lib/aarch64-linux-gnu/libc.so.6(__libc_start_main+0xe0) [0xffff8c5ba6e0]./backtrace(+0xcc4) [0xaaaad6b2ecc4] Now I compile it with -O2 :amit:pg:error$ gcc -O2 -rdynamic -o backtrace backtrace.camit:pg:error$ ./backtrace 6backtrace() returned 4 addresses./backtrace(myfunc3+0x38) [0xaaaac7183e40]./backtrace(main+0x4c) [0xaaaac7183cfc]/lib/aarch64-linux-gnu/libc.so.6(__libc_start_main+0xe0) [0xffffb91286e0]./backtrace(+0xd38) [0xaaaac7183d38] There is no frame for myfunc2() and myfunc(). One possibility is that the compiler has replaced the recursive calls of myfunc() and also myfunc2() call with the tail end call myfunc3(), which is called tail call optimization. The point being: we need to be aware of such missing frames in a few scenarios. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/08/04/backtraces-in-postgresql/"},{"title":"Building Linux packages for different CPU architectures with Docker and QEMU","text":"作者: Martin Grigorov 原文链接: https://medium.com/@martin.grigorov/building-linux-packages-for-different-cpu-architectures-with-docker-and-qemu-d29e4ebc9fa5 Many Linux open source projects provide only source code releases. To be able to use them the users need to download the source code and to build it, usually by executing steps like: ./configure,make and make install. Some users prefer this way because they have the chance to configure the software by passing specific arguments to the ./configure script. It is also the preferred way from security point of view — the person responsible for managing the system is certain that this is the original version of the source code and no one added anything on top. Still many users prefer to download a binary package and install it, or to use the package management software of their favorite Linux distribution, e.g. yum for RedHat/CentOS/Fedora or apt for Debian/Ubuntu flavors. Here the benefit is that the dependencies are installed automatically for you. Some of the open source projects provide binary packages for download themselves. Others delegate the packaging task to their community or to the Linux distributions to package the software following the best practices for the specific package type. They do this for different reasons but most often because: 1) it is an extra burden — the software developers do not want to deal with “bureaucracy” different their domain of expertise 2) there are many Linux distributions with their specific packaging types, e.g. .deb, .rpm, .apk, etc. One needs to read a lot of documentation to understand each of them 3) another reason is because one may need specific hardware to be able to build a package for not so common CPU architectures. Usually developers work on Intel or AMD based computers known as x86_64 CPU architecture. But if your software needs to run on mobile phones or tables and Internet of Things (IoT) devices then you need to produce a binary for ARM architecture, also known as AARCH. ARMv7 and before is 32-bit. ARMv8, also known as aarch64, is 64-bit. Lately even more and more cloud providers recommend ARM64 CPUs because they have similar performance to the x86_64 ones but consume less electricity, so they are cheaper to rent and environment friendlier. In the rest of this article I’m going to show you how to build and package your software for ARM on x86_64 computer by using Docker and QEMU. What is Docker ?From Wikipedia: Docker is a set of platform as a service (PaaS) products that uses OS-level virtualization to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. All containers are run by a single operating system kernel and therefore use fewer resources than virtual machines. What is QEMU ?From Wikipedia: QEMU (short for Quick EMUlator) is a free and open-source emulator that performs hardware virtualization. QEMU is a hosted virtual machine monitor: it emulates the machine’s processor through dynamic binary translation and provides a set of different hardware and device models for the machine, enabling it to run a variety of guest operating systems. It also can be used with KVM to run virtual machines at near-native speed (by taking advantage of hardware extensions such as Intel VT-x). QEMU can also do emulation for user-level processes, allowing applications compiled for one architecture to run on another. Most of the cloud based Continuous Integration (CI) providers (e.g. TravisCI, CircleCI, DroneCI, Github Actions, and more) use Docker to provide you with a throw-away Docker container (a Linux instance) which you can modify the way you need, for example by installing required dependencies of your software or by even changing kernel settings, and then to build/test/package your software. Once your CI job finishes the docker container is discarded and the resources freed for the new CI job. The jobs are fully isolated from each other and this makes your build reproducible because they always start from the same state and there is nothing left from a previous job. BuildingThe process of building your software consists of two main steps: 1) register QEMU/binfmtIf you try to run a Docker container that is built for a different CPU architecture than the host’s it will fail with this error: 12$ docker run -it — rm arm64v8/centos:8 uname -mstandard_init_linux.go:211: exec user process caused “exec format error” To be able to run such foreign architectures one may use QEMU! Someone made the installation step as simple as executing: 1$ docker run -it — rm — privileged multiarch/qemu-user-static — credential yes — persistent yes What this does is: 1.2) run a Docker container that modifies the host. If it is executed inside a Docker container then it will modify the outer container. 1.3) The — privileged argument gives permissions to the Docker container to modify the host. In case it is run in a CI server then the host is the outer Docker container, the one allocated for our CI job. 1.4) The — credential yes argument is needed only if you need to use sudo later in step 2). 1.5) The — persistent yes argument tells it to load the interpreter when binfmt is configured and remains in memory. All future uses clone the interpreter from memory. If the execution of the command above is successful you should see output similar to the following: 1234567891011121314151617181920212223242526272829Setting /usr/bin/qemu-alpha-static as binfmt interpreter for alphaSetting /usr/bin/qemu-arm-static as binfmt interpreter for armSetting /usr/bin/qemu-armeb-static as binfmt interpreter for armebSetting /usr/bin/qemu-sparc-static as binfmt interpreter for sparcSetting /usr/bin/qemu-sparc32plus-static as binfmt interpreter for sparc32plusSetting /usr/bin/qemu-sparc64-static as binfmt interpreter for sparc64Setting /usr/bin/qemu-ppc-static as binfmt interpreter for ppcSetting /usr/bin/qemu-ppc64-static as binfmt interpreter for ppc64Setting /usr/bin/qemu-ppc64le-static as binfmt interpreter for ppc64leSetting /usr/bin/qemu-m68k-static as binfmt interpreter for m68kSetting /usr/bin/qemu-mips-static as binfmt interpreter for mipsSetting /usr/bin/qemu-mipsel-static as binfmt interpreter for mipselSetting /usr/bin/qemu-mipsn32-static as binfmt interpreter for mipsn32Setting /usr/bin/qemu-mipsn32el-static as binfmt interpreter for mipsn32elSetting /usr/bin/qemu-mips64-static as binfmt interpreter for mips64Setting /usr/bin/qemu-mips64el-static as binfmt interpreter for mips64elSetting /usr/bin/qemu-sh4-static as binfmt interpreter for sh4Setting /usr/bin/qemu-sh4eb-static as binfmt interpreter for sh4ebSetting /usr/bin/qemu-s390x-static as binfmt interpreter for s390xSetting /usr/bin/qemu-aarch64-static as binfmt interpreter for aarch64Setting /usr/bin/qemu-aarch64_be-static as binfmt interpreter for aarch64_beSetting /usr/bin/qemu-hppa-static as binfmt interpreter for hppaSetting /usr/bin/qemu-riscv32-static as binfmt interpreter for riscv32Setting /usr/bin/qemu-riscv64-static as binfmt interpreter for riscv64Setting /usr/bin/qemu-xtensa-static as binfmt interpreter for xtensaSetting /usr/bin/qemu-xtensaeb-static as binfmt interpreter for xtensaebSetting /usr/bin/qemu-microblaze-static as binfmt interpreter for microblazeSetting /usr/bin/qemu-microblazeel-static as binfmt interpreter for microblazeelSetting /usr/bin/qemu-or1k-static as binfmt interpreter for or1k Now if we try to run the foreign Docker image it will succeed: 12$ docker run -it — rm arm64v8/centos:8 uname -maarch64 The above tells us that uname -m executed inside arm64v8/centos:8 container returns that the CPU architecture is aarch64! If you want to understand how QEMU/binfmt works you can read its documentation but it is not required to know more for the purpose of this article. 2) Build your softwareAll we need to do now is to run the usual build steps (e.g. ./configure, make, make test, etc.) inside the foreign Docker container. 2.1) Create a Dockerfile that uses as a base image any image with foreign architecture, like arm64v8/centos:8 above.2.2) run the scripts One can use Docker’s RUN commands, e.g. 12RUN makeRUN make test but this may get wild if you need to execute many steps! I prefer to put all these commands in a Shell script, copy it to the custom Docker image and finally execute it. The script may look like this: 12345#!/usr/bin/env bashapt install -y dependency1 dependency2 dependencyN./configuremakemake test The Dockerfile will look something like: 123FROM arm64v8/centos:8ADD build-test-and-package.sh /usr/binCMD [“build-test-and-package.sh”] 2.3) Build the custom image1$ docker build -t my-arm-centos:8 . 2.4) Run it1$ docker run — rm -it -v $(pwd):/my-software my-arm-centos:8 Here we mount the current folder into /my-software folder inside the Docker container. build-test-and-package.sh needs to know this location to cd into it! Any result files, like the binary packages, could be saved in this folder or another mounted folder so that they can be consumed at the end of the CI workflow, e.g. to store them as artifacts of the build and copy them to AWS S3 or elsewhere. In actionYou can see all this in action at Varnish Cache GitHub repository. It is a Pull Request suggesting to build, test and package Varnish Cache for CentOS 7 &amp; 8, Ubuntu 16.04 &amp; 18.04, Debian 8, 9 &amp; 10, and Alpine 3, for both x86_64 and aarch64. Expending it for more distros, versions or CPU architectures is as easy as adding an additional CircleCI job with the proper parameters. The build graph looks like: The dist and tar_pkg_tools jobs run first in parallel. The dist job packages the source distribution and tar_pkg_tools gets the packaging recipes for RPM, DEB and APK from here. Those are stored in CircleCI’s workflow workspace and made available for any following jobs. Once both of them finish the next jobs that run in parallel are the distcheck and the package jobs. distcheck jobs build Varnish Cache on different distros and the package jobs build the respective binary packages for each arch/distro/version triple. If everything is successful finally the collect_packages job exports all binary packages as CircleCI artifacts which are later copied to Package Cloud. ConclusionUsing stable tools like Docker and QEMU makes it easier to build and test our software for different CPU architectures. There are few drawbacks though: 1) it is an emulation of the foreign CPU architecture, so it is slower than doing it on a real hardwareNote: Some cloud CI services like TravisCI and DroneIO provide support for ARM/ARM64. I have experience only with TravisCI and it is not faster than QEMU. I’ve had some small issues with it but it was easy to work them around. Hopefully it will become even better in the near future! 2) you need to find a good base Docker image for the CPU architecture you need to support. There are many images at DockerHub but depending on how exotic your needs are it may be harder to find one.","link":"/2020/04/23/building-linux-packages-for-different-cpu-architectures-with-docker-and-qemu/"},{"title":"HAproxy X86 vs ARM64性能比拼","text":"译者: wangxiyuan作者: Martin Grigorov原文链接: https://medium.com/@martin.grigorov/compare-haproxy-performance-on-x86-64-and-arm64-cpu-architectures-bfd55d1d5566 本文是由Apache Tomcat PMC Martin带来的Haproxy最新版本的性能测试报告。 中文 English HAProxy v2.2在几天前刚刚发布，所以我决定在 x86_64和 aarch64 虚拟机上对它运行负载测试: x86_64 12345678910111213141516171819202122232425262728Architecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianAddress sizes: 42 bits physical, 48 bits virtualCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 2Core(s) per socket: 4Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 85Model name: Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHzStepping: 7CPU MHz: 3000.000BogoMIPS: 6000.00Hypervisor vendor: KVMVirtualization type: fullL1d cache: 128 KiBL1i cache: 128 KiBL2 cache: 4 MiBL3 cache: 30.3 MiBNUMA node0 CPU(s): 0-7Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nons top_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowpref etch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx51 2cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat avx512_vnni md_clear flush_l1d arch_capabilities aarch64 123456789101112131415161718192021Architecture: aarch64CPU op-mode(s): 64-bitByte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 1Core(s) per socket: 8Socket(s): 1NUMA node(s): 1Vendor ID: 0x48Model: 0Stepping: 0x1CPU max MHz: 2400.0000CPU min MHz: 2400.0000BogoMIPS: 200.00L1d cache: 512 KiBL1i cache: 512 KiBL2 cache: 4 MiBL3 cache: 32 MiBNUMA node0 CPU(s): 0-7Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp asimdfhm 注意: 我尽可能的让虚拟机的硬件配置更接近，即使用相同的 RAM 类型和大小、相同的磁盘、网卡和带宽。此外，cpu 尽可能相似，但难免有一些差异： CPU 频率: 3000 MHz (x86 _ 64) vs 2400 MHz (aarch64) BogoMIPS: 6000(x86 _ 64) vs 200(aarch64) 一级缓存: 128 KiB (x86 _ 64) vs 512 KiB (aarch64) 两个虚拟机都运行在最新版的Ubuntu 20.04上。 我的HAProxy 是从master分支的源代码构建的，代码与HAProxy v2.2的几乎没有区别。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758HA-Proxy version 2.3-dev0 2020/07/07 - https://haproxy.org/Status: development branch - not safe for use in production.Known bugs: https://github.com/haproxy/haproxy/issues?q=is:issue+is:openRunning on: Linux 5.4.0-40-generic #44-Ubuntu SMP Mon Jun 22 23:59:48 UTC 2020 aarch64Build options : TARGET = linux-glibc CPU = generic CC = clang-9 CFLAGS = -O2 -Wall -Wextra -Wdeclaration-after-statement -fwrapv -Wno-address-of-packed-member -Wno-unused-label -Wno-sign-compare -Wno-unused-parameter -Wno-missing-field-initializers -Wno-string-plus-int -Wtype-limits -Wshift-negative-value -Wnull-dereference -Werror OPTIONS = USE_PCRE=1 USE_PCRE_JIT=1 USE_OPENSSL=1 USE_LUA=1 USE_ZLIB=1 USE_DEVICEATLAS=1 USE_51DEGREES=1 USE_WURFL=1 USE_SYSTEMD=1Feature list : +EPOLL -KQUEUE +NETFILTER +PCRE +PCRE_JIT -PCRE2 -PCRE2_JIT +POLL -PRIVATE_CACHE +THREAD -PTHREAD_PSHARED +BACKTRACE -STATIC_PCRE -STATIC_PCRE2 +TPROXY +LINUX_TPROXY +LINUX_SPLICE +LIBCRYPT +CRYPT_H +GETADDRINFO +OPENSSL +LUA +FUTEX +ACCEPT4 +ZLIB -SLZ +CPU_AFFINITY +TFO +NS +DL +RT +DEVICEATLAS +51DEGREES +WURFL +SYSTEMD -OBSOLETE_LINKER +PRCTL +THREAD_DUMP -EVPORTSDefault settings : bufsize = 16384, maxrewrite = 1024, maxpollevents = 200Built with multi-threading support (MAX_THREADS=64, default=8).Built with OpenSSL version : OpenSSL 1.1.1f 31 Mar 2020Running on OpenSSL version : OpenSSL 1.1.1f 31 Mar 2020OpenSSL library supports TLS extensions : yesOpenSSL library supports SNI : yesOpenSSL library supports : TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3Built with Lua version : Lua 5.3.3Built with DeviceAtlas support (dummy library only).Built with 51Degrees Pattern support (dummy library).Built with WURFL support (dummy library version 1.11.2.100)Built with network namespace support.Built with zlib version : 1.2.11Running on zlib version : 1.2.11Compression algorithms supported : identity(&quot;identity&quot;), deflate(&quot;deflate&quot;), raw-deflate(&quot;deflate&quot;), gzip(&quot;gzip&quot;)Built with transparent proxy support using: IP_TRANSPARENT IPV6_TRANSPARENT IP_FREEBINDBuilt with PCRE version : 8.39 2016-06-14Running on PCRE version : 8.39 2016-06-14PCRE library supports JIT : yesEncrypted password support via crypt(3): yesBuilt with clang compiler version 9.0.1 Available polling systems : epoll : pref=300, test result OK poll : pref=200, test result OK select : pref=150, test result OKTotal: 3 (3 usable), will use epoll.Available multiplexer protocols :(protocols marked as &lt;default&gt; cannot be specified using 'proto' keyword) fcgi : mode=HTTP side=BE mux=FCGI &lt;default&gt; : mode=HTTP side=FE|BE mux=H1 h2 : mode=HTTP side=FE|BE mux=H2 &lt;default&gt; : mode=TCP side=FE|BE mux=PASSAvailable services : noneAvailable filters : [SPOE] spoe [COMP] compression [TRACE] trace [CACHE] cache [FCGI] fcgi-app 我已经试图通过遵循我在官方文档和网络上找到的所有最佳实践来尽可能地优化它。 HAProxy的配置如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445global log stdout format raw local0 err# nbproc 8 nbthread 32 cpu-map 1/all 0-7 tune.ssl.default-dh-param 2048 tune.ssl.capture-cipherlist-size 1 ssl-server-verify none maxconn 32748 daemondefaults timeout client 60s timeout client-fin 1s timeout server 30s timeout server-fin 1s timeout connect 10s timeout http-request 10s timeout http-keep-alive 10s timeout queue 10m timeout check 10s mode http log global option dontlog-normal option httplog option dontlognull option http-use-htx option http-server-close option http-buffer-request option redispatch retries 3000frontend test_fe bind :::8080 #bind :::8080 ssl crt /home/ubuntu/tests/tls/server.pem default_backend test_bebackend test_be #balance roundrobin balance leastconn #balance random(2) server go1 127.0.0.1:8081 no-check server go2 127.0.0.1:8082 no-check server go3 127.0.0.1:8083 no-check server go4 127.0.0.1:8084 no-check 通过这种方式，HAProxy 被用作四个 HTTP 服务的前端负载均衡器。 想使用 SSL方式的话，只需要注释掉第34行并取消注释第35行。 我使用了多线程设置以获得最佳结果。正如文档所说，这是推荐的设置，而且它也使吞吐量提高了近两倍！此外经过我把吞吐量从8个线程增加到16个线程，再从16个线程增加到32个线程的设置后，发现使用32个线程的效果最好，当使用64个线程时吞吐量开始下降。 我还使用CPU-map 1/all 0-7将线程固定在同一个 CPU中。 另一个重要的设置是用于平衡后端的算法。就像Willy Tarreau的测试一样。 正如在 HAProxy Enterprice 文档中所推荐的，我已经禁用了irqbalance。 最后，我应用了以下内核设置: 12345sudo sysctl -w net.ipv4.ip_local_port_range=&quot;1024 65024&quot;sudo sysctl -w net.ipv4.tcp_max_syn_backlog=100000sudo sysctl -w net.core.netdev_max_backlog=100000sudo sysctl -w net.ipv4.tcp_tw_reuse=1sudo sysctl -w fs.file-max=500000 fs.file-max 也与/etc/security/limits. conf中的一些更改有关: 1234root soft nofile 500000root hard nofile 500000* soft nofile 500000* hard nofile 500000 对于后端，我使用了用 Golang 编写的非常简单的 HTTP 服务器。他们只是将“ Hello World”写回客户机，而不从磁盘或网络读/写: 12345678910111213141516171819202122232425package main// run with: env PORT=8081 go run http-server.goimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;os&quot;)func main() { port := os.Getenv(&quot;PORT&quot;) if port == &quot;&quot; { log.Fatal(&quot;Please specify the HTTP port as environment variable, e.g. env PORT=8081 go run http-server.go&quot;) } http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request){ fmt.Fprintf(w, &quot;Hello World&quot;) }) log.Fatal(http.ListenAndServe(&quot;:&quot; + port, nil))} 对用负载测试客户端，我使用了与测试Apache Tomcat相同设置的WRK。 结果如下: aarch64, HTTP 12345678Running 30s test @ http://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.67ms 8.82ms 196.74ms 89.85% Req/Sec 2.60k 337.06 5.79k 75.79% 621350 requests in 30.09s, 75.85MB readRequests/sec: 20651.69Transfer/sec: 2.52MB x86_64, HTTP 12345678Running 30s test @ http://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 3.32ms 4.46ms 75.42ms 94.58% Req/Sec 4.71k 538.41 8.84k 82.41% 1127664 requests in 30.10s, 137.65MB readRequests/sec: 37464.85Transfer/sec: 4.57MB aarch64, HTTPS 12345678Running 30s test @ https://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 7.92ms 12.50ms 248.52ms 91.18% Req/Sec 2.42k 338.67 4.34k 80.88% 578210 requests in 30.08s, 70.58MB readRequests/sec: 19220.81Transfer/sec: 2.35MB x86_64, HTTPS 12345678Running 30s test @ https://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 3.56ms 4.83ms 111.51ms 94.25% Req/Sec 4.46k 609.37 7.23k 85.60% 1066831 requests in 30.07s, 130.23MB readRequests/sec: 35474.26Transfer/sec: 4.33MB 我们可以发现： 在 x86_64 VM 上，HAProxy 的速度几乎是 aarch64 VM 的两倍。 并且 TLS offloading减少了5-8% 的吞吐量 更新1(2020年7月10日) : 为了确定基于 Golang 的 HTTP 服务器是否是上述测试中的瓶颈，我决定直接针对一个后端(即跳过 HAProxy)运行相同的 WRK 负载测试。 aarch64, HTTP 12345678Running 30s test @ http://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 615.31us 586.70us 22.44ms 90.61% Req/Sec 20.05k 1.57k 42.29k 73.62% 4794299 requests in 30.09s, 585.24MB readRequests/sec: 159319.75Transfer/sec: 19.45MB x86_64, HTTP 12345678Running 30s test @ http://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 774.24us 484.99us 36.43ms 97.04% Req/Sec 15.28k 413.04 16.89k 73.57% 3658911 requests in 30.10s, 446.64MB readRequests/sec: 121561.40Transfer/sec: 14.84MB 在这里我们看到运行在 aarch64上的 HTTP 服务比运行在 x86– 64上的要快30% ！ 更重要的观察结果是，当根本不使用负载均衡器时，arm64的吞吐量要好几倍！我认为问题在于我的设置ーー HAProxy 和4个后端服务器都运行在同一个虚拟机上，所以它们在争夺资源！下面我计划把Golang服务固定到他们自己的 CPU 核心上，让 HAProxy 只使用其他4个 CPU 核心！敬请期待最新消息！ 更新2(2020年7月10日) : 为了将进程固定到特定的 cpu，我将使用numactl。 12345678$ numactl — hardwareavailable: 1 nodes (0)node 0 cpus: 0 1 2 3 4 5 6 7node 0 size: 16012 MBnode 0 free: 170 MBnode distances:node 00: 10 我已经将 Golang HTTP 服务固定在以下几个方面: 12numactl — cpunodebind=0 — membind=0 — physcpubind=4 env PORT=8081 go run etc/haproxy/load/http-server.go 例如，这个后端实例被固定到 CPU 节点0和物理 CPU 4。其他三个后端服务分别固定在物理 cpu 5、6和7上。 我还对 HAProxy 的配置做了一些改动: 1234nbthread 4cpu-map 1/all 0–3Nbthread 4cpu-map 1/all 0-3 也就是说，HAProxy 将产生4个线程，它们将被固定到物理 cpu 0-3上。 通过这些改变，aarch64的结果保持不变: 12345678Running 30s test @ https://192.168.0.232:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 1.44ms 2.11ms 36.48ms 88.36% Req/Sec 4.98k 651.34 6.62k 74.40% 596102 requests in 30.10s, 72.77MB readRequests/sec: 19804.19Transfer/sec: 2.42MB 但是 x86_64下降了: 123456789Running 30s test @ https://192.168.0.206:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 767.40us 153.24us 19.07ms 97.72% Req/Sec 5.21k 173.41 5.51k 63.46% 623911 requests in 30.10s, 76.16MB readRequests/sec: 20727.89Transfer/sec: 2.53MB 对于 HTTP (没有 TLS)也是如此: aarch64 123456789Running 30s test @ http://192.168.0.232:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 1.40ms 2.16ms 36.55ms 88.08% Req/Sec 5.55k 462.65 6.97k 69.85% 665269 requests in 30.10s, 81.21MB read Requests/sec: 22102.12 Transfer/sec: 2.70MB x86_64 12345678Running 30s test @ http://192.168.0.206:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 726.01us 125.04us 6.42ms 93.95% Req/Sec 5.51k 165.80 5.80k 57.24% 658777 requests in 30.10s, 80.42MB read Requests/sec: 21886.50 Transfer/sec: 2.67MB 因此，现在 HAProxy 在 aarch64上的速度比 x86_64稍快一些，但仍然远远低于每秒120000多个请求的“空负载均衡器”方法。 更新3(2020年7月10日) : 在看到 Golang HTTP 服务的性能非常好(120-160K reqs/sec)并简化设置之后，我决定从 Update 2中删除 CPU固定，并使用来自其他 VM 的后端，例如，当在aarch64虚拟机上运行HAProxy时，它将在x86_64上运行的后端之间进行负载均衡；当使用WRK在x86_64上运行HAProxy时，它将使用aarch64虚拟机上运行的 Golang HTTP服务。以下是新的结果： aarch64, HTTP 12345678Running 30s test @ http://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.33ms 4.93ms 76.85ms 89.14% Req/Sec 2.10k 316.84 3.52k 74.50% 501840 requests in 30.07s, 61.26MB readRequests/sec: 16688.53Transfer/sec: 2.04MB x86_64, HTTP 12345678Running 30s test @ http://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 5.32ms 6.71ms 71.29ms 90.25% Req/Sec 3.26k 639.12 4.14k 65.52% 779297 requests in 30.08s, 95.13MB readRequests/sec: 25908.50Transfer/sec: 3.16MB aarch64, HTTPS 12345678Running 30s test @ https://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.17ms 5.41ms 292.21ms 91.08% Req/Sec 2.13k 238.74 3.85k 86.32% 506111 requests in 30.09s, 61.78MB readRequests/sec: 16821.60Transfer/sec: 2.05MB x86_64, HTTPS 12345678Running 30s test @ https://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 3.40ms 2.54ms 58.66ms 97.27% Req/Sec 3.82k 385.85 4.55k 92.10% 914329 requests in 30.10s, 111.61MB readRequests/sec: 30376.95Transfer/sec: 3.71MB 祝你黑客生活愉快，注意安全！ HAProxy 2.2 has been released few days ago so I’ve decided to run my load tests against it on my x86_64 and aarch64 VMs: x86_64 12345678910111213141516171819202122232425262728Architecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianAddress sizes: 42 bits physical, 48 bits virtualCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 2Core(s) per socket: 4Socket(s): 1NUMA node(s): 1Vendor ID: GenuineIntelCPU family: 6Model: 85Model name: Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHzStepping: 7CPU MHz: 3000.000BogoMIPS: 6000.00Hypervisor vendor: KVMVirtualization type: fullL1d cache: 128 KiBL1i cache: 128 KiBL2 cache: 4 MiBL3 cache: 30.3 MiBNUMA node0 CPU(s): 0-7Flags: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss ht syscall nx pdpe1gb rdtscp lm constant_tsc rep_good nopl xtopology nons top_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowpref etch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm mpx avx512f avx512dq rdseed adx smap clflushopt clwb avx51 2cd avx512bw avx512vl xsaveopt xsavec xgetbv1 arat avx512_vnni md_clear flush_l1d arch_capabilities aarch64 123456789101112131415161718192021Architecture: aarch64CPU op-mode(s): 64-bitByte Order: Little EndianCPU(s): 8On-line CPU(s) list: 0-7Thread(s) per core: 1Core(s) per socket: 8Socket(s): 1NUMA node(s): 1Vendor ID: 0x48Model: 0Stepping: 0x1CPU max MHz: 2400.0000CPU min MHz: 2400.0000BogoMIPS: 200.00L1d cache: 512 KiBL1i cache: 512 KiBL2 cache: 4 MiBL3 cache: 32 MiBNUMA node0 CPU(s): 0-7Flags: fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm jscvt fcma dcpop asimddp asimdfhm Note: the VMs are as close as possible in their hardware capabilities — same type and amount of RAM, same disks, network cards and bandwidth. Also the CPUs are as similar as possible but there are some differences the CPU frequency: 3000 MHz (x86_64) vs 2400 MHz (aarch64) BogoMIPS: 6000 (x86_64) vs 200 (aarch64) Level 1 caches: 128 KiB (x86_64) vs 512 KiB (aarch64) Both VMs run Ubuntu 20.04 with latest software updates. HAProxy is built from source for the master branch, so it might have few changes since the cut of haproxy-2.2 tag! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758HA-Proxy version 2.3-dev0 2020/07/07 - https://haproxy.org/Status: development branch - not safe for use in production.Known bugs: https://github.com/haproxy/haproxy/issues?q=is:issue+is:openRunning on: Linux 5.4.0-40-generic #44-Ubuntu SMP Mon Jun 22 23:59:48 UTC 2020 aarch64Build options : TARGET = linux-glibc CPU = generic CC = clang-9 CFLAGS = -O2 -Wall -Wextra -Wdeclaration-after-statement -fwrapv -Wno-address-of-packed-member -Wno-unused-label -Wno-sign-compare -Wno-unused-parameter -Wno-missing-field-initializers -Wno-string-plus-int -Wtype-limits -Wshift-negative-value -Wnull-dereference -Werror OPTIONS = USE_PCRE=1 USE_PCRE_JIT=1 USE_OPENSSL=1 USE_LUA=1 USE_ZLIB=1 USE_DEVICEATLAS=1 USE_51DEGREES=1 USE_WURFL=1 USE_SYSTEMD=1Feature list : +EPOLL -KQUEUE +NETFILTER +PCRE +PCRE_JIT -PCRE2 -PCRE2_JIT +POLL -PRIVATE_CACHE +THREAD -PTHREAD_PSHARED +BACKTRACE -STATIC_PCRE -STATIC_PCRE2 +TPROXY +LINUX_TPROXY +LINUX_SPLICE +LIBCRYPT +CRYPT_H +GETADDRINFO +OPENSSL +LUA +FUTEX +ACCEPT4 +ZLIB -SLZ +CPU_AFFINITY +TFO +NS +DL +RT +DEVICEATLAS +51DEGREES +WURFL +SYSTEMD -OBSOLETE_LINKER +PRCTL +THREAD_DUMP -EVPORTSDefault settings : bufsize = 16384, maxrewrite = 1024, maxpollevents = 200Built with multi-threading support (MAX_THREADS=64, default=8).Built with OpenSSL version : OpenSSL 1.1.1f 31 Mar 2020Running on OpenSSL version : OpenSSL 1.1.1f 31 Mar 2020OpenSSL library supports TLS extensions : yesOpenSSL library supports SNI : yesOpenSSL library supports : TLSv1.0 TLSv1.1 TLSv1.2 TLSv1.3Built with Lua version : Lua 5.3.3Built with DeviceAtlas support (dummy library only).Built with 51Degrees Pattern support (dummy library).Built with WURFL support (dummy library version 1.11.2.100)Built with network namespace support.Built with zlib version : 1.2.11Running on zlib version : 1.2.11Compression algorithms supported : identity(&quot;identity&quot;), deflate(&quot;deflate&quot;), raw-deflate(&quot;deflate&quot;), gzip(&quot;gzip&quot;)Built with transparent proxy support using: IP_TRANSPARENT IPV6_TRANSPARENT IP_FREEBINDBuilt with PCRE version : 8.39 2016-06-14Running on PCRE version : 8.39 2016-06-14PCRE library supports JIT : yesEncrypted password support via crypt(3): yesBuilt with clang compiler version 9.0.1 Available polling systems : epoll : pref=300, test result OK poll : pref=200, test result OK select : pref=150, test result OKTotal: 3 (3 usable), will use epoll.Available multiplexer protocols :(protocols marked as &lt;default&gt; cannot be specified using 'proto' keyword) fcgi : mode=HTTP side=BE mux=FCGI &lt;default&gt; : mode=HTTP side=FE|BE mux=H1 h2 : mode=HTTP side=FE|BE mux=H2 &lt;default&gt; : mode=TCP side=FE|BE mux=PASSAvailable services : noneAvailable filters : [SPOE] spoe [COMP] compression [TRACE] trace [CACHE] cache [FCGI] fcgi-app I’ve tried to fine tune it as much as I could by following all best practices I was able to find in the official documentation and in the web. The HAProxy config is: 123456789101112131415161718192021222324252627282930313233343536373839404142434445global log stdout format raw local0 err# nbproc 8 nbthread 32 cpu-map 1/all 0-7 tune.ssl.default-dh-param 2048 tune.ssl.capture-cipherlist-size 1 ssl-server-verify none maxconn 32748 daemondefaults timeout client 60s timeout client-fin 1s timeout server 30s timeout server-fin 1s timeout connect 10s timeout http-request 10s timeout http-keep-alive 10s timeout queue 10m timeout check 10s mode http log global option dontlog-normal option httplog option dontlognull option http-use-htx option http-server-close option http-buffer-request option redispatch retries 3000frontend test_fe bind :::8080 #bind :::8080 ssl crt /home/ubuntu/tests/tls/server.pem default_backend test_bebackend test_be #balance roundrobin balance leastconn #balance random(2) server go1 127.0.0.1:8081 no-check server go2 127.0.0.1:8082 no-check server go3 127.0.0.1:8083 no-check server go4 127.0.0.1:8084 no-check This way HAProxy is used as a load balancer in front of four HTTP servers. To also use it as a SSL terminator one just needs to comment out line 34 and uncomment line 35. The best results I’ve achieved by using the multithreaded setup. As the documentation says this is the recommended setup anyway but it also gave me almost twice better throughput! In addition the best results were with 32 threads. The throughput was increasing from 8 to 16 and from 16 to 32, but dropped when used 64 threads. I’ve also pinned the threads to stay at the same CPU for its lifetime with cpu-map 1/all 0–7. The other important setting is the algorithm to use to balance between the backends. Just like in Willy Tarreau’s tests for me leastconn gave the best performance. As recommended at HAProxy Enterprice documentation I’ve disabled irqbalance. Finally I’ve applied the following kernel settings: 12345sudo sysctl -w net.ipv4.ip_local_port_range=&quot;1024 65024&quot;sudo sysctl -w net.ipv4.tcp_max_syn_backlog=100000sudo sysctl -w net.core.netdev_max_backlog=100000sudo sysctl -w net.ipv4.tcp_tw_reuse=1sudo sysctl -w fs.file-max=500000 fs.file-max is related also with a change in /etc/security/limits.conf: 1234root soft nofile 500000root hard nofile 500000* soft nofile 500000* hard nofile 500000 For backend I used very simple HTTP servers written in Golang. They just write “Hello World” back to the client without reading/writing from/to disk or to the network: 12345678910111213141516171819202122232425package main// run with: env PORT=8081 go run http-server.goimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;os&quot;)func main() { port := os.Getenv(&quot;PORT&quot;) if port == &quot;&quot; { log.Fatal(&quot;Please specify the HTTP port as environment variable, e.g. env PORT=8081 go run http-server.go&quot;) } http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request){ fmt.Fprintf(w, &quot;Hello World&quot;) }) log.Fatal(http.ListenAndServe(&quot;:&quot; + port, nil))} As load testing client I have used WRK with the same setup as for testing Apache Tomcat. And now the results: aarch64, HTTP 12345678Running 30s test @ http://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.67ms 8.82ms 196.74ms 89.85% Req/Sec 2.60k 337.06 5.79k 75.79% 621350 requests in 30.09s, 75.85MB readRequests/sec: 20651.69Transfer/sec: 2.52MB x86_64, HTTP 12345678Running 30s test @ http://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 3.32ms 4.46ms 75.42ms 94.58% Req/Sec 4.71k 538.41 8.84k 82.41% 1127664 requests in 30.10s, 137.65MB readRequests/sec: 37464.85Transfer/sec: 4.57MB aarch64, HTTPS 12345678Running 30s test @ https://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 7.92ms 12.50ms 248.52ms 91.18% Req/Sec 2.42k 338.67 4.34k 80.88% 578210 requests in 30.08s, 70.58MB readRequests/sec: 19220.81Transfer/sec: 2.35MB x86_64, HTTPS 12345678Running 30s test @ https://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 3.56ms 4.83ms 111.51ms 94.25% Req/Sec 4.46k 609.37 7.23k 85.60% 1066831 requests in 30.07s, 130.23MB readRequests/sec: 35474.26Transfer/sec: 4.33MB What we see here is: that HAProxy is almost twice faster on the x86_64 VM than the aarch64 VM! and also that TLS offloading decreases the throughput with around 5–8% Update 1 (Jul 10 2020): To see whether the Golang based HTTP servers are not the bottleneck in the above testing I’ve decided to run the same WRK load tests directly against one of the backends, i.e. skip HAProxy. aarch64, HTTP 12345678Running 30s test @ http://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 615.31us 586.70us 22.44ms 90.61% Req/Sec 20.05k 1.57k 42.29k 73.62% 4794299 requests in 30.09s, 585.24MB readRequests/sec: 159319.75Transfer/sec: 19.45MB x86_64, HTTP 12345678Running 30s test @ http://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 774.24us 484.99us 36.43ms 97.04% Req/Sec 15.28k 413.04 16.89k 73.57% 3658911 requests in 30.10s, 446.64MB readRequests/sec: 121561.40Transfer/sec: 14.84MB Here we see that the HTTP server running on aarch64 is around 30% faster than on x86_64! And the more important observation is that the throughput is several times better when not using load balancer at all! I think the problem here is in my setup — both HAProxy and the 4 backend servers run on the same VM, so they fight for resources! I will pin the Golang servers to their own CPU cores and let HAProxy use only the other 4 CPU cores! Stay tuned for an update! Update 2 (Jul 10 2020): To pin the processes to specific CPUs I will use numactl. 12345678$ numactl — hardwareavailable: 1 nodes (0)node 0 cpus: 0 1 2 3 4 5 6 7node 0 size: 16012 MBnode 0 free: 170 MBnode distances:node 00: 10 I’ve pinned the Golang HTTP servers with: 12numactl — cpunodebind=0 — membind=0 — physcpubind=4 env PORT=8081 go run etc/haproxy/load/http-server.go i.e. this backend instance is pinned to CPU node 0 and to physical CPU 4. The other three backend servers are pinned respectively to physical CPUs 5, 6 and 7. Also I’ve changed slightly the HAProxy configuration: 1234nbthread 4cpu-map 1/all 0–3Nbthread 4cpu-map 1/all 0-3 i.e. HAProxy will spawn 4 threads and they will be pinned to physical CPUs 0–3. With these changes the results stayed the same for aarch64: 12345678Running 30s test @ https://192.168.0.232:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 1.44ms 2.11ms 36.48ms 88.36% Req/Sec 4.98k 651.34 6.62k 74.40% 596102 requests in 30.10s, 72.77MB readRequests/sec: 19804.19Transfer/sec: 2.42MB but dropped for x86_64: 123456789Running 30s test @ https://192.168.0.206:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 767.40us 153.24us 19.07ms 97.72% Req/Sec 5.21k 173.41 5.51k 63.46% 623911 requests in 30.10s, 76.16MB readRequests/sec: 20727.89Transfer/sec: 2.53MB and same for HTTP (no TLS): aarch64 123456789Running 30s test @ http://192.168.0.232:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 1.40ms 2.16ms 36.55ms 88.08% Req/Sec 5.55k 462.65 6.97k 69.85% 665269 requests in 30.10s, 81.21MB read Requests/sec: 22102.12 Transfer/sec: 2.70MB x86_64 12345678Running 30s test @ http://192.168.0.206:8080 4 threads and 16 connections Thread Stats Avg Stdev Max +/- Stdev Latency 726.01us 125.04us 6.42ms 93.95% Req/Sec 5.51k 165.80 5.80k 57.24% 658777 requests in 30.10s, 80.42MB read Requests/sec: 21886.50 Transfer/sec: 2.67MB So now HAProxy is a bit faster on aarch64 than on x86_64 but still far slower than the “no load balancer” approach with 120 000+ requests per second. Update 3 (Jul 10 2020): After seeing that the performance of the Golang HTTP server is so good (120–160K reqs/sec) and to simplify the setup I’ve decided to remove the CPU pinning from Update 2 and to use the backends from the other VM, i.e. when hitting HAProxy on the aarch64 VM it will load balance between the backends running on the x86_64 and when WRK hits HAProxy running on the x86_64 VM it will use the Golang HTTP servers running on the aarch64 VM. And here are the new results: aarch64, HTTP 12345678Running 30s test @ http://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.33ms 4.93ms 76.85ms 89.14% Req/Sec 2.10k 316.84 3.52k 74.50% 501840 requests in 30.07s, 61.26MB readRequests/sec: 16688.53Transfer/sec: 2.04MB x86_64, HTTP 12345678Running 30s test @ http://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 5.32ms 6.71ms 71.29ms 90.25% Req/Sec 3.26k 639.12 4.14k 65.52% 779297 requests in 30.08s, 95.13MB readRequests/sec: 25908.50Transfer/sec: 3.16MB aarch64, HTTPS 12345678Running 30s test @ https://192.168.0.232:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 6.17ms 5.41ms 292.21ms 91.08% Req/Sec 2.13k 238.74 3.85k 86.32% 506111 requests in 30.09s, 61.78MB readRequests/sec: 16821.60Transfer/sec: 2.05MB x86_64, HTTPS 12345678Running 30s test @ https://192.168.0.206:8080 8 threads and 96 connections Thread Stats Avg Stdev Max +/- Stdev Latency 3.40ms 2.54ms 58.66ms 97.27% Req/Sec 3.82k 385.85 4.55k 92.10% 914329 requests in 30.10s, 111.61MB readRequests/sec: 30376.95Transfer/sec: 3.71MB Happy hacking and stay safe! .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/07/14/haproxy-x86-vs-arm64-xing-neng-bi-pin/"},{"title":"Linux下获取ARMv8-A CPU详情的3种方法","text":"作者：郑振宇 在ARM平台上进行软件适配时，经常遇到需要根据不同CPU的具体型号、额外属性等信息进行分支处理的需求，因而需要获取CPU的详情信息；ARM架构CPU与X86架构芯片在CPU详情信息的呈现上有很大不同。本文将简述ARM CPU与CPU详情相关的知识及在Linux下获取ARMv8-A CPU详情的三种方法。 ARM CPU中有关CPU详情的寄存器根据ARM CPU官方技术手册，ARM CPU的CPU型号、Vendor、版本等信息存于MIDR_EL1寄存器中:其中从低至高第0-3 bit表示revision，代表固件版本的小版本号，如r1p3中的p3；第4-15 bit表示part number(id)，代表这款CPU在所在vendor产品中定义的产品代码，如在HiSilicon产品中，part_id=0xd01代表Kunpeng-920芯片；第16-19 bit表示architecture，即架构版本，0x8即ARMv8；第20-23 bit表示variant，即固件版本的大版本号，如r1p3中的r1；第24-31 bit表示implementer，即vendor id，如vendor_id=0x48表示HiSilicon。 想要知道一款ARM CPU的具体型号，则需要首先解析vendor_id(implementer) 然后再在该Vendor的所有型号中匹配part_id，才能获取到具体的信息；这里列出目前系统中已有的Vendor列表和其ID对应关系 Vendor Name Vendor ID ARM 0x41 Broadcom 0x42 Cavium 0x43 DigitalEquipment 0x44 HiSilicon 0x48 Infineon 0x49 Freescale 0x4D NVIDIA 0x4E APM 0x50 Qualcomm 0x51 Marvell 0x56 Intel 0x69 而对于具体型号来说，对应关系则更为复杂，这里就不一一列举，可以参考本站文章或util-linux/lscpu工具中的相关具体实现来获取完整的映射关系，lscpu工具我们则将在后面的部分中进行介绍。 上面介绍过，除了CPU型号之外，我们通常还会关注CPU是否支持我们需要的特性(扩展指令集，CPU Flags, CPU features)；与X86相差较大(CPU features定义集中在EBX,ECX和EDX寄存器中)，ARM架构的这些特性分散于ID_PFR0_EL1, ID_PFR1_EL1, ID_DFR0_EL1, ID_ISAR0_EL1 等等若干个专用寄存器中，解析起来难度较高，后面我们会详细讨论如何获取这些内容。 在Linux下如何获取CPU详情信息在介绍具体的方法前，首先需要介绍一下ARMv8架构下的安全分层机制(Exception Level):如上图所示，ARMv8架构是专为数据中心场景而设计的架构，相比较早的ARM架构，新增了EL2层用于实现硬件虚拟化；较高层的用户是无权直接限访问下一层的数据内容的，对于我们的场景来说，由上面介绍的内容中可以看到，前面所有介绍的寄存器都存在于EL1层，而我们通常使用的应用程序都处于EL0层，因此是无法直接访问到这些寄存器的。那么该如何读取这些内容呢？ 1. 从文件节点获取OS在启动时，会将底层硬件信息载入到相应的文件节点中，这样，位于EL0层的用户就可以通过读取这些文件节点来获取这些信息，比较常用的有两个： /sys/devices/system/cpu:该文件夹下保存了较全的CPU信息文件，并按单个CPU进行区分，读取其中某一个的regs文件目录就可以获得相应的CPU详情信息，如我们尝试获取CPU0的相关信息：可以看到，我们读取的仍然是MIDR_EL1寄存器相对应的信息，并且是未解析的数据，需要对应上文介绍的方法进行解析。并且目前没有在这个文件夹下找到CPU Flags的相关的信息，如果后续找到其所在位置，会刷新。 /proc/cpuinfo:通过读取cpuinfo可以看到，通过这种方法获取的CPU详情，是进行过解析的，对原始数据进行了拆分，并且是包含了CPU Flag信息的，但仍与X86下的结果有较大不同，各个key所对应的信息仍然需要根据表单进行解析才能转变为人为可读的信息。 2.使用LSCPU命令读取Linux内核的开发者显然也发现了上文介绍的两种方法获取信息不够全面且需要二次解析的问题，因此在Linux外围工具组util-linux/lscpu(wiki)中进行了改进，从2.32版本开始增加了对ARM平台CPU信息的解析，从而提供人为可读的内容(由于2019年11月才合入相关Patch，HiSilicon芯片的解析需要手动编译最新主干代码才能实现)。从上图可以看到，lscpu提供了非常丰富且直观的内容。 3.使用内联汇编和辅助向量直接解析上文介绍的两种方法相对来说比较简单，但需要进行读取文件、运行外部命令等操作；当想在自己的程序中引用上述信息时，速度会相对较慢且会引入新的依赖(lscpu)。因此最快速的方法是通过内联汇编直接读取并解析相应的寄存器；上文中已经提到，用户在EL0无法直接读取到位于EL1的寄存器内的内容，那么该如何去做呢？ ARM已经为我们准备好了一切，用户可以通过MRS指令将程序状态寄存器的内容传送到通用寄存器中，再进行进一步的解析，因此我们可以这样做： 12345678/* read the cpuid data from MIDR_EL1 register */asm(\"mrs %0, MIDR_EL1\" : \"=r\" (cpuid));VIR_DEBUG(\"CPUID read from register: 0x%016lx\", cpuid);/* parse the coresponding part_id bits */data-&gt;pvr = cpuid&gt;&gt;4&amp;0xFFF;/* parse the coresponding vendor_id bits */data-&gt;vendor_id = cpuid&gt;&gt;24&amp;0xFF; 这样就可以快速的获取CPUID相关的具体内容，在根据表格进行映射即可获得Vendor和Model信息； 对于CPU Flags，由于牵扯到的寄存器众多，读者可以根据ARM64 CPU Feature Registers中的示例程序进行依次进行寄存器读取，再根据相应的映射关系进行解析，也可以使用下面将要介绍的可读性更高的另一种方法。 Linux内核提供了getauxval()方法，用于读取辅助向量(auxiliary vector, 一个从内核到用户空间的信息交流机制)，通过读取相应的辅助向量，我们就能获取相应的硬件信息；辅助向量有很多，感兴趣的读者可以查看上面的链接，对于我们读取CPU Flags来说，关心的是AT_HWCAP这个辅助向量，通过getauxval()读取这个向量的值，可以获得整合过的CPU Flags信息，其bit定位规则则在hwcap.h，当然，每种架构下的对应关系不相同，需要根据需要进行查找。 那么，我们就可以采用下面的方法进行解析： 12345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;sys/auxv.h&gt;/* 通过移位Bit Mask来读取相应的标志位 */#define BIT_SHIFTS(n) (UL(1) &lt;&lt; (n))int main() { unsigned long hwcaps = getauxval(AT_HWCAP); int i; /* 目前ARMv8架构只有32种CPU Flags */ char *list[32] = {\"fp\\n\", \"asimd\\n\", \"evtstrm\\n\", \"aes\\n\", \"pmull\\n\", \"sha1\", \"sha2\\n\", \"crc32\\n\", \"atomics\\n\", \"fphp\\n\", \"asimdhp\\n\", \"cpuid\\n\", \"asimdrdm\\n\",\"jscvt\\n\", \"fcma\\n\", \"lrcpc\\n\", \"dcpop\\n\", \"sha3\\n\", \"sm3\\n\", \"sm4\\n\", \"asimddp\\n\" , \"sha512\\n\", \"sve\\n\", \"asimdfhm\\n\", \"dit\\n\", \"uscat\\n\", \"ilrcpc\\n\", \"flagm\\n\", \"ssbs\\n\", \"sb\\n\", \"paca\\n\",\"pacg\\n\",}; for (i = 0; i&lt; 32; i++){ if (hwcaps &amp; BIT_SHIFTS(i)) { printf(\"%s\\n\",list[i]); } }} 或者，可以直接通过hwcap.h中预先定义好的宏来做bit mask: 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;sys/auxv.h&gt;#include &lt;asm/hwcap.h&gt;int main(){ long hwcaps= getauxval(AT_HWCAP); if(hwcaps &amp; HWCAP_AES){ printf(\"AES instructions are available\\n\"); } if(hwcaps &amp; HWCAP_CRC32){ printf(\"CRC32 instructions are available\\n\"); } if(hwcaps &amp; HWCAP_PMULL){ printf(\"PMULL/PMULL2 instructions that operate on 64-bit data are available\\n\"); } if(hwcaps &amp; HWCAP_SHA1){ printf(\"SHA1 instructions are available\\n\"); } if(hwcaps &amp; HWCAP_SHA2){ printf(\"SHA2 instructions are available\\n\"); } return 0;}","link":"/2020/04/03/linux-xia-huo-qu-armv8-a-cpu-xiang-qing-de-3-chong-fang-fa/"},{"title":"Memcached  x86_64 VS arm64 性能对比","text":"译者: wangxiyuan作者: Martin Grigorov原文链接: https://medium.com/@martin.grigorov/compare-memcached-performance-on-x86-64-and-arm64-cpu-architectures-7fe781e34ab8 Tomcat PMC Martin Grigorov带来的另一篇ARM64 VS X86性能对比文章。 中文 English 上周，我分享了在 x86_64和 ARM64 CPU 架构上测试 Apache Tomcat 的结果。 在这篇文章中，我将测试 Memcached。 什么是 Memcached？ 摘自 Wikipedia: Memcached 是一个通用的分布式内存缓存系统。 它通常用于加速动态数据库驱动的网站，方法是在 RAM 中缓存数据和对象，以减少必须读取外部数据源(如数据库或 API)的次数。 与 Apache Tomcat 不同的是，Apache Tomcat 是用 Java 编写的，因此是多平台通用的。 而Memcached 是用 c 编写的，需要为不同的 CPU 体系构建它。 正如在其硬件 Wiki 页面 ARM64中所说的那样，它是官方支持的体系结构之一，并且有一个 BuildBot 构建器来测试所有的代码更改！ 如果您遇到任何问题，只要在项目的问题跟踪工具中报告它！ 项目的维护者 Dormando 会非常友好和积极响应！ 在我第一次尝试为 Memcached 找到一个好的负载测试工具时，我无意中发现了 RedisLabs Memtier Benchmark 工具。 在 Apache Tomcat 的文章中提到的同一个 vm 上运行它，结果如下: 123456789ASCII protocol on ARM64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 985.28 --- --- 20.02700 67.22 Gets 9842.00 0.00 9842.00 20.01900 248.83 Waits 0.00 --- --- 0.00000 --- Totals 10827.28 0.00 9842.00 20.02000 316.05 123456789ASCII protocol on x86_64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 931.04 --- --- 20.06800 63.52 Gets 9300.21 0.00 9300.21 20.32600 235.13 Waits 0.00 --- --- 0.00000 --- Totals 10231.26 0.00 9300.21 20.30200 298.66 上面我们可以看到，Memcached 服务运行在 ARM64虚拟机会稍微快一点！ 注意: Memcached 服务器运行的默认设置(最大1024连接，4线程和64M 内存) ，即没有指定自定义值。 对于二进制协议，数字几乎是一样的: 12345678910Binary protocol on ARM64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 829.68 --- --- 23.46500 63.90 Gets 8287.69 0.00 8287.69 23.56100 314.75 Waits 0.00 --- --- 0.00000 --- Totals 9117.37 0.00 8287.69 23.55200 378.65 123456789Binary protocol on x86_64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 829.32 --- --- 23.63600 63.87 Gets 8284.10 0.00 8284.10 23.58600 314.61 Waits 0.00 --- --- 0.00000 --- Totals 9113.42 0.00 8284.10 23.59100 378.48 在我与 Memcached 社区分享了这些结果之后，社区建议我使用 MC Crusher 工具代替。 实际上，结果比之相关的数据要好得多: ASCII protocol GET operations per second ASCII protocol SET operations per second 在第一个图表中，你可以看到在 x86_64和 ARM64上，每秒大约有150万次 get 操作！ 在第二张图表中，在 ARM64上每秒运行90万次，在 x86_64上每秒运行84万次。 注意: 由于 mc-crusher 工具不提供任何统计数据。因而我使用 Memcached 的统计命令，以获得执行的操作的数量。 下面是用于负载测试的设置: 服务器的启动方式如下: 1$ memcached -t 16 -c 256 -m 2048 即16线程，最多256个并发连接和2Gb 内存。 MC Crusher a. GET配置 12send=ascii_get,recv=blind_read,conns=100,key_prefix=foobar,pipelines=10send=ascii_set,recv=blind_read,conns=10,key_prefix=foobar,pipelines=4,stop_after=200000,usleep=1000,value_size=10 b. SET配置 1send=ascii_set,recv=blind_read,conns=100,key_prefix=foobar,value_size=2,value=hi,pipelines=10 注意: 在 GET 操作的图表中，你可以看到在2020年5月13日，这个数字从每秒950K 次左右上升到每秒160万次左右。 在那一天，我升级了我用作客户机的 VM，也就是我运行负载测试工具(mc-crusher)的地方，因为我注意到在测试运行期间，当客户机本身超载时会出现峰值。 我们再一次看到，ARM64服务器可以快到和 x86_64一样！ 如果你对如何改善这个Memcached 测试或如何衡量一些其他方面有任何的想法，随意与我分享您的意见！ 祝你黑客生活愉快，注意安全！ Last week I’ve shared with you the results of load testing Apache Tomcat on x86_64 and ARM64 CPU architecture. In this article I will test Memcached. What is Memcached ? From Wikipedia: Memcached is a general-purpose distributed memory-caching system. It is often used to speed up dynamic database-driven websites by caching data and objects in RAM to reduce the number of times an external data source (such as a database or API) must be read. In contrast to Apache Tomcat which is written in Java and thus is multi-platform Memcached is written in C and one needs to build it especially for the your CPU architecture. As stated at its Hardware Wiki page ARM64 is one of the officially supported architectures and there is a BuildBot builder testing all code changes! If you face any issue just report it at the project’s issue tracker! Dormando, the project maintainer, is very friendly and responsive! In my first attempt to find a good load testing tool for Memcached I stumbled upon RedisLabs Memtier Benchmark tool. Running it on the same VMs as in the article for Apache Tomcat and the results were: 123456789ASCII protocol on ARM64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 985.28 --- --- 20.02700 67.22 Gets 9842.00 0.00 9842.00 20.01900 248.83 Waits 0.00 --- --- 0.00000 --- Totals 10827.28 0.00 9842.00 20.02000 316.05 123456789ASCII protocol on x86_64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 931.04 --- --- 20.06800 63.52 Gets 9300.21 0.00 9300.21 20.32600 235.13 Waits 0.00 --- --- 0.00000 --- Totals 10231.26 0.00 9300.21 20.30200 298.66 Above we see that the Memcached server running on the ARM64 VM was slightly faster! Note: the Memcached server was running with default settings (maximum 1024 connections, 4 threads and 64M memory), i.e. without specifying custom values. For binary protocol the numbers are almost the same: 123456789Binary protocol on ARM64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 829.68 --- --- 23.46500 63.90 Gets 8287.69 0.00 8287.69 23.56100 314.75 Waits 0.00 --- --- 0.00000 --- Totals 9117.37 0.00 8287.69 23.55200 378.65 123456789Binary protocol on x86_64=========================================================================Type Ops/sec Hits/sec Misses/sec Latency KB/sec -------------------------------------------------------------------------Sets 829.32 --- --- 23.63600 63.87 Gets 8284.10 0.00 8284.10 23.58600 314.61 Waits 0.00 --- --- 0.00000 --- Totals 9113.42 0.00 8284.10 23.59100 378.48 After sharing these results with Memcached community it was recommended to me to use MC Crusher tool instead. And indeed the numbers are much better with it: ASCII protocol GET operations per second ASCII protocol SET operations per second In the first chart you may see that both on x86_64 and ARM64 it makes around 1.5 million get operations per second! On the second chart it makes a little bit more than 900 thousand set operations per second on ARM64 and around 840 thousand ops per second on x86_64. Note: Since mc-crusher tool does not provide any statistics from its execution I used Memcached’s stats command to get the number of executed operations. Here are the settings used for the load test: The servers are started with: 1$ memcached -t 16 -c 256 -m 2048 i.e. with 16 threads, maximum of 256 simultaneous connections and 2Gb memory. MC Crusher a. GET config 12send=ascii_get,recv=blind_read,conns=100,key_prefix=foobar,pipelines=10send=ascii_set,recv=blind_read,conns=10,key_prefix=foobar,pipelines=4,stop_after=200000,usleep=1000,value_size=10 b. SET config 1send=ascii_set,recv=blind_read,conns=100,key_prefix=foobar,value_size=2,value=hi,pipelines=10 Note: In the chart for the GET operation you see that the number rises at May 13th 2020 from around 950K operations per second to around 1.6 million ops/s. At that day I’ve upgraded the VM that I use as a client, i.e. where I run the load testing tools (mc-crusher) because I’ve noticed that during the test run there were spikes when the client itself was overloaded. Once again we saw that ARM64 on the server could be as fast as x86_64! If you have ideas how to improve this test or how to measure some other aspect of Memcached feel free to share it with me in the comments! Happy hacking and stay safe! .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/05/20/memcached-x86-64-vs-arm64-xing-neng-dui-bi/"},{"title":"MySQL on x86 vs ARM","text":"作者: Krunal Bauskar By and large this would be a topic of interest for most of us including me when I started to explore this space. Before we dwell into the numbers let’s first understand some basic differences between 2 architectures. Beyond being CISC and RISC let’s look at the important differences from MySQL perspective. Strong vs Weak memory model (weak memory model needs proper memory barrier while writing lock-free code). Underlying hardware specific specialized instructions. For example: both now support crc32c hardware instructions but being low-level they are different ways to invoke them. For more differences checkout for x86-SSE/ARM-ACLE. Cache Line differences. Most of the ARM processors tend to use bigger cache lines (128 bytes for all caches or a mix of 64/128 bytes). Other sys-call level differences like: absence of PAUSE instructions with ARM and substitute instruction with very low latency failing to induce needed delay, sched_getcpu is costlier on ARM introducing challenges with use of lock-free construct, memory operations seems to show higher latency, etc… Community has contributed multiple patches around this space (Topic for another blog). Since MySQL just started supporting MySQL on ARM there are few optimizations but most of the work is yet to be done. PerformanceNow let’s look at the most important aspect: Performance We tested the performance of MySQL (current release 8.0.19) on x86 and ARM. Details of the test and machine are given below. Test Setup 24 vCPU/48 GB Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz for running MySQL on x86. 24 vCPU/48 GB ARM @ 2.60GHz for running MySQL on ARM sysbench is running on a dedicated machine located in the same data-center. sysbench steps: Load Tables. (Same seed db is reused for multiple runs so warmup is needed). Checksum based warmup. Run checksum on all tables. For checksum, flow needs to fetch the rows in the buffer pool there-by causing it to warm up. Query based warm up. Can skip but helpful if you are using adaptive hash indexes. Execute TC (oltp-read-write/oltp-update-index/oltp-update-non-index/oltp-read-only/oltp-point-select) Each TC is executed for N different scalability. Given 24 vCPU tried it for 1/2/4/8/16/32/128/256. Before switching TC, an intermediate sleep is introduced to help flush changes from previous TC. This can’t ensure all changes are flushed but sleep of X secs ensures least impact on followup TC. MySQL-Server Configuration: BP is large enough to accomodate complete data in-memory For more details please check the following configuration details Details of running the scripts and automated test-script to invoke sysbench are also [available here](https://github.com/mysqlonarm/benchmark-suites) Run specific details: Table: 96-tables * 1.5 million (data-size= 34GB) Buffer Pool: 36GB Redo-Log: 4GB*2 TC-run-time: 300 secs TC-warmup: 60 (sysbench –warmup-time) workload-query-based warmup: 600 change-over-sleep: 180 checksum-based-warmup: enabled data-storage: 300GB (support for 16500 IOPS (nullify effect of Burst IOPS)). Note: Frequency Scaling (FS). Given ARM is running @ 2.6 GHz vs x86 is running @ 3.0 GHz. Comparing them directly is not fair. In order to compensate for the frequency difference, graphs also add frequency-scaled tps/qps for ARM (ARM-fscaled simply extrapolate original ARM tps/qps number by (3/2.6) factor). In real life, the factor could be a bit on the higher side given increasing CPU frequency can affect contention graphs and wait cycles. 1. Point Select: threads ARM (qps) x86 (qps) ARM (qps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 6696 6439 7726 4 20 2 12482 11774 14402 6 22 4 23881 21308 27555 12 29 8 45993 42110 53069 9 26 16 88517 81239 102135 9 26 32 142974 136724 164970 5 21 64 198839 212484 229430 -6 8 128 217778 241555 251282 -10 4 256 209797 224009 242073 -6 8 Analysis: ARM performs better than x86 for lower scalability but fails to scale at same rate with increasing scalability. With frequency scaling applied ARM continues to beat x86 despite of the scalability issues. 2. Read Only: threads ARM (qps) x86 (qps) ARM (qps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 5222 5259 6025 -1 15 2 10333 10200 11923 1 17 4 19176 19349 22126 -1 14 8 36881 37035 42555 0 15 16 70337 67065 81158 5 21 32 109207 113210 126008 -4 11 64 139294 164148 160724 -15 -2 128 151382 175872 174672 -14 -1 256 149136 164382 172080 -9 5 Analysis: ARM is almost on par with x86 for lower scalability but again fails to scale for higher scalability. With frequency scaling applied ARM continues to beat x86 (in most cases). 3. Read Write: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 137 149 158 -8 6 2 251 273 290 -8 6 4 462 502 533 -8 6 8 852 920 983 -7 7 16 1539 1678 1776 -8 6 32 2556 2906 2949 -12 1 64 3770 5158 4350 -27 -16 128 5015 8131 5787 -38 -29 256 5676 8562 6549 -34 -24 Analysis: Pattern is different with read-write workload. ARM starts lagging. Frequency scaling helps ease this lag for lower scalability but increasing scalability continues to increase the gap. 4. Update Index: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 328 373 378 -12 1 2 623 768 719 -19 -6 4 1060 1148 1223 -8 7 8 1905 2028 2198 -6 8 16 3284 3590 3789 -9 6 32 5543 6275 6396 -12 2 64 9138 10381 10544 -12 2 128 13879 16868 16014 -18 -5 256 19954 25459 23024 -22 -10 Analysis: Frequency scaled ARM continues to perform on par/better with x86 (except for heavy contention use-cases). 5. Update Non-Index: threads ARM (tps) x86 (tps) ARM (tps - fscaled (FS)) % ARM-vs-x86 % ARM (FS)-vs-x86 1 328 373 378 -12 1 2 588 686 678 -14 -1 4 1075 1118 1240 -4 11 8 1941 2043 2240 -5 10 16 3367 3662 3885 -8 6 32 5681 6438 6555 -12 2 64 9328 10631 10763 -12 1 128 14158 17245 16336 -18 -5 256 20377 26367 23512 -23 -11 Analysis: Frequency scaled ARM continues to perform on par/better with x86 (except for heavy contention use-cases). ConclusionThere are some important observations we can make: For read only workload MySQL on ARM continues to perform on-par with MySQL on x86. For write involving workload MySQL on ARM starts lagging a bit but if we consider frequency scaling things start getting better. Frequency scaling is not a real life parameter so we should consider the price-per-performance ratio. This could be a topic in itself but just a quick fact: ARM instance is 66% cheaper than x86 (24U48G same one we used). There is a pattern that we can observe. ARM workloads are very well scalable till it hits the CPU limits. With increasing scalability, contention increases and ARM starts lagging. This is expected since mutexes/contention hot-spots were all tuned for x86 (for example: spin-lock). But now that MySQL officially supports ARM and the growing ARM community and interest, it would be tuned for ARM too. To summarize, MySQL on ARM is a worth exploring option from a cost and performance perspective. If you have more questions/queries do let me know. Will try to answer them.","link":"/2020/04/08/mysql-on-x86-vs-arm/"},{"title":"Mysql社区ARM优化汇总","text":"译者: bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/Community-Contributions-So-Far/ 社区拥有来自不同组织的开发人员为 MySQL 提供了一些很好的补丁。但是这些补丁中的大多数都在等待Oracle的接受。 这篇博客的目的是分析这些补丁以及它们的利弊。希望这将有助于 Mysql / Oracle 接受这些期待已久的补丁。 中文 English 社区Patches1. 校验和优化 Mysql 使用的校验和有两种: crc32c 和 crc32。因为它们使用不同的多项式而导致它们的之间的不同。 crc32c 被用来在 MySQL Innodb中计算页面校验和 crc32在 MySQL 中用于表校验和、 binlog-checksum 等… crc32c 页面校验和是在读/写每个页面时进行的，所以crc32c可以在perl报告中快速的展示出来。确保在使用优化版本后，它能够提高整个系统的性能。 crc32c 通常是由硬件完成的功能，例如在 x86(SSE)和 ARM (ACLE)。 Innodb 目前使用基于硬件的 x86实现，但还没有使用 ARM (ACLE)实现。 必要的补丁修复有助于解决上述问题。 最新的补丁(bug # 85819)还有助于在使用 crypto (PMULL)处理指令时来进行进一步优化. 开源贡献:bug#79144 No hardware CRC32 implementation for AArch64bug#85819 Optimize AARCH64 CRC32c implementation 123456789101112131415[example test-case runs update-non-index and gets the crc32 as top mysqld function].perf analysis (w/o patch)+ 10.43% 8027 mysqld [kernel.kallsyms] [k] _raw_spin_unlock_irqrestore + 3.23% 2486 mysqld mysqld [.] ut_crc32_sw + 2.33% 1797 mysqld [kernel.kallsyms] [k] finish_task_switch + 1.73% 1330 mysqld libc-2.27.so [.] malloc perf analysis (w/ patch) Overhead Samples Command Shared Object Symbol + 10.60% 8133 mysqld [kernel.kallsyms] [k] _raw_spin_unlock_irqrestore + 2.37% 1816 mysqld [kernel.kallsyms] [k] finish_task_switch + 1.78% 1366 mysqld libc-2.27.so [.] malloc .... 0.44% 338 mysqld mysqld [.] ut_crc32_aarch64 结论: 明显可以考到节省了大约3%的吞吐量。另外，在更加广泛的测试中，我们可以看到crc32有助于提高所有类型测试场景下的吞吐量。 crc32为了计算表校验和，MySQL 使用基于 zlib 的 crc32(软实现)。 据我所知，x86不支持 crc32计算的硬件优化版本，但幸运的是 ARM (ACLE)支持。 同时Binlog-checksum 也使用相同的代码 / 处理流程。 开源贡献:bug#99118 ARM CRC32 intrinsic call to accelerate table-checksum (not crc32c but crc32) 123456789101112131415161718[example test-case runs checksum on all tables and update-non-index].perf analysis (w/o patch)checksum:+ 49.46% 13480 mysqld mysqld [.] crc32_zupdate-non-index: 0.40% 311 mysqld mysqld [.] crc32_z perf analysis (w/ patch)checksum:+ 8.15% 988 mysqld mysqld [.] aarch64_crc32_checksum update-non-index: 0.07% 56 mysqld mysqld [.] aarch64_crc32_checksum 结论: 这个补丁在两个方面都有提升。超级加速表校验和(平均提高50%) ，并且在 binlog 校验和中也是。 2. my_convert (in turn copy_and_convert) 在ARM平台表现不好: my_convert用作发送结果的一部分步骤中，主要是用于在字符集之间进行转换。 给定转换的数据量，这个函数会出现在 perf top-list 中 现有的实现对于 x86使用4字节的复制，但对于 ARM 则退回到单字节复制。 通过对 x86-64和 aarch64使用8个字节的复制，然后再到现有逻辑的尾部处理过程，可以总体改进这一点。 这个简单的补丁可以帮助节省大量的时钟周期并提高系统性能。 开源贡献:bug#98737 my_convert routine is suboptimal in case of non-x86 platforms 123456[example test-case runs oltp-read-write on all tables].perf analysis (w/o patch)+ 0.79% 1114 mysqld mysqld [.] my_convertperf analysis (w/ patch) 0.22% 299 mysqld mysqld [.] my_convert 结论: 这个补丁提高了吞吐量。 3. 为原子变量优化内存屏障: Mysql / innodb 有很多变量，它使用 gcc 内置的原子函数(sync add and fetch 或 atomic add fetch). 虽然在x86的强内存模型，它们表现很好，但是大多数这些计数器函数中都是使用顺序内存排序(缺省)来实现的。 因为Arm 的弱内存模型，因此不推荐使用这种顺序内存排序(缺省的)。 社区多个补丁来帮助修改这些代码片段。它们有助于实现两个目标: 切换到使用 c + + 11原子函数(MySQL现已支持)。 切换到使用松散的内存顺序(vs 顺序)。 开源贡献:bug#97228 rwlock: refine lock-&gt;lock_word with C11 atomicsbug#97230 rwlock: refine lock-&gt;waiters with C++11 atomicsbug#97703 innobase/dict: refine dict_temp_file_num with c++11 atomicsbug#97704 innobase/srv: refine srv0conc with c++11 atomicsbug#97765 innobase/os: refine os_total_large_mem_allocated with c++11 atomicsbug#97766 innobase/os_once: optimize os_once with c++11 atomicsbug#97767 innobase/dict: refine zip_pad_info-&gt;pad with c++11 atomicsbug#99432 Improving memory barrier during rseg allocation 结论: 由于它的影响分布非常广，所以很难用perf来进行判断。另外，部分修复仅仅是为了改进语义，而不是为了性能因素。 4. 为全局计数器带来核心亲和性调度:Arm 以拥有大量的核心(和 numa 套接字)而闻名，为了从多核中获得最大的吞吐量，确保全局计数器的可编程性是非常重要的。拥有一个分布式计数器并将计数器的递增部分尽量与线程核心靠近，应该可以避免跨numa延迟。 MySQL通过调用call sched_getcpu来获取计数器插槽，但是这个逻辑由于另一个bug的修复而改变了(这对于上述问题来说当然是有意义的) ， 这个bug修复影响了正常的全局计数器。下面的补丁提议纠正这一点，并使用sched_getcpu(核心亲和性)来实现全局计数器。 不幸的是，在 ARM 上，这个补丁由于使用了 sched_getcpu 而产生了开销，但是在x86上在使用VDSO时进行了优化。 开源贡献:bug#79455 Restore get_sched_indexer_t in 5.7 5. 当前UT_RELAX_CPU () 在ARM平台上的可伸缩性问题:Innodb 使用自制的 spin-wait 来实现 rw-locks 和 mutexes。 无论何时需要休眠(或让我纠正称它为PAUSE) ，在 x86 MySQL 上支持PAUSE指令。 ARM不支持 PAUSE 指令，因此流程中使用编译器屏障，但是该指令未能引入所需的延迟。 修补程序建议使用Compare-And-Exchange，这应该有助于引入类似的延迟(如PAUSE)。 开源贡献:bug#87933 Scalibility issue on Arm platform with the current UT_RELAX_CPU () code. 基于内部评估，我们得不到补丁所带来的吞吐量提升，因此目前没有将其纳入我们贡献到社区的内容。 6. 在ARM上应用更宽的cacheline来填充:大多数 ARM 处理器计划拥有更宽的cacheline size。 补丁提出基于 ARM 处理器使用更大的cachelilne，并填充以避免false sharing问题。 开源贡献:bug#98499 Improvement about CPU cache line size 7. 其他开源贡献除了上面列出的6个大类，在其他领域也有很多的贡献。 但是大多数都没有相关的代码提交，或者这个想法已经作为另一个重大改进被放在 MySQL 中(不是针对 ARM 的工作) ，又或者是这个idea不太可能对性能产生影响。 社区补丁对性能的影响基于上面收集的内容，我们分析了引入社区补丁后对性能的影响，下面的表显示了如果我们合入这些补丁，吞吐量将如何提高。 结果限制在较大的可伸缩性(256线程)，因为它显示了主要的影响，我们已经全面运行了测试用例，确定补丁有助于提高总吞吐量(即使对于单线程而言)。 point select read only read write update index update non index without-patch 218447 145755 5646 22200 22601 with-patch 224355 149718 5829 23070 23292 % 2.7 2.72 3.24 3.92 3.06 使用 mysql-8.0.20进行评估。配置参看 here. 处理器: ARM Kunpeng 920 24vCPU/48GB 结论社区提供的补丁确实有助于优化 ARM 上的 MySQL，但影响程度有限，并且需要覆盖很多领域才能看到 MySQL 在 ARM 上加速的程度。 如果你有好的想法，请联系我或者直接在社区进行交流。 ARM MySQL 社区可以尽情针对这一问题爆发头脑风暴，并尝试实现修复这个问题的idea。 如果你有问题 / 疑问，请让我知道，我会尽力回答。 Community Patches1. Optimizing checksum MySQL uses 2 types of checksum: crc32c and crc32. They both are different since both uses different polynomials. crc32c is used in MySQL by InnoDB to calculate page-checksum. crc32 is used in MySQL for table checksum, binlog-checksum, etc… crc32c Page checksum is calculated during each page read/write so crc32c can quickly show up as one of the top functions in perf report. Ensuring use of optimized versions of it could help improve the overall throughput of the system. crc32c has been implemented as a hardware function on both x86 (SSE) and ARM (ACLE). InnoDB currently uses hardware based implementation for x86 but not yet for ARM (ACLE). Patch helps address the said issue. Latest patch (bug#85819) also helps further optimize it using crypto (PMULL) processing instruction. Open Contributions:bug#79144 No hardware CRC32 implementation for AArch64bug#85819 Optimize AARCH64 CRC32c implementation 123456789101112131415[example test-case runs update-non-index and gets the crc32 as top mysqld function].perf analysis (w/o patch)+ 10.43% 8027 mysqld [kernel.kallsyms] [k] _raw_spin_unlock_irqrestore + 3.23% 2486 mysqld mysqld [.] ut_crc32_sw + 2.33% 1797 mysqld [kernel.kallsyms] [k] finish_task_switch + 1.73% 1330 mysqld libc-2.27.so [.] malloc perf analysis (w/ patch) Overhead Samples Command Shared Object Symbol + 10.60% 8133 mysqld [kernel.kallsyms] [k] _raw_spin_unlock_irqrestore + 2.37% 1816 mysqld [kernel.kallsyms] [k] finish_task_switch + 1.78% 1366 mysqld libc-2.27.so [.] malloc .... 0.44% 338 mysqld mysqld [.] ut_crc32_aarch64 Conclusion: Clearly a saving of around 3% in overall throughput can be seen. Also, as part of wider testing we see crc32c helps in overall throughput gain for all kind of test-cases. crc32For calculating table checksum MySQL uses zlib-based crc32. As per my knowledge, x86 doesn’t support hardware optimized versions for crc32 calculation but fortunately ARM (ACLE) supports it. The same code/flow path is also used for binlog-checksum. Open Contributions:bug#99118 ARM CRC32 intrinsic call to accelerate table-checksum (not crc32c but crc32) 123456789101112131415161718[example test-case runs checksum on all tables and update-non-index].perf analysis (w/o patch)checksum:+ 49.46% 13480 mysqld mysqld [.] crc32_zupdate-non-index: 0.40% 311 mysqld mysqld [.] crc32_z perf analysis (w/ patch)checksum:+ 8.15% 988 mysqld mysqld [.] aarch64_crc32_checksum update-non-index: 0.07% 56 mysqld mysqld [.] aarch64_crc32_checksum Conclusion: This patch helps on both front. Super-accelerate table checksum (average improvement of 50%) and also marginally helps in binlog-checksum. 2. my_convert (in turn copy_and_convert) routine is suboptimal for ARM: my_convert is used as part of the send result for converting among charsets. Given the amount of the data that is converted this function gets spotted in perf top-list. Existing implementation uses 4 bytes copying for x86 but falls back to byte copy for ARM. This could be overall improved by using 8 bytes copying for x86-64 and aarch64 and then falling back for trailing things to existing logic. Patch for this simple operation help save significant cycles and help improve performance. Open Contributions:bug#98737 my_convert routine is suboptimal in case of non-x86 platforms 123456[example test-case runs oltp-read-write on all tables].perf analysis (w/o patch)+ 0.79% 1114 mysqld mysqld [.] my_convertperf analysis (w/ patch) 0.22% 299 mysqld mysqld [.] my_convert Conclusion: Patch can help improve overall throuhgput. 3. Improving memory barrier for atomic variables: MySQL/InnoDB has a lot of variables for which it uses gcc inbuilt atomic functions (__sync_add_and_fetch or __atomic_add_fetch). While this is all good x86 being a strong memory model most of these counter functions were implemented to use sequential memory ordering (default). ARM has a relaxed memory model so using sequential memory ordering (default one) is not recommended. Multiple patches were submitted to help revamp the said snippets. Patches help achieve 2 things: Switch to use C++11 atomics. (Now that MySQL supports it). Switch to use relaxed memory order (vs sequential). Open Contributions:bug#97228 rwlock: refine lock-&gt;lock_word with C11 atomicsbug#97230 rwlock: refine lock-&gt;waiters with C++11 atomicsbug#97703 innobase/dict: refine dict_temp_file_num with c++11 atomicsbug#97704 innobase/srv: refine srv0conc with c++11 atomicsbug#97765 innobase/os: refine os_total_large_mem_allocated with c++11 atomicsbug#97766 innobase/os_once: optimize os_once with c++11 atomicsbug#97767 innobase/dict: refine zip_pad_info-&gt;pad with c++11 atomicsbug#99432 Improving memory barrier during rseg allocation Conclusion: Impact is wide spread so difficult to judge using perf. Also, some of the fixes help improve semantics and may not be for performance reason as such. 4. Restore core affinity scheduler for global counter:ARM is known for its large number of cores (and numa sockets) and to harvest the max throughput from multi-cores it is important to ensure that global counters are programmed accordingly. Having a distributed counter and incrementing part of the counter closer to the thread core should avoid cross-numa latency. MySQL use to call sched_getcpu for getting the counter slots but this logic was changed as part of the different bug fix (that surely made sense for the said issue) but it also affected the normal global counters. Patch proposes to correct this and use sched_getcpu (core affinity) based counter for global counters. On ARM this patch unfortunately is running into overhead resulting from use of sched_getcpu which is optimized on x86 using VDSO. Open Contributions:bug#79455 Restore get_sched_indexer_t in 5.7 5. Scalability issue on ARM platform with the current UT_RELAX_CPU () code:InnoDB uses home-grown spin-wait implementation for rw-locks and mutexes. Whenever there is a need to sleep (or let me correctly say PAUSE) then on x86 MySQL uses supported PAUSE instruction. ARM doesn’t have support for PAUSE instruction so the flow uses a compiler barrier but this statement fails to introduce the needed delay. Patch suggest use of Compare-And-Exchange that should help introduce comparable delay (like PAUSE). Open Contributions:bug#87933 Scalibility issue on Arm platform with the current UT_RELAX_CPU () code. Based on internal evaluation we couldn’t get the patch to help improve on throughput so have not-considered it as part of our community-patch branch for now. 6. Using wider cacheline padding for ARM:Most of the ARM processors are scheduled to have a wider cache line. Patch proposes use of a wider cache line padding for ARM based processors to avoid false sharing. Open Contributions:bug#98499 Improvement about CPU cache line size 7. Other open contributionsBesides the 6 main categories listed above there are more contributions in other areas too. But most of them didn’t have a patch associated or the said idea has been folded in MySQL as part of another major revamp (not specific to ARM work) or the idea is less likely to have a performance impact. So for now we were not able to consider these set of patches. Performance impact of Community PatchesBased on the inputs collected above we have analyzed performance impact of community patches and below table help shows how the throughput would improve if the said patches are accepted. Limiting results for higher scalability (256 threads) where it shows major effect but we have run test-case across the board and patches helps improve overall throughput (even for single threaded). point select read only read write update index update non index without-patch 218447 145755 5646 22200 22601 with-patch 224355 149718 5829 23070 23292 % 2.7 2.72 3.24 3.92 3.06 Evaluated using mysql-8.0.20. For configuration check here. Processor: ARM Kunpeng 920 24vCPU/48GB ConclusionPatches contributed by community surely helps in optimizing MySQL on ARM but the impact is still limited and lot of ground to cover to make MySQL accelerate on ARM. If you have good ideas on how things could be pushed further then let’s connect. ARM MySQL community can help brainstorm the idea and aid/help in materializing it to a contribution. If you have more questions/queries do let me know. Will try to answer them. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/05/13/mysql-she-qu-arm-you-hua-hui-zong/"},{"title":"NUMA 智能全局计数器 -- 来自MySQL的灵感","text":"译者: bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/NUMA-Smart-Global-Counter/ 通过之前在X86, ARM虚机上的调研，与遇到的跨NUMA问题，结合自身在运行benchmark测试中的经验，让应用程序在针对特定的全局数据结构中更好的应用底层硬件，达到极致性能体验。下面来用数据说话。 中文 English 在多线程系统中管理全局计数器一直是一项挑战。 它们是限制软件可扩展性的一大难题。NUMA 的引入只是增加了复杂性。 幸运的是，在硬件平台提供的支持下发现了多种选择，以帮助解决 / 缓解其中的一些问题。 在本博客中，我们将讨论如何使全局计数器感知NUMA，做到智能选择NUMA，并且看看每种方法对性能有什么影响。 注意: 很多这方面的工作都是受 MySQL 代码库的启发，是由于MySQL 代码库不断发展中会尝试解决这个问题。 全局计数器大部分软件(例如: 数据库、web-server等等)都需要维持全局计数器。 由于是全局的，这些计数器只有一个副本，有多个工作线程试图更新它。 当然，这复杂的更新需要进行精细的协调，单从这一点，在性能上它就成为可伸缩性的热点分析对象。 另一种方式是松散地维护这些计数器（不加任何协调工作），但这意味着它们将表示一个近似的数字（特别是在竞争激烈的系统上）。这样不会对性能有过多影响，有一定的益处。 让我们看看当前生态系统提供了哪些方法来帮助解决这个问题。 配置说明为了评估不同的方法，我们将考虑一个通用的设置。In order to evaluate different approaches we will consider a common setup. 试想一些counter-block，它们位于全局级别，因此所有线程都会时不时地更新它们 试想一些data-block(实际工作负载发生的地方) ，data-block的一部分操作会更新本地全局计数器。 每个数据块都有自己的本地计数器。 只要访问data-block，就会更新这些本地计数器。 这两个data-block是交错的。 请参阅以下的分布图 让我们通过一些简单的数值例子来理解这个结构。 假设我们有100个全局counter-block，每个data-block有10个counter。 假设我们有1000个全局data-block，它们与counter-block互相交织在一起。 这意味着，1-counter-block 计数器块之后是10个数据块，这样组合重复100次。 这样可以确保在 NUMA 节点上分布完整的内存块，并且在访问计数器和data-block时可以看到对NUMA 产生的影响。 Workload (one-round): 将访问 n 个data-block(至少足以使 L2缓存失效)。 作为data-block访问的一部分，还更新与data-block相关联的本地计数器。 data-block是使用 rand ()函数随机选择的，以确保扩散分布。 接下来是从counter-block访问和更新全局计数器。 随机选择counter-block，并从中随机选择一个计数器(inc 操作)。 重复 M次。 Workload 循环 K 次(rounds). 每个线程执行上述Workload循环(K 次) ，从1-256 / 2048开始使用不同的可伸缩性进行基准测试。 注意: 计数器只是简单的uint64_t 值(目前只使用 inc 操作)。 如果您有兴趣了解更多关于这方面的信息，您可以随时查看这里的详细代码。 使用的硬件描述 x86-vm: 24 vCPU (12 cores with HT), 48 GB memory, 2 NUMA nodes, Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz (Ubuntu-18.04) arm-vm: 24 vCPU (24 cores), 48 GB memory, 2 NUMA nodes, Kunpeng 920 2.60 GHz (Ubuntu-18.04) 用于1-2048伸缩性测试的机器 arm-bms: 128 physical cores, 1 TB of memory, 4 NUMA nodes, Kunpeng 920 2.60 GHz (CentOS-7.8) 我们的意图不是比较 x86和 ARM，而是比较 NUMA 对全局计数器的影响。 测试方案作为实验的一部分，我们评估了从基础到高级的多种方法。 pthread-mutex based: 保护计数器操作的简单 pthread mutexes std::mutex: C++11 支持的 std::mutexes，和pthread mutexes很像，但是更容易使用。 std::atomic: C++11 原子变量。 fuzzy-counter (来自mysql): 有 n 个 cacheline 对齐的插槽。 随机选择要更新的一个插槽。 若要计算计数器的总值，需要从所有槽中添加值。 没有用于保护槽操作的互斥对象 / 原子对象。 这意味着数值是近似的，但是当需要想之前计算总是时效果最好。 我们将在结果部分看到一个方差系数。[ref: ib_counter_t. N 通常是核心的数量] shard-atomic-counter (来自mysql): 计数器被分割成 N个分片(如上面的 slot)。 每个处理流程都需要知道更新哪个分片。 为了高效的访问，分片都做了cacheline对齐。 [ ref: Counter: : Shard ] shard-atomic-counter (thread-id based): 计数器被分割成 N 个分片(如上面的槽)。 根据执行线程的线程 id 选择要更新的分片。 为了高效的访问，分片都做了cacheline对齐。[这里 N是活动核心的数量] shard-atomic-counter (cpu-id based): 计数器被分割成 N个分片。 根据执行核心的 core-id 选择要更新的分片。 为了高效的访问，分片都做了cacheline对齐。[这里N是活动核心的数量。使用sched_getcpu获得cpu-id] shard-atomic-counter (numa-id based): 计数器被分成 N 个分片。 根据执行核心的 numa-node-id 选择要更新的碎片。 为了高效的访问，分片都做了cacheline对齐。 [这里 N 是活动节点数。 N比较小，在2 / 4 / 8范围内，不是32 / 64 / 128 /等] 值得一提的是Mysql 内部还有另一个计数器结构 ut_lock_free_cnt_t()。 它尝试为各自 NUMA 上的每个计数器(值)分配内存，但是在每个numa_alloc_onnode种，即使是8个字节的小块也会按照系统页面大小的分配( Linux 4KB)。 这是大大的空间浪费。 我尝试过这种方法，但由于超负荷的巨大内存，最终没能成功分配内存。 让我们找出哪种方法在 NUMA 环境中最有效。 Benchmarking使用上面解释的结构和workflow进行基准测试。 每次运行分配好内存后，然后为每个可伸缩性测试运行 K 轮Workflow。 下面的Timing 包括处理数据和计数器的时间，但大部分时间来自计数器争用(通过压制data-block处理已确认)。 x86-vm [x轴: threads(1-256), y轴: time秒. 越低越好] 数据集: 100 个global counter-block, 每个block中10个counter, 1m data-blocks (每个block一个本地counter), 循环10K次 点评 正如预期的那样，带有 cpu-id 的 shard-atomic-counter 性能最好。 值得注意的是，简单的原子操作也是最佳的，并且节省了大量的空间。(没有cacheline对齐)。可能是 VM 影响的 另一个无法解释的行为: fuzzy counter被认为是最快的，但是测试中它不是最快的(我运行了3次同样的benchmark测试证实了这个现象。 在 ARM 上，它表现如预期的那样，因此不像是在基准测试代码出错导致的，需要再分析一下)。 直线非常接近 / 重叠，因此为了确切的表述，共享一下具体数据。 threads p-mutex std-mutex atomic fuzzy shard-rand shard-tid shard-cpuid shard-numaid 128 305.89 312.78 275.21 306.62 273.52 278.14 263.5 352.45 256 608.21 625.37 549.15 611.97 546.04 560.18 521.25 705.17 arm-vm [x轴: threads(1-256), y轴: time秒. 越低越好] 数据集: 100 个global counter-block, 每个block中10个counter, 1m data-blocks (每个block一个本地counter), 循环10K次 点评 同样，shard-atomic-counter (这次使用 thread-id)的得分高于其他方法。 (原因之一可能是在ARM上消耗巨大的sched_getcpu)。 [对于thread-id，线程开始时，在线程本地存储中缓存该线程的唯一标识符] FuzzyCounter正在帮助建立基线(假设没有争用的情况下)。 老旧的 pthread-mutex 似乎也得到了优化 令人感兴趣的是，随着可伸缩性的增加，ARM 似乎显示出较低的争用(可能是由于 NUMA 的互连性更好)。 直线线条非常接近，在某些情况下也会重叠，因此为了更好的表述，数据如下。 threads p-mutex std-mutex atomic fuzzy shard-rand shard-tid shard-cpuid shard-numaid 128 265.05 271.53 272.06 241.26 287.1 258.9 337.2 396.88 256 529.74 546.74 544.07 481.71 574.05 520 671.63 795.92 arm-bms [x轴: threads(1-2048), y轴: time秒. 越低越好] 数据集: 100 个global counter-block, 每个block中10个counter, 1m data-blocks (每个block一个本地counter), 循环1K次 点评 Fuzzy-Counter 帮助设置基线，但是这次我们看到 shard-atomic-counter (带有thread-id)几乎与 Fuzzy-Counter (无争用情况)相当。 似乎这就是预期的最佳数字。 直线非常接近，在某些情况下也会重叠，因此为了更好的表述，参看下列具体数据。 以防你没有注意到测试循环次数已经减少到了1K。 由于跨NUMA访问和增加的可伸缩性，保持循环10K次可能会造成更多的时间消耗，也会有更多的噪音。 (注意: 我们现在裸机有4个 NUMA节点)。 threads p-mutex std-mutex atomic fuzzy shard-rand shard-tid shard-cpuid shard-numaid 128 62.81 63.9 66.24 57.37 64.24 54.09 57.67 72.08 256 115.39 119.53 126.52 102.68 119.01 102.13 106.3 140.83 512 228.2 234.5 252 199.71 241.69 205.66 211.29 279.81 1024 456.53 470.55 503.73 398.61 484.82 412.43 427.52 559.21 2048 913.58 953.56 1007.94 805.35 960.53 817.45 862.94 1132.56 让我们看看fuzzy-counter的近似因子，区别不是很大。 threads global-counter (expected) global-counter (actual) 128 20480000 20479994 256 40960000 40959987 512 81920000 81919969 1024 163840000 163839945 2048 327680000 327679875 总结Benchmark测试证明了，对全局计数器使用 CPU/thread 亲和性的性能最好。 当然，x86和 ARM 有不同的优化点，因此可以相应地调整 MySQL。 Fuzzy counter替换为atomic (或shard-atomic)，可以更好的节省空间和提高精度(在 x86平台上)。 如果你有问题 / 疑问，请联系我。 Managing global counters in a multi-threaded system has always been challenging. They pose serious scalability challenges. Introduction of NUMA just increased the complexity. Fortunately multiple options have been discovered with hardware lending support to help solve/ease some of these issues. In this blog we will go over how we can make Global Counter NUMA SMART and also see what performance impact each of this approach has. Note: a lot of this work is inspired from MySQL codebase that is continuously trying to evolve to solve this issue. Global CountersMost of the software (for example: database, web-server, etc…) needs to maintain some global counters. Being global, there is one copy of these counters and multiple worker threads try to update it. Of-course this invites a need of coordination while updating these copies and in turn it becomes scalability hotspots. Alternative is to loosely maintain these counters (w/o any coordination) but that means they will represent an approximate number (especially on a heavily contended system). But they have their own benefits. Let’s see what all approaches the current ecosystem provides to help solve this problem. SetupIn order to evaluate different approaches we will consider a common setup. Let’s consider some global counters that are at global level so all threads update them once in a while. Let’s consider some data-blocks (where the real workload happens) and as part of this action global counters are updated. Each data-block has its own local counter(s). These local counters are updated whenever data-block is accessed. Both of these blocks are interleaved. Check the arrangement below. Let’s try to understand this structure with some simple numeric examples. Say we have 100 global counter-blocks and each data-block has 10 counters. Say we have 1000 global data-blocks that are equally interleaved with each counter block. That means, 1-counter-block is followed by 10-data-blocks and this combination repeats 100 times. This ensures complete memory blocks are distributed across NUMA nodes and we get to see the effect of NUMA while accessing the counters and data-blocks too. Workload (one-round): Flow will access N data-blocks (at-least enough to invalidate L2 cache). As part of the data-block access, local counter(s) associated with the data-block are also updated. Data blocks are randomly selected using rand() function to ensure spread-across distribution. This is followed with the access and update of global counters from the counter-block. Random counter-block is selected and a random counter from the selected counter block is updated (inc operation). This operation is repeated M times. Workload loop is repeated K times (rounds). Each thread executes the said workload loop (K times). Benchmarking is done with different scalability starting from 1-256/2048. Note: Counter is simply uint64_t value (currently using inc operation only). If you are interested in understanding more about this you can always check out the detailed code here. Hardware usedFor scaling from 1-256 x86-vm: 24 vCPU (12 cores with HT), 48 GB memory, 2 NUMA nodes, Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz (Ubuntu-18.04) arm-vm: 24 vCPU (24 cores), 48 GB memory, 2 NUMA nodes, Kunpeng 920 2.60 GHz (Ubuntu-18.04) For scaling from 1-2048 arm-bms: 128 physical cores, 1 TB of memory, 4 NUMA nodes, Kunpeng 920 2.60 GHz (CentOS-7.8) Idea is not to compare x86 vs ARM but the idea is to compare the effect of NUMA on the global counter. ApprochesAs part of the experiment we evaluated different approaches right from basic to advanced. pthread-mutex based: Simple pthread mutexes that protects operation on counter std::mutex: C++11 enabled std::mutexes just like pthread mutexes but more easier to use with inherent C++11 support. std::atomic: C++11 atomic variable. fuzzy-counter (from mysql): There are N cacheline aligned slots. Flow randomly selects one of the slots to update. To find out the total value of the counter, add value from all the slots. There are no mutexes/atomic that protect the slot operations. This means value is approximate but works best when the flow needs likely count. We will see a variance factor below in result section. [ref: ib_counter_t. N is typically = number of cores]. shard-atomic-counter (from mysql): Counter is split into N shards (like slot above). Each flow tells which shard to update. Shards are cache lines aligned for better access. [ref: Counter::Shard] shard-atomic-counter (thread-id based): Counter is split into N shards (like slot above). Shard to update is selected based on thread-id of executing thread. Shards are cache lines aligned for better access. [here N is number-of-active-cores] shard-atomic-counter (cpu-id based): Counter is split into N shards. Shard to update is selected based on core-id of executing core. Shards are cache lines aligned for better access. [here N is number-of-active-cores. cpu-id obtained using sched_getcpu]. shard-atomic-counter (numa-id based): Counter is split into N shards. Shard to update is selected based on numa-node-id of the executing core. Shards are cache lines aligned for better access. [here N is number-of-active-numa-nodes. N is small here in the range of 2/4/8 not like 32/64/128/etc…] There is another counter structure inside MySQL that is worth mentioning ut_lock_free_cnt_t(). It tries to allocate memory for each counter (value) on respective NUMA but as per the numa_alloc_onnode even a smaller chunk of 8 bytes will cause allocation of system-page size (for Linux 4KB). That is too much space wastage. I tried this approach but eventually failed to allocate memory due to enormous memory over-head. Idea is to find out which approach works best in the NUMA environment. BenchmarkingBenchmarking is done using the structure and workload explained above. Each run allocates memory and then K rounds of workload loop per scalability. Timing below includes time to process data and counter but majority of it is coming from counter contention (confirmed by supressing data-block processing). x86-vm [x-axis: threads(1-256), y-axis: time in seconds. Lesser is best] Data-set: 100 global counter blocks, 10 counters per block, 1m data-blocks (with a local counter per block), 10K rounds Comments As expected, shard-atomic-counter with cpu-id performs best. (cpu-id = sched_getcpu). Suprisingly, simple atomic is optimal too with significant space saved. (No cacheline alignment). May be VM effect. Another unexplained behavior: fuzzy counter which is expected to be fastest is not showing up to be fastest (I re-confirmed this behavior with 3 different runs. On ARM, it performing as expected so less likely something going wrong in the benchmarking code. More analysis to be done). Lines are pretty close/overlapping, so sharing the numeric numbers for higher-sclalability. threads p-mutex std-mutex atomic fuzzy shard-rand shard-tid shard-cpuid shard-numaid 128 305.89 312.78 275.21 306.62 273.52 278.14 263.5 352.45 256 608.21 625.37 549.15 611.97 546.04 560.18 521.25 705.17 arm-vm [x-axis: threads(1-256), y-axis: time in seconds. Lesser is best] Data-set: 100 global counter blocks, 10 counters per block, 1m data-blocks (with a local counter per block), 10K rounds Comments Again, shard-atomic-counter (this time with thread-id) scored better than other alternatives. (one of the reason could be sched_getcpu is costly on ARM). [For thread-id, flow cached thread unique identifier during creation, in thread-local storage]. FuzzyCounter is helping establish baseline (given there is no-contention). Good old pthread-mutex seems to be optimized too. Intererstingly, ARM seems to be showing lower contention with increase scalability (may be due to better NUMA interconnect). Lines are pretty close and in some cases overlapping too, so sharing the numeric numbers for higher-sclalability. threads p-mutex std-mutex atomic fuzzy shard-rand shard-tid shard-cpuid shard-numaid 128 265.05 271.53 272.06 241.26 287.1 258.9 337.2 396.88 256 529.74 546.74 544.07 481.71 574.05 520 671.63 795.92 arm-bms [x-axis: threads(1-2048), y-axis: time in seconds. Lesser is best] Data-set: 100 global counter blocks, 10 counters per block, 1m data-blocks (with a local counter per block), 1K rounds Comments Fuzzy-Counter help set the baseline but this time we see shard-atomic-counter (with thread-id) is almost on-par with Fuzzy-Counter (non-contention use-case). That is like optimal number to expect. Lines are pretty close and in some cases overlapping too, so sharing the numeric numbers for higher-sclalability. Just incase you have not noticed the rounds has been reduced by 1K. Keeping it 10K increases timing like anything due to cross-numa access and increased scalability. (note: we are now on operating machine with 4 numa nodes). threads p-mutex std-mutex atomic fuzzy shard-rand shard-tid shard-cpuid shard-numaid 128 62.81 63.9 66.24 57.37 64.24 54.09 57.67 72.08 256 115.39 119.53 126.52 102.68 119.01 102.13 106.3 140.83 512 228.2 234.5 252 199.71 241.69 205.66 211.29 279.81 1024 456.53 470.55 503.73 398.61 484.82 412.43 427.52 559.21 2048 913.58 953.56 1007.94 805.35 960.53 817.45 862.94 1132.56 Let’s see approximation factor for fuzzy-counter. Not that major difference. threads global-counter (expected) global-counter (actual) 128 20480000 20479994 256 40960000 40959987 512 81920000 81919969 1024 163840000 163839945 2048 327680000 327679875 ConclusionBenchmark study has proved that using CPU/thread affinity for global counters works best. Of-course x86 and ARM has different optimization point so MySQL could be tuned accordingly. Fuzzy counter could be better replaced with atomic (or shard-atomic) given space saved and improved accurancy (on x86). If you have more questions/queries do let me know. Will try to answer them. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/05/28/numa-zhi-neng-quan-ju-ji-shu-qi-lai-zi-mysql-de-ling-gan/"},{"title":"PostgreSQL ARM和X86性能比拼","text":"译者: bzhaoopenstack作者: Amit Dattatray Khandekar原文链接: https://amitdkhan-pg.blogspot.com/2020/05/postgresql-on-arm.html 由团队内部PostgreSQL大牛Amit在ARM和X86上针对PostgreSQL的性能比拼测试。 中文 English PostgreSQL on ARM在我的上个博客, 我写道，如果那些已经运行在X86的应用程序要在不同的架构上运行，比如 ARM，那么这些应用程序可能需要进行一些优化。 让我们来看看它具体指的是什么。 最近我一直在使用 ARM64机器测试 PostgreSQL RDBMS。几个月前，我甚至不知道它是否可以在 ARM 上编译，因为忽略了一个事实，即我们有一个用于 ARM64的常规构建机器，已经很长时间了. 现在甚至连 PostgreSQL apt 库也开始制作ARM64 PostgreSQL 的包了。但是在我用不同的场景测试了 PostgreSQL-on-ARM 之后，我才真正对它的可靠性有了信心。 我从read-only pgbench 测试开始，比较了 x86_64和 ARM_64虚机的测试结果。 目的不是比较任何特定的 CPU 实现。 这个想法是为了找出ARM 上的 PostgreSQL 与X86相比表现不尽如人意的场景。 Test Configuration ARM64 VM: Ubuntu 18.04.3; 8 CPUs; CPU frequency: 2.6 GHz; available RAM : 11GBx86_64 VM: Ubuntu 18.04.3; 8 CPUs; CPU frequency: 3.0 GHz; available RAM : 11GB 以下是所有测试的共用的配置: PostgreSQL parameters changed : shared_buffers = 8GBpgbench scale factor : 30pgbench command :for num in 2 4 6 8 10 12 14do pgbench [-S] -c $num -j $num -M prepared -T 40done它的意思是: pgbench 运行的并行client数量越来越多，从2个到14个不等。 Select-only workload pgbench -S 选项应用在 read-only workload. 在2个线程和4个线程之间，x86的性能比 ARM 高出30% ，而且差距越来越大。 当线程数在4到6之间，曲线变得平坦了一点，再到线程数6到8之间，曲线突然变得陡峭。 然后线程数到达8之后，由于测试机上有8个 cpu，预计它会变平或下降。 但是还有更多的原因。 这里Pgbench client运行在与安装 PostgreSQL server相同的一台机器上。 通过充分利用 cpu，Pgbench client 占用了大约20% 的 cpu。 所以client从6个线程开始对测试产生干扰。 尽管如此，ARM 和 x86的性能差距还是在线程数6到8之间急剧上涨。 我还没有理解为什么会这样，可能与 Linux 调度程序以及 pgbench client和PostgreSQL server之间的交互有关。 注意，x86和 ARM 的曲线形状基本相似。 所以这种行为并不是架构特有的。 不过，这些曲线的一个不同之处在于: ARM 曲线从8个线程开始下降幅度稍大一些。 此外，线程数在6到8之间时，ARM 的处理事务量的增长并不像 x86那样剧烈。 因此，这种情况的最终结果是: 随着 cpu 变得越来越忙，ARM 上的 PostgreSQL 越来越落后于 x86。 让我们看看如果移除 pgbench client带来的干扰会发生什么。 select exec_query_in_loop(n) 因此，为了避免由于同一台机器上的pgbench client对PostgreSQL server造成的干扰，我想测试一下它的查询性能。为此，pgbench client运行在另一台机器上，但这可能会产生另一种的噪音: 网络延迟。 所以，我写了一个 PostgreSQL C language user-defined function ，用来循环执行与 pgbench 测试运行的完全相同的 SQL 查询。 使用 pgbench 自定义脚本执行此函数。现在，pgbench client大部分都是空闲的。 另外，这不会占用提交 / 回滚程度时间，因为大部分时间将花费在这个C 函数上。 pgbench 自定义脚本 : select exec_query_in_loop(n);其中 n 是 pgbench 查询在PostgreSQL server上一次循环执行的次数与pgbench -S选项作用下的普通循环查询：SELECT abalance FROM pgbench_accounts WHERE aid = $1详情参看 exec_query_in_loop() 现在，你看到一个非常不同的曲线。 对于这两条曲线，最多为8个线程，事务率与线程数成线性比例。 正如预期的那样，在线程数达到8以后，处理的事务就不会上升了。 而且，即使对 ARM 来说，它也有相同的行为。 与 x86相比，PostgreSQL 在 ARM上从头到尾慢了35% 左右。 考虑到 ARM 处理器的频率是2.6 GHz，而 x86是3.0 GHz，这么一说看起来这性能还不错。 注意，事务率是个位数，因为函数 exec_query_in_loop(n)中是用 n=100000来执行的。 这个实验还表明，之前使用内置 pgbench 脚本的性能测试结果与 pgbench client干扰有关。 而且，ARM 对于竞争线程的倾斜曲线不是由服务器中的争用引起的。 请注意，事务率是在客户端计算的。 因此，特别是在高争用场景中, 即使查询中的结果已经准备就绪，然而client请求结果、计算时间戳等仍然可能会有一些延迟。 select exec_query_in_loop(n) - PL/pgSQL function 在使用用户定义的 c 函数之前，我使用了 PL/pgSQL function来做同样的事. 我偶然发现了一种不同的表现行为。 在这里，无论线程数量如何，ARM 上的 PostgreSQL 都比 x86慢65% 左右。 与之前使用 C 函数的结果相比，由于某种原因，很明显 PL/pgsql 在 ARM 上的执行速度非常慢。 我检查了 perf 输出的报告，在 ARM 和 x86中看到的热点函数大致相同。 但由于某些原因，在 PL/pgsql 函数内执行的任何操作在 ARM 上都比在 x86上慢得多。 我还没有检查缓存失败，看看缓存失败是否在 ARM 上会更多。 在撰写本文时，我所做的是这样的(在PostgreSQL内部是这样的) : exec_stmt_foreach_a()调用exec_stmt()。 我将 exec_stmt()克隆为 exec_stmt_clone() ，并将 exec_stmt_foreach_a()调用 exec_stmt_clone()。 这加快了整体执行的速度，对于 ARM 来说却加快了20%多 。 到目前为止，这种变化为什么会导致这种行为，对我来说还是一个谜。 可能与程序中某个代码位置有关，这点我还不确定。 Updates 默认 pgbench 选项运行与 tpcb类似的内置脚本，该脚本对多个表进行了一些更新操作。 与 x86相比，ARM 上的事务处理率大约比X86慢1%-10% 。 这可能是因为大部分时间用于等待锁，而在提交过程中的磁盘写操作。 我使用的磁盘是非 SSD 磁盘。 但总体来看，PostgreSQL在 ARM 上的更新表操作在 ARM 上运行良好。 接下来，我将测试聚合查询、分页、更多CPU核数 (32 / 64 / 128)、更大的 RAM 和更高的规模因数，以便相对地了解 PostgreSQL 在拥有大量资源的两个平台上的性能扩展情况。 结论 我们看到，PostgreSQL RDBMS 在 ARM64上工作得相当稳定。 虽然在比较两个不同平台上的性能很棘手，但是我们仍然可以通过比较两个平台中不同场景中的行为来判断它哪些方面做得不好。 PostgreSQL on ARMIn my last blog, I wrote that applications that have been running on x86 might need to undergo some adaptation if they are to be run on a different architecture such as ARM. Let’s see what it means exactly. Recently I have been playing around with PostgreSQL RDBMS using an ARM64 machine. A few months back, I even didn’t know whether it can be compiled on ARM, being oblivious of the fact that we already have a regular build farm member for ARM64 for quite a while. And now even the PostgreSQL apt repository has started making PostgreSQL packages available for ARM64 architecture. But the real confidence on the reliability of PostgreSQL-on-ARM came after I tested it with different kinds of scenarios. I started with read-only pgbench tests and compared the results on the x86_64 and the ARM64 VMs available to me. The aim was not to compare any specific CPU implementation. The idea was to find out scenarios where PostgreSQL on ARM does not perform in one scenario as good as it performs in other scenarios, when compared to x86. Test Configuration ARM64 VM: Ubuntu 18.04.3; 8 CPUs; CPU frequency: 2.6 GHz; available RAM : 11GBx86_64 VM: Ubuntu 18.04.3; 8 CPUs; CPU frequency: 3.0 GHz; available RAM : 11GB Following was common for all tests : PostgreSQL parameters changed : shared_buffers = 8GBpgbench scale factor : 30pgbench command :for num in 2 4 6 8 10 12 14do pgbench [-S] -c $num -j $num -M prepared -T 40doneWhat it means is : pgbench is run with increasing number of parallel clients, starting from 2 to 14. Select-only workload pgbench -S option is used for read-only workload. Between 2 and 4 threads, the x86 performance is 30% more than ARM, and the difference rises more and more. Between 4 and 6, the curves flatten a bit, and between 6 and 8, the curves suddenly become steep. After 8, it was expected to flatten out or dip, because the machines had 8 CPUs. But there is more to it. The pgbench clients were running on the same machines where servers were installed. And with fully utilized CPUs, the clients took around 20% of the CPUs. So they start to interfere from 6 threads onward. In spite of that, there is a steep rise between 6 and 8, for both ARM and x86. This is not yet understood by me, but possibly it has something to do with the Linux scheduler, and the interaction between the pgbench clients and the servers. Note that, the curve shape is mostly similar on both x86 and ARM. So this behaviour is not specific to architectures. One difference in the curves, though, is : the ARM curve has a bit bigger dip from 8 threads onward. Also, betweeen 6 and 8, the sudden jump in transactions is not that steep for ARM compared to x86. So the end result in this scenario is : As the CPUs become more and more busy, PostgreSQL on ARM lags behind x86 more and more. Let’s see what happens if we remove the interference created by pgbench clients. select exec_query_in_loop(n) So, to get rid of the noise occurring because of both client and server on the same machines, I arranged for testing exactly what I intended to test: query performance. For this, pgbench clients can run on different machines, but that might create a different noise: network latency. So instead, I wrote a PostgreSQL C language user-defined function that keeps on executing in a loop the same exact SQL query that is run by this pgbench test. Execute this function using the pgbench custom script. Now, pgbench clients would be mostly idle. Also, this won’t take into account the commit/rollback time, because most of the time will be spent inside the C function. pgbench custom script : select exec_query_in_loop(n);where n is the number of times the pgbench query will be executed on the server in a loop.The loop query is the query that gets normally executed with pgbench -S option:SELECT abalance FROM pgbench_accounts WHERE aid = $1Check details in exec_query_in_loop() Now, you see a very different curve. For both curves, upto 8 threads, transactions rate is linearly proportional to number of threads. After 8, as expected, the transactions rate doesn’t rise. And it has not dipped, even for ARM. PostgreSQL is consistently around 35% slower on x86 compared to ARM. This sounds not that bad when we consider that the ARM CPU frequency is 2.6 GHz whereas x86 is 3.0 Gz. Note that the transaction rate is single digit, because the function exec_query_in_loop(n) is executed with n=100000. This experiment also shows that the previous results using built-in pgbench script have to do with pgbench client interference. And that, the dip in curve for ARM for contended threads is not caused by the contention in the server. Note that, the transactions rates are calculated at client side. So even when a query is ready for the results, there may be some delay in the client requesting the results , calculating the timestamp, etc, especially in high contention scenarios. select exec_query_in_loop(n) - PLpgSQL function Before using the user-defined C function, I had earlier used a PL/pgSQL function to do the same work. There, I stumbled across a different kind of performance behaviour. Here, PostgreSQL on ARM is around 65% slower than on x86, regardless of number of threads. Comparing with the previous results that used a C function, it is clear that PL/pgSQL execution is remarkably slower on ARM, for some reason. I checked the perf report, but more or less the same hotspot functions are seen in both ARM and x86. But for some reason, anything executed inside PL/pgSQL function becomes much slower on ARM than on x86. I am yet to check the cache misses to see if those are more on ARM. As of this writing, what I did was this (some PostgreSQL-internals here) : exec_stmt_foreach_a() calls exec_stmt(). I cloned exec_stmt() to exec_stmt_clone(), and made exec_stmt_foreach_a() call exec_stmt_clone() instead. This sped up the overall execution, but it sped up 20% more for ARM. Why just this change caused this behaviour is kind of a mystery to me as of now. May be it has to do with the location of a function in the program; not sure. Updates The default pgbench option runs the tpcb-like built-in script, which has some updates on multiple tables. Here, the transaction rate is only around 1-10% percent less on ARM compared to x86. This is probably because major portion of the time goes in waiting for locks, and in disk writes during commits. And the disks I used are non-SSD disks. But overall it looks like, updates on PostgreSQL are working good on ARM. Next thing, I am going to test with aggregate queries, partitions, high number of CPUs (32/64/128), larger RAM and higher scale factor, to relatively see how PostgreSQL scales on the two platforms with large resources. Conclusion We saw that PostgreSQL RDBMS works quite robustly on ARM64. While it is tricky to compare the performance on two different platforms, we could still identify which areas it is not doing good by comparing patterns of behaviour in different scenarios in the two platforms. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/05/22/postgresql-arm-he-x86-xing-neng-bi-pin/"},{"title":"PostgreSQL对外部压缩方法的诉求","text":"译者: bzhaoopenstack作者: Amit Dattatray Khandekar原文链接: https://amitdkhan-pg.blogspot.com/2020/08/need-for-external-compression-methods.html Amit PSQL专家分析压缩库在PostgreSQL中的迫切诉求。 中文 English 现今的每个数据库系统都有一定程度的数据压缩方法。很明显，这是为了减少数据库的大小，特别是在当今数据呈指数增长的时代。另外的原因是为了提高查询性能; 其思想是: 更小的数据大小意味着需要扫描的数据页面更少，这意味着更少的磁盘 i/o 和更快的数据访问。因此，无论如何，数据解压缩的速度应该足够快，以免影响查询性能(如果不能提高的话)。 压缩提供了不同的层次: 页面压缩、行压缩、列压缩等。柱型数据库的优点是它的列压缩比很高，因为在一个列中存在连续数据的重复区域。另一种情况是，在面向行的数据库中，列值非常大，因此有必要压缩列的单个值。如果这些值不适合放在单个页面中，甚至可以单独保留它们，并且该行具有指向行外压缩数据的指针。在 PostgreSQL 中，这种技术被称为 TOAST (超大型属性存储技术) ，对于可以包含可变长度数据的列，数据被明显地压缩并存储在同一行中，或者如果数据仍然太大，则将数据以较小的块形式单独的存储在称为 TOAST table表的行中，这些块本身可能被压缩，也可能不被压缩。 压缩为不同的数据操作提供了可能性。它可能不会被限制只有几秒数据压缩。例如，在容灾系统中，把redo logs从主服务器到从服务器的传输可能成为一个巨大的网络瓶颈，因此许多 RDBMS 提供压缩redo logs的功能。 然后是 RDBMS 使用或提供选项可选的压缩算法。这一点尤其适用于数据压缩。由于数据是用户的数据，用户数据中的特定格式可能适合特定的压缩算法，而不同的存储格式可能适合另一种压缩算法。此外，这意味着，如果 RDBMS 提供一个选项，为特定列选择特定的压缩算法，或者从众所周知的标准压缩库列表(如 zlib、 lz4、 zstd、 snappy、 gzip 等)中选择特定的用户定义类型，那么这种方法将更加有益。或者，库算法都可以是完全定制的。 并且提供了与 CPU 内核紧密耦合的压缩、加密和 SIMD 硬件加速器，这些硬件加速器可以通过压缩或加密算法加以利用。其中一个例子是Kunpeng Zlib Acceleration Engine, 它提供了一个支持硬件的基础设施，用于在“ Kunpeng 920” ARM64处理器上进行压缩。我还没有机会测试这种能力，但它听起来很有希望。 此外，压缩/加密算法在数据上执行重复的任务，这是利用 SIMD 向量化的自然选择。已经有一些独立的项目在 ARM64和 Intel 上进行，以便在 zlib、 lz4等著名的压缩库中进行这种特定于平台的增强。参看NEON Intrinsics case study 关于优化 zlib 的 adler-32算法的 NEON intrinsic 案例研究。 所有这些都直接表明，RDBMS 服务器迫切需要为用户提供针对特定表或特定列的本地压缩算法/库的选择。在写这篇文章的时候，PostgreSQL 使用基于 LZ它自己的内建压缩算法 来压缩Toast 表。想象一下，如果有一个用于选择 zlib 的接口，而不是内置的算法。进一步，选择 zlib 压缩级别。更进一步，为用户添加一个界面来创建一个扩展，该扩展使用特定平台的自定义算法，该平台使用硬件加速。 OK，我们正在实现一个这样的特性。在 PostgreSQL 黑客社区中查看这个 讨论主题。这个特性可能还有很长的路要走(截至本文撰写之时) ，但是我对这个特性充满希望，因为如上所示，用例足够强大，对这个功能没有反对意见，并且提交了work-in-progress的补丁。 我查看了这个补丁，玩了一下。粗略地说，下面是操作界面的样子。在补丁集完全具体化之后，接口可能会有所不同，但我认为它的本质或多或少会保持不变。下面是我的测试结果; 请注意，这只是为了通过例子强调这个功能是多么的酷和有用，并且使我在这个博客中解释的任何东西都有意义。 CREATE TABLE zlibtab(t TEXT COMPRESSION zlib WITH (level ‘4’));CREATE TABLE lztab(t TEXT);ALTER TABLE lztab ALTER COLUMN t SET COMPRESSION pglz; pgg:s2:pg$ time psql -c “\\copy zlibtab from text.data”COPY 13050 real 0m1.344suser 0m0.031ssys 0m0.026s pgg:s2:pg$ time psql -c “\\copy lztab from text.data”COPY 13050 real 0m2.088suser 0m0.008ssys 0m0.050s pgg:s2:pg$ time psql -c “select pg_table_size(‘zlibtab’::regclass), pg_table_size(‘lztab’::regclass)” pg_table_size | pg_table_size—————+————— 1261568 | 1687552 pgg:s2:pg$ time psql -c “select NULL from zlibtab where t like ‘0000’” &gt; /dev/null real 0m0.127suser 0m0.000ssys 0m0.002s pgg:s2:pg$ time psql -c “select NULL from lztab where t like ‘0000’” &gt; /dev/null real 0m0.050suser 0m0.002ssys 0m0.000s 注意两种不同的压缩算法在压缩大小、插入数据(压缩)和选择数据(解压)的速度上是如何不同的。 你甚至可以创建一个新的压缩访问函数，就像我们创建一个新的索引一样: CREATE ACCESS METHOD pglz1 TYPE COMPRESSION HANDLER my_compression_handler;其中my_compression_handler 应该是一个 PostgreSQL C 函数，可以使用 PostgreSQL 扩展创建。这个函数为一组预定义的钩子分配它自己的实现函数，这些钩子定义了 PostgreSQL 核心使用压缩访问方法所需要知道的一切: Datummy_compression_handler(PG_FUNCTION_ARGS){ CompressionAmRoutine *routine = makeNode(CompressionAmRoutine); ​ routine-&gt;cmcheck = my_cmcheck;​ routine-&gt;cminitstate = my_cminitstate;​ routine-&gt;cmcompress = my_cmcompress;​ routine-&gt;cmdecompress = my_cmdecompress;​ routine-&gt;cmdecompress_slice = NULL; ​ PG_RETURN_POINTER(routine);} 这是 PostgreSQL 高度可扩展的方式: 允许用户使用内置方法，但也为用户提供了一种方法来定义他/她自己的方法来完成相同的工作。上面的所有函数都在一个 PostgreSQL 扩展中，可以使用:CREATE EXTENSION my_compression; Every modern database system has some way to compress its data at some level. The obvious reason for this feature is to reduce the size of it’s database, especially in today’s world where the data is growing exponentially. The less obvious reason is to improve query performance; the idea is: smaller data size means less data pages to scan, which means lesser disk i/o and faster data access. So, in any case, data de-compression should be fast enough so as not to hamper the query performance, if not improve it. Compression is offered at different levels : page compression, row compression, column compression, etc. Columnar databases have the advantage of a very high compression ratio of its column because of presence of a repetetive pattern of contiguous data in a column. Another case is when, in a row oriented database, the column values are so large that it makes sense to compress individual values of the column. Such values can even be kept separately if they do not fit in a single page. And the row has pointers to the out-of-line compressed data. In PostgreSQL, such technique is called TOAST (The Oversized-Attribute Storage Technique), where, for columns that can contain variable-length data, the data is transparently compressed and stored in the same row, or else if it is still too large, it is stored in smaller chunks as rows in a separate table called a toast table, where these chunks themselves may or may not be compressed. Compression is offered for different purposes. It may not be restricted for only data compression. E.g. in a replication system, the transfer of redo logs from the master to slave can become a huge network bottleneck, so many RDBMS offer to compress redo logs. And then comes the compression algorithms that the RDBMS uses or gives options to choose. This applies especially more to data compression. Since data is user’s data, a specific pattern in the user data might suit a particular compression algorithm, while a different pattern might be suitable for another compression algorithm. Moreover, this implies that it would be far more beneficial if the RDBMS gives an option to choose a specific compression algorithm for a specific column or a specific user-defined type out of a list of well-known standard compression libraries such as zlib, lz4, ztd, snappy, gzip, etc. Or, the library algorithm may very well be a completely customized one. Secondly, there has been a lot of advancements to optimize compression algorithms for specific platforms, and provide hardware accelerators for Compression, Encryption and SIMD that are closely coupled to CPU cores, which can then be levergaed by compression or encryption algorithms. One such example is the Kunpeng Zlib Acceleration Engine, which offers a hardware-enabled infrastructure for compression on a “Kunpeng 920” ARM64 processor. I haven’t got a chance to test this capability, but it does sound promising. Furthermore, the compression/encryption algorithms inherently do repetitive tasks over the data, which is a natural fit for leveraging SIMD vectorization. There has been independent projects going on on both ARM64 and Intel to do such platform-specific enhancements in well known libraries like zlib, lz4 etc. Check out this NEON Intrinsics case study that optimizes zlib’s adler-32 algorithm using NEON intrinsics. All this directly points to an urgent need for RDBMS servers to give users a choice for specific native compression algorithms/libraries for specific tables or specific columns. As of this writing, PostgreSQL uses its own built-in compression algorithm based on LZ for toast table compression. Imagine if there were an interface to select zlib instead of the built-in algorithm. Further, select the zlib compression level. Still further, add an interface for users to create an extension that uses a customized algorithm native to a specific platform that uses hardware acceleration. Well, there is exactly such a proposed feature in the making. Check out this discussion thread in the PostgreSQL hackers community. It may be a long way to go (as of this writing), but I am very hopeful of this feature going in, because the use-cases are strong enough as shown above, there are no fundamental objections to this functionality, and there are work-in-progress patches submitted. I went ahead and applied this patch, and played around it. Roughly, below is how the interface looks like. After the patch-set fully materializes, the interface might be different, but I think the essence of it would remain more or less the same. Below is the output of my tests; please note that it is just to emphasize with examples how cool and useful this feature would be, and to make sense of whatever I explained above in this blog. CREATE TABLE zlibtab(t TEXT COMPRESSION zlib WITH (level ‘4’));CREATE TABLE lztab(t TEXT);ALTER TABLE lztab ALTER COLUMN t SET COMPRESSION pglz; pgg:s2:pg$ time psql -c “\\copy zlibtab from text.data”COPY 13050 real 0m1.344suser 0m0.031ssys 0m0.026s pgg:s2:pg$ time psql -c “\\copy lztab from text.data”COPY 13050 real 0m2.088suser 0m0.008ssys 0m0.050s pgg:s2:pg$ time psql -c “select pg_table_size(‘zlibtab’::regclass), pg_table_size(‘lztab’::regclass)” pg_table_size | pg_table_size—————+————— 1261568 | 1687552 pgg:s2:pg$ time psql -c “select NULL from zlibtab where t like ‘0000’” &gt; /dev/null real 0m0.127suser 0m0.000ssys 0m0.002s pgg:s2:pg$ time psql -c “select NULL from lztab where t like ‘0000’” &gt; /dev/null real 0m0.050suser 0m0.002ssys 0m0.000s Notice how two different compression algorithms differ in the compressed size, and the speed of inserting data (compression) and selecting data (decompression). You would even be able to create a new compression access method using the same way as we do for creating a new index :CREATE ACCESS METHOD pglz1 TYPE COMPRESSION HANDLER my_compression_handler;where my_compression_handler should be a PostgreSQL C function that could be created using a PostgreSQL extension. This function assigns its own implementation functions for a set of pre-defined hooks that define everything that the PostgreSQL core needs to know to make use of the compression access method : Datummy_compression_handler(PG_FUNCTION_ARGS){ CompressionAmRoutine *routine = makeNode(CompressionAmRoutine); ​ routine-&gt;cmcheck = my_cmcheck;​ routine-&gt;cminitstate = my_cminitstate;​ routine-&gt;cmcompress = my_cmcompress;​ routine-&gt;cmdecompress = my_cmdecompress;​ routine-&gt;cmdecompress_slice = NULL; ​ PG_RETURN_POINTER(routine);} This is PostgreSQL’s way of being highly extensible : Allow user to use built-in methods, but also provide a way for the user to define his/her own methods for doing the same job. All the above functions would be inside an PostgreSQL extension, that could be created using:CREATE EXTENSION my_compression; .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/08/31/postgresql-dui-wai-bu-ya-suo-fang-fa-de-su-qiu/"},{"title":"Running MySQL on ARM. Does it work?","text":"作者: Krunal Bauskar 原文链接: https://mysqlonarm.github.io/Running-MySQL-on-ARM/ I am sure most of you may have this question. In fact, I too had it before I started working on #mysqlonarm initiative. What does it take to run MySQL on ARM? Does it really work? What about dependencies? What kind of performance does it have? What about support? Is there enough community support? This could go on….. Let’s try to answer these questions in simple question answer format. Q: Is MySQL supported on ARM?A: Yes, MySQL is officially supported on ARM. There are packages available that you can download from mysql.com site. Q: Which OS are supported?A: Currently support is enabled for RHEL-7 &amp; 8/Oracle-Linux- 7 &amp; 8. I don’t see direct package support for other OS. Q: Can we build it from source code for other OS (like say Ubuntu)?A: Yes. It works. I have been using binaries built from source code (using mysql-8.0.19 tag current release tag) on Ubuntu-18.04 (Bionic Beaver). (Also, build it on CentOS if you want to go the source code way). This also means all needed dependencies are taken care off or are already available. Q: Are supporting tools available on ARM?A: Since packages are available and I was able to build it from source too the default utilities like mysql shell/mysqladmin/mysqlslap/mysqldump/etc… and tons of other things that default ships along with binaries are available. If you care about a specific tools do let me know I will check them out. For now I have tried percona-toolkit some selective tools and they too work. Q: Does MariaDB and Percona too support their respective server flavor on ARM?A: MariaDB Community Server packages (from MariaDB corporation) are available for ARM (CentOS7/Ubuntu-16.04/18.04). Tools for MariaDB server are not yet officially available on ARM.Percona doesn’t yet officially support ARM but I was able to build it from source (MyRocks/TokuDB are not available). Q: Non-availability of tools. Can that block my progress of trying MySQL (or its variants) on ARM?A: No. Since most of these tools talk mysql protocol you can of-course install them on x86 with server running on ARM. (if tool is not yet ported to ARM) Q: Is there enough community support?A: MySQL on ARM is there for quite some time. There are active contributions from multiple vendors including ARM, Qualcomm, Huawei etc… and the community is growing rapidly. There is a lot of interest from all sections on optimizing MySQL on ARM. Lot of developers wanted to connect with this initiative. There are few challenges, most importantly non-availability of the hardware. If you are interested in contributing please talk to me (shoot me an email). Q: All that looks good. What about performance?A: This is a wide topic so I will be publishing multiple posts on this topic in the coming days but to put it in short performance is comparable. On other hand ARM instances should provide better price performance. Q: What about Support?Since packages are available officially from MySQL I presume their service offering should also cover ARM. Same with MariaDB. And of-course beyond official support there are common groups and independent developers. Command to build MySQL on ARM12cmake .. -DWITH_NUMA=1 -DDOWNLOAD_BOOST=1 -DWITH_BOOST=&lt;boost-dir&gt; -DCMAKE_INSTALL_PREFIX=&lt;dir-to-install&gt;make -j &lt;num-of-cores&gt; So no special flag is needed to build MySQL on ARM. (Assumes you have installed standard dependencies). It defaults compiles with “CMAKE_BUILD_TYPE=RelWithDebInfo” ConclusionMySQL on ARM is reality and it is now officially supported with ever growing eco-system/community. So give it a try. It could be your next cost-saving options without comprising performance or functionality. If you have more questions/queries do let me know. Will try to answer them","link":"/2020/03/31/running-mysql-on-arm-does-it-work/"},{"title":"Understanding InnoDB rw-lock stats","text":"作者: Krunal Bauskar InnoDB uses mutexes for exclusive access and rw-locks for the shared access of the resources. rw-locks are used to control access to the common shared resources like buffer pool pages, tablespaces, adaptive search systems, data-dictionary, informaton_schema, etc… In short, rw-locks play a very important role in the InnoDB system and so tracking and monitoring them is important too. InnoDB provides an easy way to track them using “SHOW ENGINE INNODB STATUS”. 1234RW-shared spins 38667, rounds 54868, OS waits 16539RW-excl spins 6353, rounds 126218, OS waits 3936RW-sx spins 1896, rounds 43888, OS waits 966Spin rounds per wait: 1.42 RW-shared, 19.87 RW-excl, 23.15 RW-sx In this article we will try to understand how these stats are calculated and what is the significance of each of these numbers. We will also try to draw inferences using different use-cases and touch base important stats bug that makes the current state of the stats almost ineffective for tuning. rw-lock spin algorithmThere are 3 types of rw-locks: Shared: offers shared access to the resource. Multiple shared locks are allowed. Exclusive: offers exclusive access to the resource. Shared locks wait for exclusive locks. Shared-Exclusive (SX): offer write access to the resource with inconsistent read. (relaxed exclusive). We will first try to understand the flow and then discuss some tuning steps. (For sake of discussion, to start with, let’s assume spins=0, rounds=0, os-waits=0). Locking Steps Step-1: Try to obtain the needed lock If SUCCESS then return immediately. (spins=0, rounds=0, os-waits=0) If FAILURE then enter spin-loop. Step-2: Start Spin-loop. Increment spin-count. (Why is spin-loop needed? If we enter wait then the OS will take away CPU from the given thread and then the thread will have to wait for its turns as per OS-scheduling. Better approach is to busy-wait using spin-loop (with condition check) so that the CPU is kept. Since most of these locks are short-duration likely chance of re-obtaining it very high). Step-3: Start spinning for N rounds. (Here N is defined and controlled by innodb_sync_spin_loops). Default is 30 rounds. Step-3a: Each round will invoke a PAUSE logic (see a separate section below about PAUSE logic) that will cause the CPU to go to PAUSE for X cycles. Step-3b: Post each round a soft check is done if the said lock is available (busy-wait). If it is available then spin-cycle exits. (There could still be some rounds pending. We will use this info below). Step-3c: Again try to obtain the needed lock. If SUCCESS then return. (spins=1, rounds=M (M &lt;= N), os-waits=0) If FAILURE and there are some pending rounds (max=innodb_sync_spin_loops) then resume spinning. (How come the loop was interrupted and locking failed. Note: the said lock is being looked upon by multiple threads in parallel. While multiple threads got signals about lock availability by the time said thread tried to obtain the lock, some other thread took it. So the said thread is now back re-trying). Step-3d: Say a thread now completes its set rounds of spin-wait and even now it failed to obtain the lock. There is no point in spinning further and wasting CPU cycles. Better give up pending CPU cycles back to OS and let OS scheduling do the needful. Also, since the said thread is now going to go to sleep it should register itself with some common infrastructure that will help signal it back to active whenever the said lock is available. Step-3e: This infrastructure to signal it back to active is sync-array infrastructure in InnoDB. Said thread registers itself by reserving a slot in the said array. Before starting the wait, give another try to see if the lock is available. (since reserving could be time consuming and lock could be available in meantime). If still lock is not available then wait for sync-array infrastructure to signal back the said thread. This wait is called OS-wait and entering this loop will now cause OS-waits count to increase. Step-3f: Say the said thread is signaled by sync-array infrastructure for the wait-event. It retries to obtain the needed lock. If SUCCESS then return. (spins=1, rounds=N, os-waits=1) If FAILURE then the whole loop restarts from spinning logic (Back to Step-3 with rounds-count re-intialize to 0). Note: spins count is not re-incremented. So let’s now assign the meaning to these counts spins: represent how many times flow failed to get a lock in first go and had to enter spin-loop. rounds: represent how many rounds of PAUSE logic executed. os-waits: how many times spin-loop failed to grant a lock that resulted in os-waits. It is possible that during a given spin loop for acquiring said lock flow may need more than 30 (innodb_sync_spin_loops) rounds of PAUSE logic and have to multiple time enter os-waits. This can cause os-waits &gt; spins-count. PAUSE logicK = {random value from between (0 - innodb_spin_wait_delay) * innodb_spin_wait_pause_multiplier} Invoke low-level PAUSE instruction K times. Not all architectures provide low-level pause instruction. x86 does provide it but ARM doesn’t. Even with x86 latency of this pause instruction continues to change with different families of processors. It was around 10-15 cycles for old generation processors (pre-skylake). Went upto 140 cycles with Skylake and again came down with CascadeLake (I see 13 cycles with Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz which belongs to CascadeLake family). (I have not personally benchmarked it on all platforms (except Cascadelake) but this is based on the references. This means the delay (in terms of cycle) introduced by PAUSE continues to change and so tuning PAUSE logic for each generation/type of processor is important. 2 configurable variables viz. innodb_spin_wait_delay, innodb_spin_wait_pause_multiplier exactly help achieve this. Interpreting statsNow that we understand the stats let’s look at the number and try to draw some inferences. But before we get into further details let me point out a bug that makes these stats inconsistent and incorrect. To get a fair idea we will use the version of mysql with the patch applied (as pointed in bug, stats w/o patch doesn’t help yield correct picture and so all kinds of interpretation and tuning is bound to fail). Use Case 11234RW-shared spins 338969, rounds 20447615, OS waits 592941RW-excl spins 50582, rounds 1502625, OS waits 56124RW-sx spins 12583, rounds 360973, OS waits 10484Spin rounds per wait: 60.32 RW-shared, 29.71 RW-excl, 28.69 RW-sx Let’s analyze the shared spins case: spins 338969, rounds 20447615, OS waits 592941```12345678910111213* 338K times flow couldn’t find the lock in first go, forcing thread to enter spin-lock.* During each spin-cycle there were 60 rounds of PAUSE cycle executed (so the said spin-cycles were done 2 times).* OS-waits/spins = 592/338 = 1.75 suggest that majority of the flow entered OS-wait (delay from PAUSE was not sufficient).* It also suggests that for the majority of spin-cycles, single OS -wait was not enough so it was repeated.**Conclusion:** Use-case represents heavy contention. Also, it sounds like PAUSE loop is unable to introduce the needed delay that is causing so many ROUNDS of PAUSE loop per spin-cycle.&lt;em&gt;256 thread oltp-read-write workload on 24 vCPU ARM machine&lt;/em&gt;### &lt;span style=&quot;color:#1aa260&quot;&gt;Use Case 2&lt;/span&gt; RW-shared spins 35943, rounds 777178, OS waits 19051RW-excl spins 4269, rounds 121796, OS waits 4164RW-sx spins 13407, rounds 321954, OS waits 7346Spin rounds per wait: 21.62 RW-shared, 28.53 RW-excl, 24.01 RW-sx 123456789101112131415161718Let’s analyze the shared spins case:&lt;br&gt;`RW-shared spins 35943, rounds 777178, OS waits 19051`* Flow invokes spin-loop 35K times.* Only 19K (that is approximately half of the spin-loop) caused OS-waits.* Per spin-cycle average too is limited to 21.62 that suggests that for each spin-cycle on average 22 rounds of PAUSE loop was invoked.**Conclusion:** Use-case represents medium contention.&lt;em&gt;16 thread oltp-read-write workload on 24 vCPU ARM machine&lt;/em&gt;### &lt;span style=&quot;color:#1aa260&quot;&gt;Use Case 3&lt;/span&gt;Just for reference, let me put an example of very less contention. This is with 16 threads oltp-read-write workload on x86_64 based VM with 16 CPU. RW-shared spins 39578, rounds 424553, OS waits 7329RW-excl spins 5828, rounds 78225, OS waits 1341RW-sx spins 11666, rounds 67297, OS waits 449Spin rounds per wait: 10.73 RW-shared, 13.42 RW-excl, 5.77 RW-sx 123456789101112* Flow invokes spin-loop 39K times.* Only 7K (that is approximately 20% of the spin-loop) caused OS-waits.* Per spin-cycle average too is limited to 10.**Conclusion:** Use-case represents low contention.&lt;em&gt;16 thread oltp-read-write workload on 24 vCPU x86_64 machine&lt;/em&gt;### &lt;span style=&quot;color:#1aa260&quot;&gt;Note on tuning&lt;/span&gt;Remember the high contention case we saw above. By tuning some things + code changes I could reduce the contention for shared-spins significantly. RW-shared spins 318800, rounds 13856732, OS waits 374634RW-excl spins 35759, rounds 656955, OS waits 22310RW-sx spins 10750, rounds 226315, OS waits 5598Spin rounds per wait: 43.47 RW-shared, 18.37 RW-excl, 21.05 RW-sx ``` Rounds per spins-cycles: average of 60 -&gt; 43 OS-wait per spin-cycle: 1.75 -&gt; 1.17 Is this good.? Not really. There are multiple factors to consider. Do you see improvement in TPS? Sometime it may be suggested to simply increase the PAUSE loop. But increasing PAUSE loop beyond some point can cause extended spin-cycle wasting precious CPU cycles especially if that causes it to land back in OS-wait. (Does this help more in HT cases vs multi-core case). Also, as pointed above, processor generation and type affect the PAUSE loop latency. There are multiple factors to consider. Even I am exploring this to see how we can tune this for all kinds of CPUs. I will blog more about it once I get some good solid algorithms on this front (or maybe we can develop some automated, self-adjustable or adaptive algorithms) so users don’t need to worry about it. ConclusionAs we saw above rw-locks stats can help us get good insight on understanding the contention of the system. Of-course it is not the only in-sight about InnoDB contention as mutexes are not covered as part of these stats. Tuning could be challenging but over-tuning can affect performance in the wrong way too. If you have more questions/queries do let me know. Will try to answer them.","link":"/2020/04/14/understanding-innodb-rw-lock-stats/"},{"title":"Web开源服务之ARM64现状","text":"作者: 王玺源 社区核心参与者：Martin Grigorov、Michael Rumph 背景开源界中Web服务众多,但其中很多软件对ARM64的支持并不理想。或是没有官方CI测试保证代码质量，或是在ARM64上的性能明显差于X86_64，甚至有的服务根本无法在ARM上运行。为了完善Web领域的ARM64生态，我们参与了主流的几个开源社区，旨在推动Web on ARM64。以下是我们近期的一些进展，以供大家参考。 概述我们目前参与了主流的共9个Web相关项目。如下所示 项目 主要语言 Apache Httpd Server C Apache Tomcat Java Memcached C Nginx C Lighttpd C JBoss/WildFly Java HAProxy C Squid C++ Varnish Cache C 针对这些项目，我们按照以下三个方面循序渐进的推动中: 能不能在ARM上运行 如何稳定在ARM上运行 怎么更好的在ARM上运行 能不能在ARM上运行我们可以看到这9大项目主要由Java和C/C++编写。 首先，像Python、Java这种自带runtime的语言天生就是跨平台的。这样的项目在ARM64平台上至少可以保证程序的可运行。 而C/C++项目则需要先编译成ARM64平台的目标可执行文件。这样的项目则需要先进行编译测试。 经过我们的测试，这9个Web项目都可以在ARM64上成功编译并运行。 如何稳定在ARM上运行所谓稳定，包含两个方面： 软件在ARM64上是否和在X86_64上行为一致？ 随着代码更新迭代，软件在ARM64上是否持续可用？ 行为一致我们常遇到两类行为一致的问题： 同样的代码，不同的结果 同样的功能，不同的支持 很遗憾，由于架构不同、底层实现不同等原因，很多软件的某些行为在X86_64和ARM64上的行为并不一致。 例如，之前的文章提到的Java中Math计算结果的差异。 又或者某些功能依赖独有的平台特性或者特殊的第三方库，导致在X86_64上可以运行的功能，在ARM64上却执行失败。 例如我们发现WildFly官方发布的源码包中缺少了个别ARM64平台的.so文件，这就导致个别调用.so的功能不可用。 针对这种问题，我们需要打开代码逐个分析、逐个修复。保证所有测试在ARM64上全部通过。 持续可用CI/CD是保证软件持续可用的重要方法。主流软件的CI系统都有X86_64平台的测试。而ARM64平台的少之又少。 针对这个问题，我们推动了这9个项目的ARM CI支持。除Lighttpd还在推动中以外，其他8个项目目前都已支持了ARM CI。甚至其中4个项目已经官方声明了ARM64的支持（详见附录）。 其中Httpd、Tomcat、Memcached、HAProxy和Varnish Cache通过Travis CI支持了ARM64测试。Nginx使用内部CI，对外不可见。Squid使用自己的树莓派。而JBOSS使用了我们捐献的基于Kunpeng 920的ARM虚拟机。同时我们也计划捐献同样的测试机到Lighttpd社区中。 随着ARM CI的落地，我们将持续保证ARM CI的稳定。我们相信在不久的将来，这9大核心Web项目都会官方声明ARM64的支持，并满足用户在ARM64上稳定、高效使用Web服务的需求。 怎么更好的在ARM上运行我们不仅希望软件在ARM64上能用，还在不断探索如何让软件在ARM64上用的好。其中性能优化是重中之重，也是我们未来一段时间的主要投入点。 例如，有些软件只实现了X86_64的汇编实现，但缺少ARM64的汇编代码。 又或者有些在X86_64上纯软实现的功能，可以在ARM64上通过下沉至硬编码的方式提高性能。 甚至还可以考虑如何最大化利用ARM64的多核优势，或规避ARM64的锁劣势等等。 关于性能优化的内容，我们将在以后的文章中针对不同的软件一一细说。敬请期待。 附录最后附上我们参与Web社区的总览表格及相关链接，感兴趣的同学可以进一步详读，有任何问题，欢迎留言。 Official arm64 CI CI tool Package in Downloads Official ARM support Apache Tomcat YES TravisCI Binary YES Memcached YES 1. BuildBot 2. TravisCI Source Code YES Apache httpd YES TravisCI Source Code YES NGINX YES Internal Only for Ubuntu LTSs YES Lighttpd NO Jenkins Source Code NO JBoss/Wildfly YES TeamCity Source Code NO HAProxy YES 1. CirrusCI 2. TravisCI Source Code YES Squid YES Jenkins Source Code NO Varnish Cache YES Travis 1. Source Code 2. Package NO","link":"/2020/04/10/web-kai-yuan-fu-wu-zhi-arm64-xian-zhuang/"},{"title":"Why ARM?","text":"作者: Krunal Bauskar 原文链接: https://mysqlonarm.github.io/Why-ARM/ ARM processors are everywhere. It is quite likely some of you may be reading this blog from an ARM powered device. Phone, IoT devices, consumer and home appliances, health-care devices, all are powered by ARM processors. ARM processors are known to be power efficient and so most of these devices that demands a long recharge cycle but less processing power started using them. But this has changed in the past few years. More and more ARM processors are being used for high-end applications like database server, web server, application server, big data use-cases. They have already made their way to the data-centers as a server class machines. They are being looked upon as a cost effective option while running applications in cloud. ARM ecosystem evolutionFew years back it was difficult to imagine that ARM would be used for running some high-end server class applications. There were 2 major reasons that I could think off: ARM were best suited for small handheld devices. ARM ecosystem was limited around the specific product it supported. ARM ecosystem has really picked up well after some major OS providers added support for it including RedHat (CentOS), Ubuntu, Debian, Windows. This eased out porting of the major softwares to ARM. ARM community gave it a push to make sure most of the standard softwares are available on ARM viz. IDE, DB-server, Hadoop and all its variants from Apache Foundation, CI/CD software, Container, Virtualization, etc… The ARM model that allows other vendors to license and develop their own ARM processors further helped fueled its popularity with more chip designers joining, collaborating and innovating. Break-through came with major cloud providers like Amazon started providing ec2 instances (currently invitation only) based on ARM processors this means now everyone can boot an ARM instance and start developing/porting their software on ARM. This helped further grow the ecosystem. What was missing?Though most of these software have been ported to ARM they were not yet optimized for ARM. ARM has a weak memory model, can fit more cores in smaller space, difference in low-level instruction (for software that uses them), etc.. This was the start of the 2nd phase of ARM where the community/developer/user started moving from “running software on arm” -&gt; “optimizing software on arm”. I think this was a major win for the arm community when users started to think ARM seriously and started spending efforts on optimizing their software on ARM. This (especially optimization) is a never ending process but I see first goal is to at-least be on par with x86. I purposely say “onpar” because each of architecture has its own USP so say if you port an enterprise class application to ARM and you can offer it to customer @ 50% of the cost (operating cost + initial investment) for 75% of the performance of x86 I think that would be still be attractive fit for most of the customers (especially given application are horizontally scalable). Of-course that doesn’t mean all applications run on ARM at reduced speed, in fact there are applications that run on ARM faster than x86 and since the optimization phase has just started in next few years a lot of applications would be running on ARM faster than other architectures. Go GreenIt is everywhere and especially a matter of major concern for data-center operators (small or big). ARM being power efficient can save approximately 50% of the power compared to other architecture. This makes it help support Go-Green initiative. ARM is Next-Gen processorIt is interesting why I referred to it this way. Next generation kids are actively using kits like Andrino, Raspberry Pi, Odroid, Banana Pi, Asus tinker board, etc…. to build some of the next-gen system. These kids will be defining the next generation of computing. Given they started with ARM their social community has grown around ARM in the next few years there would be an army of ARM users/developers with a very active community. All the groundwork and good things that are being built at this stage around ARM will be pushed to the next level once this workforce becomes active. ARM in Desktop/LaptopThis is catching up fast and no wonder if we start seeing ARM based Desktop/PC workstation/Laptop (there are already few) commonly being used. ConclusionThe ARM Ecosystem looks a lot more fascinating and full of new challenges and opportunities. Current decade will be ruled by ARM based processors and it will be everywhere from tiny wearable devices to high-end movie experience, from auto-driving cycle/car to jumbo jet/space-craft. It is estimated that there would be 35 active ARM power devices per person. That’s Ocean of Opportunity. If you have any comments feel free to drop an email (check about section)","link":"/2020/03/30/why-arm/"},{"title":"利用SIMD Vectorization优化PostgreSQL","text":"译者: bzhaoopenstack作者: Amit Dattatray Khandekar原文链接: https://amitdkhan-pg.blogspot.com/2020/06/leveraging-simd-vectorization.html 团队大牛Amit利用SIMD向量化对ARM和X86硬件平台在PostgreSQL上的优化，欢迎品鉴，相当硬核，坐稳了吗？ 中文 English Leveraging SIMD Vectorization随着列式存储数据库的出现，人们迫切需要使用 SIMD 向量处理数据表。 这种情况显然很符合表格数据的排列方式。 让我们首先简单介绍一下什么是 SIMD。 它代表单指令多数据流(Single Instruction Multiple Data)。 在当前，CPU 指令支持这种机制，在这种机制中，同一条指令可以在多个数据元素上同时执行。 例如，你想把所有的列值元素加倍。 或者删除图像像素RGB 值的红色部分。 对于大数据场景来说，这些操作是 CPU 的瓶颈。 因此，SIMD 根据每个数据元素的大小，对2、4、8、16或32个(或更多)数据元素同时进行操作，从而大大缩短了 CPU 时间。 假设我们想对“ int32 arr []”的每个元素执行“ arr [ i ] * = 2”。 通常，我们会遍历每个元素来执行这个操作。 在生成的汇编代码中，MUL 指令将在每个元素上执行。 使用 SIMD，我们将划分4个(或更多)相邻的数组元素加载到128位(或更大) CPU“向量”寄存器中，然后让这个寄存器调用 MUL 指令的“向量化”版本，并对随后的每个4数组元素重复这一步骤。 我们怎么做才能生成这样的向量化汇编指令？ 一种方法是编写这样的汇编代码。 但是在大多数情况下，我们不会这么做，多亏了以下两个方法的出现: 1. 内部函数实现向量化 对于程序员来说，调用内部函数就像调用其他函数一样。 在底层，编译器会用适当的程序集指令替换它。 因此，不必使用 c / c + + 代码中的汇编指令来处理寄存器，而是调用相应的内部函数。 每个 CPU 体系结构都有自己的一组内部函数API 和相应的头文件。 作为一个例子，让我们使用 ARM 架构的 SIMD内部函数对 PostgreSQL 代码片段进行向量化，看看通过向量化代码会产生多大的不同。 在此之前，您可能希望快速浏览NEON架构预览来了解寄存器(registers)、通道(lanes)和向量(vectors)的命名规范。 NEON是 ARM SIMD 架构的品牌名称(The implementation of the Advanced SIMD extension used in ARM processors is called NEON,)。 NEON 单元是 ARMv8芯片的必备部分。 下面是 PostgreSQL 代码片段，mul_var() 函数 用于将两个PostgreSQL NUMERIC 数据类型的值相乘. 就像下面的例子那样: 123for (i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3), i = i1 + i2 + 2; i2 &gt;= 0; i2--) dig[i--] += var1digit * var2digits[i2]; 其中变量声明为: 12int32 *dig;int16 var1digit, *var2digits; 这个例子，你将可以看到循环迭代 i2 + 1次。 在每次迭代中，i 和 i2都会递减。 这意味着，两个数组中的每个数组都有一个固定的连续区段，我们希望在这个区段中对每个数组元素重复执行相同的算术运算。 这里所做的算法是: 将两个 int16变量相乘，然后将乘积加起来得到一个 int32变量。 有一条汇编指令正是这样做的: VMLA。 相应的 内部函数是: vmlal _ s16() 让我们首先将上面的反向 for-loop 简化为一个等效的正向循环 : 12345i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3);count = i2 + 1;digptr = &amp;dig[i1 + 2];for (i = 0; i &lt; count; i++) digptr[i] += var1digit * var2digits[i]; 当我们想要对上面的 multiply + accumulate 语句进行向量化时，我们应用下面这个内部函数： 1int16x8_t vmlaq_s16(int16x8_t a, int16x8_t b, int16x8_t c); 这句代码执行 a + (b * c)并返回结果。 a b c 是矢量。 类型 int16x8_t 表示该向量位于一个128位的 NEON 寄存器中，该寄存器有8个通道，每个通道有16位有符号整数。 所以 vmlaq_s16并行地对3个向量的所有8个通道执行相同的multiply + accumulate操作，并在一个int16x8_t 向量中再次返回8个结果值。 每个multiply + accumulate操作都包含在所有3个向量中的一个特定通道中。如上面 c 代码片段所示，为了避免溢出，将所得的乘法累计值计入一个32位整数。 因此，我们不能使用vmlaq_s16() ，而必须使用一个对16位值进行操作并返回32位值的内部函数： 1int32x4_t vmlal_s16(int32x4_t a, int16x4_t b, int16x4_t c); 由于128位矢量只能容纳4个32位数据元素，因此4个元素可以并行化，而不是8个。 可以看出，所有这些操作都使用128位寄存器，它们不需要完全占用，就像使用 int16x4向量那样。 我们需要首先将 C 数组元素值加载到这些寄存器中，最后将结果值从寄存器取回至结果数组元素中。 我们也有实现这种想法的内部函数。 尽管有混合使用标量和向量的内部函数，然而上面内部函数只使用到了向量。 因此，同样的 var1digit 值可以装载到16x4矢量的所有4个通道中。 结合这些内部函数，最终的代码会是: 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;arm_neon.h&gt;............int i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3);int remainder;int count = i2 + 1;int32 *digptr = &amp;dig[i1 + 2];/* Load the same var1digit value into all lanes of 16x4 vector. */int16x4_t var1digit_16x4 = vdup_n_s16(var1digit); // VDUP.16 d0,r0/* Parallelize each group of 4 digits */remainder = count%4;count -= remainder;for (i = 0; i &lt; count; i += 4){ /* \\* 1. Load required data into vectors \\* 2. Do multiply-accumulate-long operation using 16x4 vectors, \\* whose output is a 32x4 vector which we need, because digptr[] \\* is 32bit. \\* 3. Store back the result vector into digptr[] */ /* Load 4 var2digits into 16x4 vector and digptr into 32x4 */ int16x4_t var2digits_16x4 = vld1_s16(&amp;var2digits[i]); int32x4_t dig_32x4 = vld1q_s32(&amp;digptr[i]); /* Vector multiply-accumulate-long: vmlal_&lt;type&gt;. Vr[i] := Va[i] + Vb[i] * Vc[i] */ dig_32x4 = vmlal_s16(dig_32x4, var1digit_16x4, var2digits_16x4); /* Store back the result into &amp;digptr[i] */ vst1q_s32(&amp;digptr[i], dig_32x4);}/* Do the last remaining digits */for (; remainder != 0; remainder--, i++) digptr[i] += var1digit * var2digits[i]; 我创建了一个包含高精度的数据的模型，如图所示, 并以多组t1.val 和 t2.val来执行如下查询。在没有向量化时，执行时间为0.874毫秒: 1234567891011121314151617181920212223$ psql -c &quot;explain analyze SELECT t1.id, t2.id, t1.val * t2.val FROM num_data t1, num_data t2&quot; QUERY PLAN \\----------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=0.00..1039.85 rows=67600 width=40) (actual time=0.016..0.840 rows=100 loops=1) -&gt; Seq Scan on num_data t1 (cost=0.00..12.60 rows=260 width=275) (actual time=0.003..0.004 rows=10 loops=1) -&gt; Materialize (cost=0.00..13.90 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=10) -&gt; Seq Scan on num_data t2 (cost=0.00..12.60 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=1) Planning Time: 0.156 ms Execution Time: **0.874** ms(6 rows)With the above vectorized code, the same query execution time is now .360 ms, i.e. more than 2x speedup :$ psql -c &quot;explain analyze SELECT t1.id, t2.id, t1.val * t2.val FROM num_data t1, num_data t2&quot; QUERY PLAN \\----------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=0.00..1039.85 rows=67600 width=40) (actual time=0.016..0.322 rows=100 loops=1) -&gt; Seq Scan on num_data t1 (cost=0.00..12.60 rows=260 width=275) (actual time=0.007..0.008 rows=10 loops=1) -&gt; Materialize (cost=0.00..13.90 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=10) -&gt; Seq Scan on num_data t2 (cost=0.00..12.60 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=1) Planning Time: 0.169 ms Execution Time: **0.360** ms(6 rows) 使用上面的向量化代码，相同的查询执行时间现在是0.360 ms，即超过2倍的加速: : 12345678910$ psql -c &quot;explain analyze SELECT t1.id, t2.id, t1.val * t2.val FROM num_data t1, num_data t2&quot; QUERY PLAN \\----------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=0.00..1039.85 rows=67600 width=40) (actual time=0.016..0.322 rows=100 loops=1) -&gt; Seq Scan on num_data t1 (cost=0.00..12.60 rows=260 width=275) (actual time=0.007..0.008 rows=10 loops=1) -&gt; Materialize (cost=0.00..13.90 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=10) -&gt; Seq Scan on num_data t2 (cost=0.00..12.60 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=1) Planning Time: 0.169 ms Execution Time: **0.360** ms(6 rows) 由于数字的个别位数必须与另一个数字的位数相乘，对于精度较高的数字来说，效果更好。 我创建的模式精度在200-600之间。 但是当我在 ARM64 VM 上的测试时，从20精度开始，它的好处就显现出来了。 2. 自动向量化 并不总是需要编写使用 内部函数的代码。通常，如果我们组织并简化代码，今天的编译器，使用适当的编译器选项尝试识别代码是否可以被向量化, 并生成适当的汇编指令，以便利用 CPU 体系结构的 SIMD。实际上，在上面的代码中，我将反向 for-loop 简化为使用单个变量递增的正向 for-loop，gcc 编译器能够自动对简化的 for-loop 进行向量化。 以下是一些细节: 12345678910111213141516171819202122232425262728diff --git a/src/backend/utils/adt/numeric.c b/src/backend/utils/adt/numeric.cindex f3a725271e..4243242ad9 100644--- a/src/backend/utils/adt/numeric.c+++ b/src/backend/utils/adt/numeric.c@@ -7226,6 +7226,7 @@ mul_var(const NumericVar *var1, const NumericVar *var2, NumericVar *result, int res_weight; int maxdigits; int *dig;\\+ int *digptr; int carry; int maxdig; int newdig;@@ -7362,10 +7363,14 @@ mul_var(const NumericVar *var1, const NumericVar *var2, NumericVar *result, * \\* As above, digits of var2 can be ignored if they don't contribute, \\* so we only include digits for which i1+i2+2 &lt;= res_ndigits - 1.\\+ *\\+ * For large precisions, this can become a bottleneck; so keep this for\\+ * loop simple so that it can be auto-vectorized. */\\- for (i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3), i = i1 + i2 + 2;\\- i2 &gt;= 0; i2--)\\- dig[i--] += var1digit * var2digits[i2];\\+ i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3);\\+ digptr = &amp;dig[i1 + 2];\\+ for (i = 0; i &lt;= i2; i++)\\+ digptr[i] += var1digit * var2digits[i]; } 通过这个修改，在 mul_var()汇编代码中，我可以看到操作 NEON 向量的乘积指令(这些是 arm64指令) : 12smlal v1.4s, v2.4h, v3.4hsmlal2 v0.4s, v2.8h, v3.8h gcc 编译器选项启用自动向量化是“-ftree-loop-vectorize”. 当使用 gcc -O3时，它始终是开启的。 虽然有一些例子表明 gcc 能够自动向量化甚至是反向循环，但是在上面的例子中，由于两个递减变量，它不能对原始代码这样做。 这就是为什么我必须将其简化为一个单变量递增的正向循环，这是最简单的方式来规避。 要检查 gcc 是否能够向量化一段代码，请使用 gcc -fopt-info-all 选项。输出信息如下: 1234numeric.c:7217:3: optimized: loop vectorized using 16 byte vectorsOr in case it can't vectorize, you would see something like this :numeric.c:7380:3: missed: couldn't vectorize loopnumeric.c:7381:15: missed: not vectorized: relevant stmt not supported: _39 = *_38; 用这种自动向量化的方法，我观察到的加速比大约是2.7倍。 这种加速比内部函数方式更快快，可能是因为编译器可能比我使用了更好的汇编向量化指令组合。 总结 向量化操作可以在重复操作中获得显著的性能提升。 虽然它很适合柱状数据结构，但是当前 PostgreSQL 代码中的一些代码可能会受益于利用 SIMD 进行这种调整。 尽可能使用编译器的自动向量化。 因为这样的做会使代码更干净，更容易移植。 与方法1相比，我们必须使用特定于 CPU 体系结构的内部函数。 但是选择这个例子是为了解释如何使用内部函数来向量化。 在编译器不能对代码进行向量化的情况下，我们应该使用编译器内部函数。 例如:这个。 With the advent of column store databases, there was an urge to make use of SIMD vector processing. It naturally fits into the way table data is arranged. Let’s first briefly check what is SIMD. It stands for Single Instruction Multiple Data. Today, CPU instructions support this kind of mechanism where the same instruction can be executed simultaneously on multiple data elements. E.g. Say, you want to double all the column values. Or remove the red component of the RGB values of pixels of an image. For large data, these operations are CPU bottlenecks. So SIMD cuts the CPU time significantly by operating simultaneously on 2, 4, 8, 16 or 32 (or more) data elements depending on the size of each data element. So suppose we want to do “arr[i] *= 2” for each element of “int32 arr[]”. Normally we would iterate through each of the elements for doing this operation. In the generated assembly code, MUL instruction will be run on each of the elements. With SIMD, we would arrange for loading 4 (or more) adjacent array elements into a 128-bit (or larger) CPU “vector” register, and then arrange for a “vectorized” version of the MUL instruction to be called using this register, and repeat this for each subsequent 4 element array section. How do we arrange for generating such vectorized assembly instructions ? Well, one way is to write such an assembly code. But in most of the cases, we won’t need this method, thanks to the below two methods : 1. Vectorization Intrinsics For a programmer, an intrinsic is just like any other function call. Underneath, the compiler replaces it with an appropriate assembly instruction. So instead of having to deal with registers using assembly instruction inside C/C++ code, call the corresponding intrinsic function. Each CPU architecture has it’s own set of intrinsics API, and corresponding header file. As an example, let’s vectorize a snippet of PostgreSQL code using ARM architecture’s SIMD intrinsics, to see how big a difference it makes by vectorizing things. Before that, you might want to quickly go through the NEON architecture to understand the naming conventions for registers, lanes and vectors. NEON is ARM’s brand name for SIMD architecture. NEON unit is a mandatory part of ARMv8 chip. Here is a PostgreSQL code snippet from the mul_var() function that is used to multiply two PostgreSQL NUMERIC data types. As of this writing, it looks like this : 123for (i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3), i = i1 + i2 + 2; i2 &gt;= 0; i2--) dig[i--] += var1digit * var2digits[i2]; where, the variables are declared as : 12int32 *dig;int16 var1digit, *var2digits; Here, you can see that the loop iterates i2+1 times. On each iteration, both i and i2 are decremented. That means, there is a fixed contiguous section of each of the two arrays where we want to repeatedly do the same arithmetic operation for every array element in this section. The arithmetic being done here is : multiply two int16 variables, and add up that product into an int32 variable. An assembly instruction is available which exactly does that : VMLA. The corresponding intrinsic is : vmlal_s16() Let’s first simplify the above backward for-loop into an equivalent forward loop : 12345i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3);count = i2 + 1;digptr = &amp;dig[i1 + 2];for (i = 0; i &lt; count; i++) digptr[i] += var1digit * var2digits[i]; So we want to vectorize the above multiply+accumulate statement. We have this intrinsic : 1int16x8_t vmlaq_s16(int16x8_t a, int16x8_t b, int16x8_t c); This does a+(b*c) and returns the result. a, b and c are vectors. The type int16x8_t signifies that the vector is in a 128-bit NEON register having 8 lanes, each lane having 16-bit signed integers. So vmlaq_s16() does the multiply+accumulate operation on all 8 lanes of the 3 vectors in parallel, and returns the 8 result values again in a int16x8_t vector. Each multiple+accumulate is contained in one particular lane of all the 3 vectors.To avoid overflow, as can be seen in the above C snippet, the multiplication is accumulated into a 32-bit integer. So instead of vmlaq_s16(), we have to use an intrinsic that operates on 16-bit values and returns 32bit values : 1int32x4_t vmlal_s16(int32x4_t a, int16x4_t b, int16x4_t c); Since only 4 32-bit data elements can be accommodated in a 128-bit vector, 4 elements could be parallelized rather than 8. As can be seen, all these operations use the 128-bit registers, even though they need not be fully occupied, as in the case with int16x4 vectors. We need to first load the C array element values into these registers, and in the end, store the resultant values back from the registers into the result array elements. We have intrinsics for that also. Although there are intrinsics that operate on a mix of scalar and vectors, the intrinsic used above uses only vectors. So the same var1digit value can be loaded into all 4 lanes of a 16x4 vector. With these instrinsics, the final code looks like this : 1234567891011121314151617181920212223242526272829303132333435363738\\#include &lt;arm_neon.h&gt;............int i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3);int remainder;int count = i2 + 1;int32 *digptr = &amp;dig[i1 + 2];/* Load the same var1digit value into all lanes of 16x4 vector. */int16x4_t var1digit_16x4 = vdup_n_s16(var1digit); // VDUP.16 d0,r0/* Parallelize each group of 4 digits */remainder = count%4;count -= remainder;for (i = 0; i &lt; count; i += 4){ /* \\* 1. Load required data into vectors \\* 2. Do multiply-accumulate-long operation using 16x4 vectors, \\* whose output is a 32x4 vector which we need, because digptr[] \\* is 32bit. \\* 3. Store back the result vector into digptr[] */ /* Load 4 var2digits into 16x4 vector and digptr into 32x4 */ int16x4_t var2digits_16x4 = vld1_s16(&amp;var2digits[i]); int32x4_t dig_32x4 = vld1q_s32(&amp;digptr[i]); /* Vector multiply-accumulate-long: vmlal_&lt;type&gt;. Vr[i] := Va[i] + Vb[i] * Vc[i] */ dig_32x4 = vmlal_s16(dig_32x4, var1digit_16x4, var2digits_16x4); /* Store back the result into &amp;digptr[i] */ vst1q_s32(&amp;digptr[i], dig_32x4);}/* Do the last remaining digits */for (; remainder != 0; remainder--, i++) digptr[i] += var1digit * var2digits[i]; I created a schema that contains numerics with large precisions, as shown here, and ran the following query that multiplies t1.val and t2.val. With the non-vectorized code, the execution time showed .874 milliseconds : 1234567891011121314151617181920212223$ psql -c &quot;explain analyze SELECT t1.id, t2.id, t1.val * t2.val FROM num_data t1, num_data t2&quot; QUERY PLAN \\----------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=0.00..1039.85 rows=67600 width=40) (actual time=0.016..0.840 rows=100 loops=1) -&gt; Seq Scan on num_data t1 (cost=0.00..12.60 rows=260 width=275) (actual time=0.003..0.004 rows=10 loops=1) -&gt; Materialize (cost=0.00..13.90 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=10) -&gt; Seq Scan on num_data t2 (cost=0.00..12.60 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=1) Planning Time: 0.156 ms Execution Time: **0.874** ms(6 rows)With the above vectorized code, the same query execution time is now .360 ms, i.e. more than 2x speedup :$ psql -c &quot;explain analyze SELECT t1.id, t2.id, t1.val * t2.val FROM num_data t1, num_data t2&quot; QUERY PLAN \\----------------------------------------------------------------------------------------------------------------------- Nested Loop (cost=0.00..1039.85 rows=67600 width=40) (actual time=0.016..0.322 rows=100 loops=1) -&gt; Seq Scan on num_data t1 (cost=0.00..12.60 rows=260 width=275) (actual time=0.007..0.008 rows=10 loops=1) -&gt; Materialize (cost=0.00..13.90 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=10) -&gt; Seq Scan on num_data t2 (cost=0.00..12.60 rows=260 width=275) (actual time=0.001..0.002 rows=10 loops=1) Planning Time: 0.169 ms Execution Time: **0.360** ms(6 rows) Since individual digits of the number have to be multiplied by the digits of the other number, the benefit is more for numerics with large precision. The schema I created has values with precisions in the range of 200-600. But the benefit starts showing up from around 20 precision onwards, with my ARM64 VM. 2. Auto-vectorization It’s not always necessary to write code that uses intrinsics. Often if we arrange/simplify the code, today’s compilers, with appropriate compiler options, try to identify if the code can be vectorized, and generate appropriate assembly instructions that leverage the CPU architecture’s SIMD. In fact, above where I simplified the backward for-loop to a forward for-loop that uses a single variable increment, the gcc compiler is able to auto-vectorize the simplified for-loop. Here are the changes again: 12345678910111213141516171819202122232425262728diff --git a/src/backend/utils/adt/numeric.c b/src/backend/utils/adt/numeric.cindex f3a725271e..4243242ad9 100644--- a/src/backend/utils/adt/numeric.c+++ b/src/backend/utils/adt/numeric.c@@ -7226,6 +7226,7 @@ mul_var(const NumericVar *var1, const NumericVar *var2, NumericVar *result, int res_weight; int maxdigits; int *dig;\\+ int *digptr; int carry; int maxdig; int newdig;@@ -7362,10 +7363,14 @@ mul_var(const NumericVar *var1, const NumericVar *var2, NumericVar *result, * \\* As above, digits of var2 can be ignored if they don't contribute, \\* so we only include digits for which i1+i2+2 &lt;= res_ndigits - 1.\\+ *\\+ * For large precisions, this can become a bottleneck; so keep this for\\+ * loop simple so that it can be auto-vectorized. */\\- for (i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3), i = i1 + i2 + 2;\\- i2 &gt;= 0; i2--)\\- dig[i--] += var1digit * var2digits[i2];\\+ i2 = Min(var2ndigits - 1, res_ndigits - i1 - 3);\\+ digptr = &amp;dig[i1 + 2];\\+ for (i = 0; i &lt;= i2; i++)\\+ digptr[i] += var1digit * var2digits[i]; } With this change, in mul_var() assembly code, I could see the multiply-accumulate instructions that operate on NEON vectors (these are arm64 instructions) : 12smlal v1.4s, v2.4h, v3.4hsmlal2 v0.4s, v2.8h, v3.8h gcc compiler option to enable auto-vectorization is “-ftree-loop-vectorize”. With gcc -O3, it is always enabled. Although there are examples where gcc is able to auto-vectorize even backward loops, in the above case, it could not do so for the original code, seemingly because of two decrementing variables. That’s why I had to simplify it to a forward loop with a single variable increment, which is as simple as it gets. To check whether gcc has been able to vectorize a particular code, use the gcc -fopt-info-all option. This outputs info such as this : 1234numeric.c:7217:3: optimized: loop vectorized using 16 byte vectorsOr in case it can't vectorize, you would see something like this :numeric.c:7380:3: missed: couldn't vectorize loopnumeric.c:7381:15: missed: not vectorized: relevant stmt not supported: _39 = *_38; With this auto-vectorization method, the speedup I observed was around 2.7x. This speedup is higher than the intrinsics method, probably because the compiler might have used a better combination of assembly vectorized instructions than I did. Conclusion Vectorizing operations gives significant returns in repetitive operations. Although it suits well for columnar data, there could be some regions in current PostgreSQL code that might benefit from such tweaks to leverage SIMD. As far as possible, we should arrange for the compiler’s auto-vectorization. Such change is cleaner and clearly portable. Compare this with method 1 where we had to use intrinsics specific to the CPU architecture. But that example was chosen for the sake of explaining how to make use of intrinsics. In cases where it is not possible for the compiler to vectorize the code, we should use compiler intrinsics. E.g. check this out. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/06/24/li-yong-simd-vectorization-you-hua-postgresql/"},{"title":"指定NUMA节点运行MySql","text":"译者: bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/Running-MySQL-on-Selected-NUMA-nodes/ 指定NUMA节点来运行Mysql，全路程实践，来试试吧 中文 English “在选定的 NUMA 节点上运行 MySQL”看起来非常简单，但不幸的是，它并不简单。最近，我遇到了一个情况，需要在2个(甚至4个) NUMA 节点上运行 MySQL。 当然，我尝试的第一件事就是使用 numactl --physcpubind 限制 CPU/Core 集合，只从选定的NUMA节点选择CPUs和Core。MySQL 配置为 innodb_numa_interleave=1 ，因此我希望它仅从这个选定的NUMA 节点分配内存(因为我限制了 CPU/core 的使用)。 Suprise-1:MySQL 使用 numa_all_nodes_ptr-&gt;maskp 这意味着即使 CPU 任务集被限制为2个 NUMA 节点。 Daniel Black告诉我并让我意识到的两个问题: https://github.com/mysql/mysql-server/pull/104 (5.7) https://github.com/mysql/mysql-server/pull/138 (8.0) 上述问题建议切换到一个更符合逻辑的 numa_get_mems_allowed(). 根据文档，它应该返回一个节点的掩码，告知这个节点被允许为特定的进程分配内存。 1ref-from-doc: numa_get_mems_allowed() returns the mask of nodes from which the process is allowed to allocate memory in it's current cpuset context. 所以我决定应用这个补丁并继续测试。 Suprise-2:仅仅使用补丁和限制 cpu/core集合并没有帮助，所以我想尝试使用 membind 选项。 Suprise-3:所以现在这个命令看起来像: 1numactl --physcpubind= --membind=0,1 这一次，我当然只希望从选定的 NUMA 节点分配内存，但它仍然没有。它从所有4个节点分配内存。 经过一番文档搜索，建议对 numa_all_nodes_ptr 查看 mems_allowed 字段，如下所述a 1numa_all_nodes_ptr: The set of nodes to record is derived from /proc/self/status, field &quot;Mems_allowed&quot;. The user should not alter this bitmask. 正如 Alexey Kopytov 在 PR # 138中指出的, numa_all_nodes_ptr 和numa_get_mems_allowed r允许读取相同的NUMA掩码。 这意味着 numa_get_mems_allowed已经失效，或者文档需要更新。 为了完全确认，我还尝试了 numctl-interleave，但这也没有帮助 事实验证:因此，我决定使用一个简单的程序(在 MySQL 之外)来验证上述事实。 12345678910111213#include &lt;iostream&gt;#include &lt;numa.h&gt;#include &lt;numaif.h&gt;using namespace std;int main(){cout &lt;&lt; *numa_all_nodes_ptr-&gt;maskp &lt;&lt; endl;cout &lt;&lt; *numa_get_mems_allowed()-&gt;maskp &lt;&lt; endl;}numactl --membind=0-1 ./a.out1515 很明显，当 numa_get_mems_allowed 返回的只是允许分配内存的NUMA节点时，两者似乎返回相同的掩码值。 解决方案:我迫切需要一个解决方案，所以尝试使用一个简单的工作方式手动填补掩码(将继续跟进与操作系统供应商 numactl 行为)。这种方法最终奏效了，现在只能从选定的 NUMA 节点分配内存。 123456789101112131415161718192021+const unsigned long numa_mask = 0x3; struct set_numa_interleave_t { set_numa_interleave_t() { if (srv_numa_interleave) { ib::info(ER_IB_MSG_47) &lt;&lt; &quot;Setting NUMA memory policy to&quot; &quot; MPOL_INTERLEAVE&quot;;- if (set_mempolicy(MPOL_INTERLEAVE, numa_all_nodes_ptr-&gt;maskp,+ if (set_mempolicy(MPOL_INTERLEAVE, &amp;numa_mask, numa_all_nodes_ptr-&gt;size) != 0) { ib::warn(ER_IB_MSG_48) &lt;&lt; &quot;Failed to set NUMA memory&quot; &quot; policy to MPOL_INTERLEAVE: &quot;@@ -1000,7 +1001,7 @@ static buf_chunk_t *buf_chunk_init( #ifdef HAVE_LIBNUMA if (srv_numa_interleave) { int st = mbind(chunk-&gt;mem, chunk-&gt;mem_size(), MPOL_INTERLEAVE,- numa_all_nodes_ptr-&gt;maskp, numa_all_nodes_ptr-&gt;size,+ &amp;numa_mask, numa_all_nodes_ptr-&gt;size, MPOL_MF_MOVE); if (st != 0) { ib::warn(ER_IB_MSG_54) &lt;&lt; &quot;Failed to set NUMA memory policy of&quot; (当然，这需要从源代码重新构建，而不是二进制/包(如果想用，往下看)). 那你为什么不用… ?当然，大多数人可能会建议通过将 innodb_numa_interleave 关闭而使用 membind 来避免这种情况. 当然，这种方法是可行的，但是这种方法略有不同，因为所有分配的内存都受上述限制的约束，而innodb_numa_interleave 仅在缓冲池分配期间适用。它可能应用于特定的目的，但可能不能像这样比较。 这已经在我的待办事项列表中，以检查 complete interleave vs innodb_numa_interleave带来的影响。 总结NUMA 节点上的平衡分配有多个方面，包括核心选择、内存分配、线程分配(同样在选定的 NUMA 节点上)等等。更过的惊喜和令人兴奋的东西等待我们去探索。 如果你有问题/疑问，请联系我。 “Running MySQL on selected NUMA node(s)” looks pretty straightforward but unfortunately it isn’t. Recently, I was faced with a situation that demanded running MySQL on 2 (out of 4) NUMA nodes. Naturally, the first thing I tried was to restrict CPU/Core set using numactl --physcpubind selecting only the said CPUs/cores from the said NUMA nodes. MySQL was configured to use innodb_numa_interleave=1 so I was expecting it to allocate memory from the said NUMA nodes only (as I restricted usage of CPU/core). Suprise-1:MySQL uses numa_all_nodes_ptr-&gt;maskp that means all the nodes are opted even though the CPU task-set is limited to 2 NUMA nodes. Some lookout pointed me to these 2 issues from Daniel Black https://github.com/mysql/mysql-server/pull/104 (5.7) https://github.com/mysql/mysql-server/pull/138 (8.0) Issue proposes to switch to a more logical numa_get_mems_allowed(). As per the documentation it should return a mask of the node that are are allowed to allocate memory for the said process. 1ref-from-doc: numa_get_mems_allowed() returns the mask of nodes from which the process is allowed to allocate memory in it's current cpuset context. So I decided to apply the patch and proceed. Suprise-2:Just applying patch and relying on cpu/core set didn’t helped. So I thought of trying with membind option. Suprise-3:So now the command looks like: 1numactl --physcpubind= --membind=0,1 This time I surely expected that memory would be allocated from the said NUMA nodes only but it still didn’t. Memory was allocated from all 4 nodes. Some more documentation search, suggested that for numa_all_nodes_ptr looks at mems_allowed field as mentioned below 1numa_all_nodes_ptr: The set of nodes to record is derived from /proc/self/status, field &quot;Mems_allowed&quot;. The user should not alter this bitmask. and as Alexey Kopytov pointed in PR#138, numa_all_nodes_ptr and numa_get_mems_allowed reads the same mask. This tends to suggest that numa_get_mems_allowed is broken or documentation needs to be updated. Just for completeness, I also tried numctl –interleave but that too didn’t helped Fact Validation:So I decided to try this using a simple program (outside MySQL) to validate the said fact. 12345678910111213#include &lt;iostream&gt;#include &lt;numa.h&gt;#include &lt;numaif.h&gt;using namespace std;int main(){cout &lt;&lt; *numa_all_nodes_ptr-&gt;maskp &lt;&lt; endl;cout &lt;&lt; *numa_get_mems_allowed()-&gt;maskp &lt;&lt; endl;}numactl --membind=0-1 ./a.out1515 It is pretty clear that both seem to return the same mask value when numa_get_mems_allowed should return only memory allowed nodes. Workaround:I desperately needed a solution so tried using a simple workaround of manually feeding the mask (will continue to follow up about numactl behavior with OS vendor). This approach finally worked and now I can allocate memory from selected NUMA nodes only. 123456789101112131415161718192021+const unsigned long numa_mask = 0x3; struct set_numa_interleave_t { set_numa_interleave_t() { if (srv_numa_interleave) { ib::info(ER_IB_MSG_47) &lt;&lt; &quot;Setting NUMA memory policy to&quot; &quot; MPOL_INTERLEAVE&quot;;- if (set_mempolicy(MPOL_INTERLEAVE, numa_all_nodes_ptr-&gt;maskp,+ if (set_mempolicy(MPOL_INTERLEAVE, &amp;numa_mask, numa_all_nodes_ptr-&gt;size) != 0) { ib::warn(ER_IB_MSG_48) &lt;&lt; &quot;Failed to set NUMA memory&quot; &quot; policy to MPOL_INTERLEAVE: &quot;@@ -1000,7 +1001,7 @@ static buf_chunk_t *buf_chunk_init( #ifdef HAVE_LIBNUMA if (srv_numa_interleave) { int st = mbind(chunk-&gt;mem, chunk-&gt;mem_size(), MPOL_INTERLEAVE,- numa_all_nodes_ptr-&gt;maskp, numa_all_nodes_ptr-&gt;size,+ &amp;numa_mask, numa_all_nodes_ptr-&gt;size, MPOL_MF_MOVE); if (st != 0) { ib::warn(ER_IB_MSG_54) &lt;&lt; &quot;Failed to set NUMA memory policy of&quot; (Of-course this needs re-build from source code and not an option for binary/package user (well there is .. check following section)). But then why didn’t you used … ?Naturally, most of you may suggest that this could be avoided by toggling innodb_numa_interleave back to OFF and using membind. Of-course this approach works but this approach is slightly different because then all the memory allocated is bounded by the said restriction vs innodb_numa_interleave is applicable only during buffer pool allocation. It may serve specific purpose but may not be so called comparable. This has been on my todo list to check effect of complete interleave vs innodb_numa_interleave. ConclusionBalance distribution on NUMA node has multiple aspects including core-selection, memory allocation, thread allocation (equally on selected numa node), etc…. Lot of exciting and surprising things to explore. If you have more questions/queries do let me know. Will try to answer them. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/07/03/zhi-ding-numa-jie-dian-yun-xing-mysql/"},{"title":"源于鲲鹏，回归社区：GNU Glibc的ARM优化小记","text":"作者：姜逸坤 张学磊 从2019年10月初开始，我们团队开始着手Glibc在aarch64(64)架构下的优化工作，并且在2019年年底，将我们的全部优化贡献给上游开源社区。本文分享我们在Glibc的版本完成的优化以及性能测试结果，同时我们也尝试着将优化的思路进行总结，希望对其他项目的优化提供一些思路。 1. 背景1.1 什么是Glibc?我们先看看官方的解释： The GNU C Library project provides the core libraries for the GNU system and GNU/Linux systems, as well as many other systems that use Linux as the kernel. Glibc的全名是The GNU C Library，它为GNU系统、GNU/Linux系统以及提供了核心的底层库。比如，我们平常使用的memset，strlen等等这些非常常用的接口都由这个库提供。 1.2 为什么要优化？在计算领域的水平场景，例如大数据、数据库、Web等领域都直接或者间接地依赖着Glibc，举个简单的例子，在数据库的代码中，我们经常使用memcpy接口，对变量进行复制，调用频次也异常的高。如果在数据复制的过程中，性能能够有所提升，那么对上层软件的性能提升也是显而易见的。 1.3 做了什么优化？根据我们的分析，字符、内存和锁操作是最基础也是最重要的基本接口，因此，我们选择了对这三种类型的接口优先进行优化。在实现优化中，我们利用了Glibc的indirect function这一机制，即会根据CPU、CPU arch去自动选择匹配的函数。这一机制让我们的实现，更加灵活，也对现有系统影响最小。 下图为我们这次优化主要接口： 在上游社区的推进过程中，我们始终坚持Upstream First的原则，希望能够将鲲鹏优化的收益共享给整个生态，真正做到源于鲲鹏，回归社区。 所以，可以看到我们的优化大部分（橙色部分）都贡献到了上游社区的AArch64的generic实现中，从而使得整个生态都能够受益，而小部分（绿色部分）针对于Kunpeng CPU的特殊优化则保持了单独实现。 2. 优化我们知道在一般的开发中，小字节数据操作的使用频率，是远远的大于大字节数据操作的使用频率，而对于大数据和数据库的场景，则有可能会出现很多大字节数据操作的使用。因此，其实我们的一个优化原则是：在保证中小字节没有负优化的前提下，提升大字节数据操作的性能。 本节我们将一一解析在我们贡献的过程中，每个接口优化的关键点，并且尽可能的写的通俗易懂，希望能通过这些干货，给大家在其他的优化中带来启发。 2.1 memcmp，每次做更多，总时间更少Patch链接：aarch64: Optimized implementation of memcmp 2.1.1 优化思路对于memcmp的优化，我们的核心思路是通过循环展开让每个周期内做的事情更多，从而减少循环本身的开销。下图可以直观的看出，循环展开带来的性能提升：具体如下： 扩展循环间隔长度memcmp的aarch64原实现是以16bit的长度作为循环的周期长度，在无形中增加了很多次循环的消耗，尤其是在进行大字节数据比较中，有较大的性能损失。因此，我们这次优化的核心思路是：将16bit的循环扩展的64bit的循环，简单的说就是现在一次循环会比较64bit的数据。 寻址方式优化除此之外，我们还改变了LDP的寻址方式，从原来的后变址寻址（Post Index Addressing）变成了偏移寻址（Base Plus index）。 2.1.2 性能测试 可以从我们实际的测试结果看到整体在中大字节的性能有不错的提升，尤其是在128字节以上的场景，性能提升更是达到了18%。 2.2 memcpy，他山之石，可以为玉Patch链接：add default memcpy version for kunpeng920memcpy优化，因为社区的falkor版本在大、小字节的性能表现，已经很完善，因此最终，我们直接使用了Flakor版本作为优化版本。 Falkor版本的将字符分为3种场景： 对于small(&lt; 32)的场景，优先处理，避免过多判断，影响性能。 对于medium(33-128)的场景，做展开，避免多次循环带来的性能损失。 对于large(&gt;128)的场景，4字节对齐处理，并做循环展开每次循环处理64字节。 有兴趣的可以看看源码的实现链接，整体性能提升13-18%。 2.3 memrchr，站在巨人的肩上Patch链接：aarch64: Optimized implementation of memrchr 2.3.1 优化思路memrchr整体的优化思路是，参考memchr设计的魔鬼数字算法，通过汇编实现逻辑适配，实现对特定字符逆向查找的功能，替代原有的C语言实现方案达到优化，具体实现见上链接。 2.3.2 性能测试最终，我们获得了58%的性能提升，最终在大字节的场景，比generic版本提升了4倍左右。 2.4 memset，定向优化，更懂硬件Patch链接：aarch64: Optimized memset for Kunpeng processor. 2.4.1 优化思路我们进行了通过循环展开和特殊的定制优化来更好的适配硬件分支预测的特性，从而达到优化的效果。 特别说明的是，对于memset来说，置零场景是非常常用的场景，我们发现原有的实现使用DZ_ZVA指令并未在置零场景有显著效果，反而增加了许多条件分支，因此我们使用set_long代替了置零，由于set_long本身有更少的分支及更少的预测，所以性能与原实现比也有所提升。 2.4.2 性能测试 2.5 strcpy，加速的武器，vector loadsPatch链接：aarch64: Optimized implementation of strcpystrlen使用了neon寄存器，通过vector operations对函数进行了优化，对比原有的汇编实现，在64字节以上的场景，获得了5%-18%的提升： 2.6 strlen/strnlen 循环展开，判断更少，性能更优strlen Patch链接：aarch64: Optimized strlen for strlen_asimdstrnlen Patch链接：aarch64: Optimized implementation of strnlen strlen和strnlen同样使用了vector operations和循环展开，对主循环仅行了改造 strlen有7%-18%的提升: strnlen有11%-24%的提升: 3. 总结经过上面的介绍，相信大家已经了解了我们是怎么去优化这些函数的版本的，虽说大部分的优化都是比较晦涩的汇编语言，但是其实实际原理还是非常易懂的。 最后，我们再总结下我们应该从哪些方面考虑，去完成优化： 使用Neon汇编指令提高指令速度 使用Prefetch机制充分利用cache 避免非对齐的内存访问 指令重排，减少数据依赖 循环展开，减少高频判断 结合硬件特性，用软件补齐硬件缺陷 4. 写在最后本书所提及的所有代码，均已贡献到Glibc上游社区，并且随着Glibc 2.31已经在社区完成发布，有需要的可以直接从社区上游获取使用，有任何问题也可以在本文留言。 另外，Glibc优化，也全部合入到集成在当前版本的openeuler中，有兴趣的，也可以直接使用openEuler最新版本进行体验。","link":"/2020/04/17/yuan-yu-kun-peng-hui-gui-she-qu-gnu-glibc-de-arm-you-hua-xiao-ji/"},{"title":"理解InnoDB rw-lock的统计数据","text":"译者：bzhaoopenstack 原文链接：https://mysqlonarm.github.io/Understanding-InnoDB-rwlock-stats/ 作者: Krunal Bauskar InnoDB使用互斥锁进行独占访问，使用rw-locks进行共享访问。rw-locks用于控制对缓冲池页、表空间、自适应搜索系统、数据字典、informaton_schema等公共共享资源的访问。总之，rw-locks在InnoDB系统中扮演着非常重要的角色，因此跟踪和监视它们也很重要。 InnoDB 提供了一种简单的方式来跟踪它们， “SHOW ENGINE INNODB STATUS”. 1234RW-shared spins 38667, rounds 54868, OS waits 16539RW-excl spins 6353, rounds 126218, OS waits 3936RW-sx spins 1896, rounds 43888, OS waits 966Spin rounds per wait: 1.42 RW-shared, 19.87 RW-excl, 23.15 RW-sx 在本文中，我们将了解这些统计数据是如何计算的，以及每个数据的意义。我们还将尝试使用不同的用例来描述一些推论，并且接触一下基础又重要的统计数据， 这个bug使当前状态的统计几乎无法进行调优。 rw-lock 自旋算法rw-locks有三种类型: Shared: 提供资源的共享访问。允许多个共享锁。 Exclusive: 提供对资源的独占访问。共享锁等待排他锁。 Shared-Exclusive (SX): 对读不一致的资源提供写访问（relaxed exclusive）。 首先我们先尝试理解流程，然后讨论一些调优步骤。 (为了便于讨论，假设 spins=0, rounds=0, os-waits=0). Locking 步骤 Step-1: 尝试获取所需的锁 If SUCCESS then return immediately. (spins=0, rounds=0, os-waits=0) If FAILURE then enter spin-loop. Step-2: 开始自旋回环(Spin-loop). 增加自旋计数 (spin-count). (为什么需要自旋循环？如果我们的线程进入等待状态，那么操作系统将把CPU从给定的线程中带走，暂时不让它使用CPU，然后线程将不得不按照操作系统调度的次序等待CPU资源，从而进行下面的任务。更好的方法是在繁忙等待中（busy-wait）使用自旋循环(带有条件的检查确认锁是否被释放）以便保留CPU。由于这些锁大多数都是短时间使用，因此重新获得的机会可能性非常高。). Step-3: 开始N轮自旋。Start spinning for N rounds. (这里N的定义由innodb_sync_spin_loops来控制)。默认为30轮。 Step-3a: 每一轮将调用一个PAUSE逻辑（见下面关于PAUSE逻辑的单独一节），这将导致CPU进入PAUSE的X个周期。 Step-3b: 每轮检查（软实现）是否对应的锁已经可用(busy-wait)。 如果它可用，那么自旋循环退出。（可能还有一些其他同样正在自旋的检查。我们将使用下面的信息）。 Step-3c: 再次尝试获取所需的锁。 If SUCCESS then return. (spins=1, rounds=M (M &lt;= N), os-waits=0) If FAILURE，并且此时仍有其他正在自旋，且悬而未决任务 (max=innodb_sync_spin_loops)还是继续自旋。（为什么循环被中断，锁失败。注：该锁被多个线程并行查看。而当多个线程试图获取锁时，它们收到了锁可用的信号。被其他线程取走，所以该线程现在仍在重新尝试）。 Step-3d: 当这个线程现在完成了它设置的spin-wait轮循次数，到现在它还没有获得锁。那么它会被认为浪费CPU周期，没有必要继续自旋。最好的选择是放弃挂起的CPU周期并交还给操作系统，让操作系统调度做其他有用的事情。此外，由于所述线程现在将要进入睡眠，它应该向一些公共基础设施注册自身，这些基础设施将帮助它在所述锁可用时发出恢复活动的信号。 Step-3e: 这个将线程从唤醒的基础设施正式InnoDB中的同步阵列（sync-array）基础设施。 所述线程通过在同步阵列中预留插槽来注册自身。 在开始等待之前，再试一次看锁是否可用。（因为预留可能很费时间，同时锁这个时候是可用的状态）。 如果仍然没有获得锁，则将等待同步阵列向该线程送回信号。 这种等待称为OS-wait，进入这个循环现在会导致OS-waits计数增加。 Step-3f: 如果该线程收到由同步阵列发送回的wait-event信号。它会重新尝试获取锁。 If SUCCESS then return. (spins=1, rounds=N, os-waits=1) If FAILURE ，则整个循环从旋转逻辑重新启动(返回Step-3，rounds-count重新初始化为0)。注意：自旋计数(spins count)不会重新递增。 所以现在我们来给这些计数赋予意义 spins: 代表在第一次尝试中多少轮数而未能得到一个锁，并不得不进入自旋循环。 rounds: 表示执行多少轮PAUSE逻辑。 os-waits:自旋循环在多少轮自旋时仍未得到锁而导致os-waits。 在获取所述锁流程中的自旋循环期间中，可能需要超过30轮(innodb_sync_spin_loops)PAUSE逻辑，并且还可能多次进入os-waits。这可能会导致os-waits &gt; spins-count。 PAUSE 逻辑K = {取 (0 - innodb_spin_wait_delay)之间的随机数 * innodb_spin_wait_pause_multiplier} 调用底层 PAUSE 指令 K 次. 并不是所有的架构都提供底层的PAUSE指令。x86有提供，但ARM没有。即使x86深藏了这个PAUSE指令，它也会随着处理器的不同系列而继续变化。老一代处理器的周期约为10-15次（pre-skylake）,Skylake系列的周期约为140次，然后CascadeLake系列的周期数又降下来了 (我看到在属于CascadeLake系列的Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz芯片上是13次). (除了Cascadelake系列以外，我个人并没有在其他平台上对它进行基准测试) 但这些信息是可供参考的。这意味着延迟引入PAUSE指令（按照周期计算）会持续不断的变化，所以针对每一代/类型的处理器调整PAUSE逻辑是非常重要的。 这里有两个可配置的变量可以解决这个问题，innodb_spin_wait_delay 和 innodb_spin_wait_pause_multiplier。 统计数据解读现在我们已经了解了统计数据，让我们看看这个数字，并试着做出一些推断。 不过，在谈及进一步的细节之前，让我先看看这个bug， 它描述了导致这些统计数据不一致和不正确的原因和修复方法。 为了得到一个公正的结论，我们将使用mysql对应版本，并打上补丁。 (正如bug中指出的，不使用修复补丁统计数据不能产生正确的数据，因此各种解释和调优都毫无用处). Use Case 11234RW-shared spins 338969, rounds 20447615, OS waits 592941RW-excl spins 50582, rounds 1502625, OS waits 56124RW-sx spins 12583, rounds 360973, OS waits 10484Spin rounds per wait: 60.32 RW-shared, 29.71 RW-excl, 28.69 RW-sx 让我们分析一下共享自旋的情况: 1RW-shared spins 338969, rounds 20447615, OS waits 592941 在头一次尝试中，用了338K 次仍未获取到锁，迫使线程进去自旋锁状态(spin-lock)。 在每个自旋周期内，执行了60轮PAUSE周期（因此，所述自旋周期执行了2次）。 OS-waits/spins = 592/338 = 1.75表明大部分被分流进入了OS-wait（PAUSE的延迟不够）。 表明对于大多数自旋周期，单一的操OS-wait是不够的，因此这种操作是在重复进行的。 Conclusion: 该Use-case是高竞争情况。而且，诸如PAUSE循环无法产生所需的延迟来获得锁，导致每个自旋周期产生如此之多的PAUSE循环。 256 thread oltp-read-write workload on 24 vCPU ARM machine Use Case 21234RW-shared spins 35943, rounds 777178, OS waits 19051RW-excl spins 4269, rounds 121796, OS waits 4164RW-sx spins 13407, rounds 321954, OS waits 7346Spin rounds per wait: 21.62 RW-shared, 28.53 RW-excl, 24.01 RW-sx 让我们分析一下共享自旋的情况: 1RW-shared spins 35943, rounds 777178, OS waits 19051 流程中，自旋循环35K次。 只有19K次(大约是自旋循环的一半)引起了OS-waits。 平均每个自旋周期也限制在21.62，这表明，对于每个自旋周期，平均有22轮PAUSE循环。 Conclusion: 该Use-case表示中度竞争情况。 16 thread oltp-read-write workload on 24 vCPU ARM machine Use Case 3让我举一个常见的例子，以供参考。这是16个线程的oltp-read-write工作负载在基于x86_64的16CPU虚拟机上。 1234RW-shared spins 39578, rounds 424553, OS waits 7329RW-excl spins 5828, rounds 78225, OS waits 1341RW-sx spins 11666, rounds 67297, OS waits 449Spin rounds per wait: 10.73 RW-shared, 13.42 RW-excl, 5.77 RW-sx 流程中自旋循环39K次。 只有7K(约占自旋循环的20%) 导致OS-waits。 每自旋周期平均数也限制为10。 Conclusion: 该Use-case表示低竞争情况。 16 thread oltp-read-write workload on 24 vCPU x86_64 machine 调优注意事项记得我们在上面看到的高竞争案例。通过优化一些代码，可以显著减少共享自旋的争用。 1234RW-shared spins 318800, rounds 13856732, OS waits 374634RW-excl spins 35759, rounds 656955, OS waits 22310RW-sx spins 10750, rounds 226315, OS waits 5598Spin rounds per wait: 43.47 RW-shared, 18.37 RW-excl, 21.05 RW-sx 每个自旋周期的轮数: 平均数从 60 降到 43 每个自旋周期的OS-wait次数: 从1.75 降到1.17 这性能好起来了吗？不是太好。有许多因素需要考虑。 你看到TPS有改善吗？ 有时，它可能会建议简单地增加PAUSE循环。但是，增加PAUSE循环超过某个点将会导致延长自旋周期，最终浪费宝贵的CPU周期，尤其是这会导致线程返回到OS-wait状态。(这种方式可能对HT案例和多核案例更有效)。 同样，如上所述，不同处理器的系列和类型会影响PAUSE循环延迟。 有许多因素需要考虑。甚至我正在研究这个问题，看看我们如何为所有类型的CPU来优化它。一旦我在这个研究中发掘到一些非常好的通用的算法(或者我们可以开发一些自动的、自调整的或自适应的算法)，我会发布更多关于这个问题的博客，用户无需担心。 结论正如我们在上文看到的，rw-locks统计数据可以帮助我们更好地理解系统中锁的争用。当然，它不是有关InnoDB争用的唯一说明，因为互斥锁没在这些统计数据里面。调优可能具有挑战性，因为以错误的方式过度调优也会影响性能。 如果你还有问题/疑问，请告诉我。会试着去回答他们。","link":"/2020/04/15/li-jie-innodb-rw-lock-de-tong-ji-shu-ju/"},{"title":"用MySQL EventMutex来理解内存屏障那些事儿","text":"译者: bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/Understanding-Memory-Barrier/ 组内Mysql大牛Krunal利用Mysql EventMutex来让你彻底理解内存屏障问题，如何优化等。中文版实在是不好翻译，强烈建议阅读英文版增加理解。瓜已经备好了，还等啥？！ 中文 English MySQL 有多种互斥实现，即封装在 pthread 上的、基于 futex 的、基于 Spin-Lock 的(EventMutex)。它们都有自己的优点和缺点，但由于长期以来 MySQL 一直默认使用 EventMutex，因为它被认为是 MySQL应用场景的最佳选择。 EventMutex 被转换为使用 C++原子操作(MySQL 增加了对C++ 11的支持)。鉴于 MySQL 现在也支持 ARM，正确地使用内存屏障也是保持 EventMutex 向前优化发展的关键。 在本文中，我们将使用 EventMutex 的一个示例，了解内存障碍，并查看缺少什么，可以优化什么等等。. 理解获取和释放内存顺序ARM/PowerPC 平台使用弱内存模型，这意味着计算操作可以更自由地重新排序，因此同步地确保逻辑正确的屏障非常重要。最简单的方案是依赖使用循序一致性的默认方案(就像x86那样) ，但是这可能会大大影响其他架构的性能。 通常开发人员必须面对两个障碍(即 顺序) : 获取和释放。 获取内存顺序意味着在这个内存顺序/屏障之后的任何操作都不能调度/重新排序到该内存顺序/屏障之前(但是在获取该获取内存顺序之前的操作是可以调度/重新排序到它之后) 释放内存顺序意味着在这个内存顺序/屏障之前的任何操作都不能调度/重新排序到释放该内存顺序/屏障之后(但是在释放该获取内存顺序之后的操作是可以调度/重新排序到它之前) 理解 EventMutex 结构EventMutex 提供了一个普通的互斥类接口，用于帮助同步对临界区的访问。 Enter (lock mutex) try_lock (如果获得锁，立即返回). 利用compare-and-exchange (CAX) 接口设置 m_lock_word 原子变量. 如果锁获取失败 进入一个自旋循环，多次尝试后暂停，检查锁是否再次可用。 如果在“ N”次尝试之后(由 innodb_sync_spin_loops 控制)锁仍然不可用，那么释放(释放 cpu 控制)并通过在 InnoDB 自制的同步数组(sync-array)中注册该线程，让其进入等待状态。另外，在保留插槽后设置一个等待标志(这样可以确保我们在 sync-array 中得到一个插槽)。等待标志是另一个用于协调信号机制的原子变量。 Exit (unlock mutex) 切换原子变量(m_lock_word)以表示离开临界区。 检查是否设置了等待标志。如果有设置，那么通过同步数组(sync-array)框架向等待线程发送信号来唤醒它们。 看起来非常简单直接。不是吗？引入内存障碍会使这个过程变得复杂，因为忽略它们将意味着重新排序，这可能会导致代码中出现竞争。 从上面的序列可以很清楚地看出，当锁定 m_lock_word (false-&gt; true)时，它起始于临界区(如果 CAX 成功的话) ，因此在m_lock_word 被获取(设置为 true)之前，流程不应该执行来自临界区的任何语句。 回到我们的获取-释放屏障的部分，它建议 m_lock_word 应该能获取一个屏障一旦它成功了。 (而不是像它现在这样默认的保持顺序一致(seq_cst)). 但是，等等，有两个潜在的结果。失败怎么办？即使在失败的情况下，后续的执行，如自旋，睡眠等待和设置等待标识应该在CAX 评估后。这再次表明获得屏障失败的例子 (而不是像它现在这样默认的保持顺序一致(seq_cst)). 现在让我们看看 m_lock_word 释放屏障的例子。通常一个释放屏障过程发生在临界区结束要改变m_lock_word的时候。 还有另外一个原子变量(等待标志)也需要一个合适的屏障 设置服务员标志的动作应该发生在只有当流程中已确保可以得到一个同步阵列(sync-array)插槽的时候。这自然而然就需要一个 释放屏障，在set_waiter以上的代码都不会被重新排序。注意: 这是不同的原子操作，所以这里不适用于协调m_lock_word 的获取和释放。 同样的信号相关的逻辑也应该在等待标志被清除之后再进行，所以它应该使用一个获取屏障，以确保在清除等待之前不会被重新调度。(而不是像现在这样释放)。 这也将帮助我们使用relaxed屏障(vs 获取)来改变waiter-load标志检查。(这里有一个潜在的问题，我们将在下面讨论)。 有了所有这些，我们也应该能够解决那些比较明显的内存屏障了。 异常情况: 在release-barrier的 1lock_word 在之后的 acquire-barrier 1waiter 这是能够重新排序的。 这甚至是我对潜在风险的理解，我认为这就是为什么 MySQL 在这两个操作之间引入了一个内存屏障。如上所述blog, C++ 标准应该限制编译器这样做。 relaxed barrier 对于等待标识(同时检查其值时)有潜在的重新排序，可以将加载指令移动到 m_lock_word释放之前(注意:释放屏障 可以让后续的指示得到预先安排，就是排在它之前). If “waiter” is true then 调用信号循环来唤醒线程. If “waiter” is false then 信号循环将不会被该线程调用，而可能被其他线程调用。 如果只有2个线程，并且 thread-1通过在释放屏障之前重新排序得到 waiter = false，然后立即发布waiter被 thread-2设置为 true 并继续等待会怎么样。现在，thread-1 将永远不会向thread-2发出信号。 因此，使用一个relaxed 屏障是不可能的，所以让我们转换它使用一个获取屏障，应该避免移动后续语句超出上述情况，并作为澄清以上release-acquire需要遵循 C++ 标准。 所有这些都是为了节省额外的内存屏障。内存屏障的意图是协调同步非原子的操作，因为示例代码中有固有的原子(等待标志)使用适当的内存屏障可以帮助达到所需的效果。 所以有了这些注意事项，代码就会变成这样 我们从这次代码改造中得到了什么?我们实现了三个目标 修正了内存屏障的使用，这也有助于澄清代码/流程/开发人员的意图。(这是使用内存屏障所强调的重要事情之一。正确的使用将有助于使代码流程被理解和遵循)。 从严格的顺序排序移动到单向屏障而不失去正确性(获取和释放) 避免在非原子操作同步中使用内存屏障。 除非具有性能影响，否则没有理由进行改造，这次改造也不例外。改造后 ARM 的性能提高了4-15% ，x86_64的性能提高了4-6% 。 总结原子操作是好的，但是内存障碍使它们面临挑战，并且确保正确使用内存屏障是在所有平台上获得最佳性能的关键。Barrier 的改造正在迎头赶上，但仍然在起步阶段(尽管在C+11中有所体现) ，因为大多数软件最近开始移植它。正确使用屏障也有助于描述开发者/代码的意图。 如果你有问题，请联系我。 MySQL has multiple mutex implementations viz. wrapper over pthread, futex based, Spin-Lock based (EventMutex). All of them have their own pros and cons but since long MySQL defaulted to EventMutex as it has been found to be optimal for MySQL use-cases. EventMutex was switched to use C++ atomic (with MySQL adding support for C++11). Given that MySQL now also support ARM, ensuring a correct use of memory barrier is key to keep the EventMutex Optimal moving forward too. In this article we will use an example of EventMutex and understand the memory barrier and also see what is missing, what could be optimized, etc… Understanding acquire and release memory orderARM/PowerPC follows weak memory model that means operations can be re-ordered more freely so ensuring the correct barrier with synchronization logic is important. Easiest alternative is to rely on a default one that uses sequential consistency (as done with x86) but it could affect performance big time on other architectures. Often a programmer has to deal with 2 barriers (aka order): acquire and release. acquire memory order means any operation after this memory-order/barrier can’t be scheduled/re-ordered before it (but operations before it can be scheduled/re-ordered after it) release memory order means any operations before this memory-order/barrier can’t be scheduled/re-ordered after it (but operations after it can be scheduled/re-ordered before it). Understanding EventMutex structureEventMutex provides a normal mutex-like interface meant to help synchronize access to the critical sections. Enter (lock mutex) try_lock (try to get the lock if procured return immediately). Uses an atomic variable (m_lock_word) that is set using compare-and-exchange (CAX) interface. If fail to procure Enter a spin-loop that does multiple attempts to pause followed by check if the lock is again available. If after “N” attempts (controlled by innodb_sync_spin_loops) lock is not available then yield (releasing the cpu control) and enter wait by registering thread in InnoDB home-grown sync array implementation. Also, set a waiter flag after reserving the slot (this ensures we will get a slot in sync-array). Waiter flag is another atomic that is used to coordinate the signal mechanism. Exit (unlock mutex) Toggling the atomic variable (m_lock_word) to signify leaving the critical section. Check if the waiter flag is set. If yes then signal the waiting thread through the sync-array framework. Looks pretty straightforward and simple. Isn’t it?Things get complicated with introduction of memory barriers as ignoring them would mean re-ordering can cause race in your code. From the above sequence it is pretty clear that while locking m_lock_word (false-&gt;true) it could potentially begin the critical section (if CAX succeeds) and so flow shouldn’t execute any statement from the critical section before the lock word is acquired (set to true). Going back to our acquire-release barrier section it suggests m_lock_word should take an acquire barrier incase of success (instead of default (seq_cst) as it currently does). But wait, there are 2 potential outcomes. What about failure? Even in case of failure, followup actions like spin, sleep and set-waiter should be done only post CAX evaluation. This again suggests use of an acquire barrier for failure case too. (instead of default (seq_cst) as it currently does). Now let’s look at the release barrier for m_lock_word. Naturally a release barrier will be placed once a critical section is done when the m_lock_word is toggled. There is another atomic variable (waiter flag) that needs to get a proper barrier too. Action to set a waiter flag should be done only when flow has ensured it can get a sync array slot. This naturally invites the need for a release barrier so the code is not re-ordered beyond set_waiter. Note: This is different atomic though so the co-ordination of m_lock_word acquire and release will not apply here. Same way signal logic should be done only after the waiter flag is cleared so it should use an acquire barrier that will ensure it is not re-scheduled before the clear-waiter. (instead of release as it currently does). This will also help us change the waiter-load flag check to use relaxed barrier (vs acquire). (There is a potential catch here; we will discuss it below). With all that in place we should able to get rid of explicit memory_fence too. Anomalies: release-barrier on 1lock_word followed by an acquire-barrier on 1waiter this could be reordered. This was even my understanding of potential risk and I presume that’s why MySQL introduced a fence between these 2 operations. As per the said blog, C++ standard should limit compilers from doing so. By using a relaxed barrier for the waiter (while checking for its value) there is potential re-ordering that could move load instruction before the m_lock_word release (note: release barrier can allow followup instructions to get scheduled before it). If “waiter” is true then a signal loop will be called. If “waiter” is false then the signal loop will not be called by this thread but some other thread may call it. What if there are only 2 threads and thread-1 evaluates waiter=false by re-ordering it before the release barrier and then immediately posts that waiter is set to true by thread-2 and goes to wait. Now thread-1 will never signal thread-2. So using a relaxed barrier is not possible so let’s switch it to use an acquire barrier that should avoid moving the followup statement beyond the said point and as clarified above release-acquire needs to follow C++ standard. All this to help save an extra memory fence. memory-fence intention is to help co-ordinate non-atomic synchronization since our flow has inherent atomic (waiter) using proper memory barrier can help achieve the needed effect. So with all that taken-care this is how things would look What we gained from this revamp?So we achieved 3 things Corrected use of memory barrier that helps also clarify the code/flow/developer intention. (This is one of the important thing stressed with use of memory barrier. Correct use will help make the code flow naturally obvious to understand and follow). Moved from strict sequential ordering to one-way barrier without loosing on correctness. (acquire and release) Avoided use of fence memory barrier meant for synchronization of non-atomic. Revamp is not justified unless it has performance impact and this revamp is no exception. Revamp helps improve performance on ARM in range of 4-15% and on x86_64 in range of 4-6%. ConclusionAtomics are good but memory-barrier make them challanging and ensuring proper use of these barriers is key to the optimal performance on all platforms. Adaptation of barrier is catching up but still naive (though present in C+11) as most of the softwares recently started adapting to it. Proper use of barrier help clear the intention too. If you have more questions/queries do let me know. Will try to answer them. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/07/09/yong-mysql-eventmutex-lai-li-jie-nei-cun-ping-zhang-na-xie-shi-er/"},{"title":"让Github Action在你的ARM机器上跑起来","text":"作者：姜逸坤 Github在2019年8月，宣布推出了一项新的功能——Github Action，让成千上万的开源项目可以利用Github提供的计算资源完成构建、测试、部署等CI/CD，并且提供Self Hosted Runners功能，让开发者们可以将自己的机器接入到Github中来。 最近，我们利用这一功能，将搭载着openEuler 20.03 (LTS) 操作系统，跑在Kunpeng 920 处理器的ARM环境接入进来，在近期华为与阿里合作的MPAM项目，也将充分的利用这些资源利用Github Action的能力完成构建与测试。 本篇文章将接入方法分享给大家，希望能够帮助更多同学们把自己的ARM环境也在Github上用起来。 1. 接入资源资源的接入流程比较简单： 依次点击项目的Settings–Actions进入资源接入页面，点击Add Runner。 根据弹出的提示，下载和运行脚本 完成后我们可以看到接入的资源： 2. 使用资源我们为接入的项目增加一个Action： 123456789101112131415161718192021name: Run some script in Kunpeng envon: push: branches: [ master ] pull_request: branches: [ master ]jobs: build: runs-on: self-hosted steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 - name: Run `uname -a` in Kunpeng env run: | uname -a cat /etc/os-release lscpu | grep -E \"Architecture|Model name|CPU\\(s\\):\" 这样，这个workflow是展示所接入的环境上内核、操作系统、处理器信息，我们可以从结果看到job的结果： 点击Details可以进入详情页面： 可以看到，我们在资源上执行的指令，已经运行成功，可以看到这台资源的系统为openEuler 20.03 (LTS)，CPU为aarch64 128核的Kunpeng 920。 3.结语本文介绍了我们是如何将搭载着鲲鹏920处理器、openEuler操作系统的计算资源接入到Github Action的。可以看到Github Action的自定义资源接入，在ARM64下还是很顺滑的。 希望这篇文章能够帮助到大家，大家也可以尝试着将你们自己ARM资源接入进来，有问题可以留言一起讨论，玩的开心！：）","link":"/2020/04/15/rang-github-action-zai-ni-de-arm-ji-qi-shang-pao-qi-lai/"},{"title":"让压缩库ZSTD在aarch64更顺滑","text":"作者: 姜逸坤 曹亚珍 Facebook的ZSTD压缩库从1.0版本发布的那天起，就引起了业界的关注，对比业界常用的压缩库lz4、zilib、xz，ZSTD更注重速度和压缩比的均衡，对比zlib来看，更是在保证压缩比的情况下，较zlib压缩性能提升6倍左右，解压性能提升2倍左右。 我们团队也在2020年年初时，对ZSTD压缩库进行了性能优化，最终优化已推入到Facebook的上游社区中，本文将详细的介绍我们进行的优化。 1. 利用neon指令集对数据复制优化。完整的Patch链接：facebook/zstd#2041 优化思路：aarch64提供了一系列的neon指令，本次优化则利用了VLD和VST指令，借助neon寄存器进行读写加速，ARM的官方文档是这样描述这两个指令的： VLDn and VSTn (single n-element structure to one lane) Vector Load single n-element structure to one lane. It loads one n-element structure from memory into one or more NEON registers. Elements of the register that are not loaded are unaltered. Vector Store single n-element structure to one lane. It stores one n-element structure into memory from one or more NEON registers. 来自ARM的官方文档Coding for Neon - Part 1: Load and Stores中，写的非常详细，引用一张图来描述neon寄存器和memory加载和存储的方式，核心思想就是：利用neon寄存器作为暂存的中转站，加速数据处理： 我们以u8的复制为例，总结下本次我们在ZSTD具体的优化实现： 1234567static void ZSTD_copy8(void* dst, const void* src) {#ifdef __aarch64__ vst1_u8((uint8_t*)dst, vld1_u8((const uint8_t*)src));#else memcpy(dst, src, 8);#endif} 核心步骤包含两步： 将src利用vld1加载到neon寄存器。 使用vst1将neon寄存器的值store到dst的memory中。 这样便利用neon完成了对u8的memcpy的优化，对于此类优化，有兴趣的可以阅读What is the fastest way to copy memory on a Cortex-A8?，了解在Cortext-A8的架构下，如何快速的进行memory copy。 性能测试：完成neon优化后，我们对压缩和解压缩都进行了测试，最终，在压缩场景获得了大概1+%的提升： Average gains(level 1~19) gcc9.2.0 clang9.0.0 Compression 1.67% 1.23% Decompression 0.02% 0.36% 2. 使用prefetch机制加速数据读取。完整的Patch链接：facebook/zstd#2040 优化思路：Prefetch的中文是预取，原理是通过将数据预取到cache中，加速数据的访问。一个比较常见的场景就是在循环中，我们可以通过显示的调用，充分的预取未来将会访问的数据或指令便能快速从Cache中加载到处理器内部进行运算或者执行。 在Jeff Dean的一次经典的talk–Software Engineering Advice fromBuilding Large-Scale Distributed Systems中，提到了cache和memory的速度差异，大致如下图所示： 可以看到，从cache中拿数据，将比直接从memory拿数据性能提升几十甚至上百倍，因此，我们也在本次的优化中，为aarch64加入的预取指令。 12#define PREFETCH_L1(ptr) __asm__ __volatile__(\"prfm pldl1keep, %0\" ::\"Q\"(*(ptr)))#define PREFETCH_L2(ptr) __asm__ __volatile__(\"prfm pldl2keep, %0\" ::\"Q\"(*(ptr))) 同时，将预取加速加入到了ZSTD_compressBlock_fast_generic和ZSTD_compressBlock_doubleFast_generic的主循环中，在数据访问前，预先先将数据加载到cache中，从而加速后续访问对数据读取。 性能测试：我们仅对压缩进行了优化，因此，也仅对压缩进行了测试，测试结果可以看出，速度在aarch64架构下获得了1.5-3+%的提升： Average gains(level 1~19) gcc9.2.0 clang9.0.0 level 1~2 3.10% 3.69% level 3~4 2.49% 1.51% 3. 总结在Facebook的ZSTD中，我们使用了neon指令集对memcpy的过程进行了加速，同时，也利用了prefetch机制，加速了循环时数据的访问。 希望本篇文章，能够对大家带来一些性能优化的启发。","link":"/2020/05/20/rang-ya-suo-ku-zstd-zai-aarch64-geng-shun-hua/"},{"title":"让大数据生态在ARM架构下更顺滑","text":"作者：郑振宇 受疫情影响Linaro Connect 2020改为线上直播的Linaro Tech Days，笔者所在团队在该活动上介绍了自19年Q4以来笔者团队在各主流开源社区推广ARM生态所做的工作以及所取得的成果。直播活动约有120+与会者。 视频回放：视频连接PPT：LTD20-104 Make life easier for Big Data users on ARM - Our efforts and future plans","link":"/2020/03/30/rang-da-shu-ju-sheng-tai-zai-arm-jia-gou-xia-geng-shun-hua/"},{"title":"跑benchmark？当心你的芯","text":"译者: bzhaoopenstack作者: Krunal Bauskar原文链接: https://mysqlonarm.github.io/Benchmarking-Mind-Your-Core/ 最近，我们在运行基准测试时发现 MySQL 吞吐量的抖动。 即使对于普通用户来说也是如此，但是还有很多其他事情需要注意(尤其是 IO 性能瓶颈) ，以至于我们今天计划讨论的一些方面可能会被暂时省略。 在本文中，我们将讨论可能影响 MySQL 性能的一个原因。 中文 English 在启用 NUMA 的 vm / machine 上的线程调度Numa 通常是从内存分配的角度来看待的，但本文试图探讨在不同的 vCPUs上启动线程会如何大幅度地影响性能。 在我们的实验中，我们已经看到性能上升到66% 。 Mysql 有一个名为 innodb_numa_interleave的选项，如果启用，它将尝试在 NUMA 节点之间统一分配缓冲池。 这很好，但是工作线程呢。 这些工作线程是否在 NUMA 节点上分配过于一致？ 跨 NUMA 访问成本较高，因此最好让工作线程更接近数据，但鉴于这些工作线程的通用性，它们不应该被均匀分布。 假设我在一台24个 vCPU 机器上启动12个工作线程，这台机器上有2个 NUMA 节点，那么统一的分布预计会有6个工作线程绑定到 NUMA-node-0的 vCPU，剩下6个工作线程绑定到 NUMA-node-1的 vCPU。 操作系统(Linux)调度程序不是这样工作的。 它将尝试从一个 NUMA节点耗尽 vCPU，然后才会继续到另一个NUMA节点获取。 当工作线程(可伸缩性) &lt; 核心数，所有这些都会大大影响性能。 甚至还会看到同一测试用例的不同性能，这些都是因为CPU跨NUMA的高访问成本, OS层面调度的不均衡, 以及核心切换导致的。 实验开始:现在，让我们尝试看看Mysql吞吐量是如何如何由于工作线程所在的位置而更改的。 我使用同一台机器来运行client(sysbench)和server，因此client也会占用几个核心。 我们还考虑了客户端线程的位置，因为它是运行基准测试时的一个重要方面(除非你计划使用一些专用机器)。 24 vCPU/48 GB VM，2 个NUMA nodes. NUMA-1: 0-11 vCPU/24GB NUMA-2: 12-23 vCPU/24GB x86 (Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz) VM中每个物理内核有2个线程，所以24个 vCPU就是12个物理内核。 因此，我们还将探索两个工作线程位于不同的 vCPU 但处在相同物理核心的情况。 Test-Case: oltp-point-select(2 threads). 故意将其限制在两个线程内，以保持其他内核处于开放状态，从而允许操作系统执行内核切换(这会导致它独特的效果)。此外，所有测试数据都在内存中，使用 point-select 意味着没有执行 IO操作，因此 IO 瓶颈或后台线程大多处于空闲状态。 所有迭代的时间是60秒。 为了让测试更加灵活，vCPUs/cores 使用 numactl (vs taskset)绑定到 sysbench 和 mysqld。 对于服务器配置请看 here.Data-Size: 34G and BP: 36G. 在内存中生成测试数据并平均分布50% 的数据到 numa-0，剩下50% 的 numa-1。 Sysbench 使用range-type=uniform，这会让其触及大多数测试表的不同部分。 client-threads server-threads tps Client-Threads bounded to vCPU: (0, 1, 12, 13) Server Thread bounded to vCPUs: (2-11, 14-23) 35188, 37426, 35140, 37640 37625, 35574, 35709, 37680 很显然 tps 在波动。 我做了进一步的研究，操作系统会一直继续做核心切换，导致 TPS 的波动(7% 的范围对于像这样的小测试场景来说太高了)。 此外，操作系统也同样一直在切换客户端线程核心。 这样的景象促使我对服务器核心绑定进行了更多的探索。 Client和Server线程所处的位置 Server-Threads: (Numa Node: 0, Physical Core: 2-5, vCPU: 4-11) Server-Threads: (Numa Node: 0, Physical Core: 2, 3, vCPU: 4, 6) Server-Threads: (Numa Node: 0, Physical Core: 2, vCPU: 4, 5) Client Threads (Numa Node: 0, Physical Core: 0, vCPU: 0,1) - Client+Server threads 处在同一NUMA节点 - Server threads (可能性大)做核心切换 (基于OS调度) - Client threads 在同一物理核心上 TPS: 39570, 38656, 39633 - Client+Server threads 处在同一NUMA节点 - Server threads (可能性小)执行核心切换. - Client threads 在同一物理核心上 TPS: 39395, 39481, 39814 - Client+Server threads 处在同一NUMA节点 - Server threads (可能性小)执行核心切换 (在同一物理内核上) - Client threads 在同一物理核心上. TPS: 39889, 40270, 40457 (Numa Node: 0, Physical Core: 0,1, vCPU: 0,2) - Client+Server threads 处在同一NUMA节点 - Server threads (可能性大)做核心切换 (基于OS调度) - Client threads 在不同物理核心上 TPS: 39890, 38698, 40005 - Client+Server threads 处在同一NUMA节点 - Server threads (可能性小)执行核心切换. - Client threads on 在不同物理核心上. TPS: 40068, 40309, 39961 - Client+Server threads 处在同一NUMA节点 - Server threads (可能性小)执行核心切换 (在同一物理内核上) - Client threads 在不同物理核心上. TPS: 40680, 40571, 40481 (Numa Node: 0, Physical Core: 0, vCPU: 0) - Client+Server threads 处在同一NUMA节点 - Server threads (可能性大)做核心切换 (基于OS调度) - Client threads 在同一物理核心和同一vCPU上 TPS: 37642, 39730, 35984 - Client+Server threads 处在同一NUMA节点 - Server threads (可能性小)执行核心切换. - Client threads 在同一物理核心和同一vCPU上 TPS: 40426, 40063, 40200 - Client+Server threads 处在同一NUMA节点 - Server threads (可能性小)执行核心切换 (在同一物理内核上) - Client threads 在同一物理核心和同一vCPU上 TPS: 40292, 40158, 40125 (Numa Node: 1, Physical Core: 6, vCPU: 12,13) - Client+Server threads 处在不同NUMA节点 - Server threads (可能性大)做核心切换 (基于OS调度) -Client threads 在同一物理核心上 TPS: 34224, 34463, 34295 - Client+Server threads 处在不同NUMA节点 - Server threads (可能性小)执行核心切换. - Client threads 在同一物理核心上 TPS: 34518, 34418, 34436 - Client+Server threads 处在不同NUMA节点 - Server threads (可能性小)执行核心切换 (在同一物理内核上) - Client threads 在同一物理核心上 TPS: 34282, 34512, 34583 (Numa Node: 1, Physical Core: 6,7, vCPU: 12,14) - Client+Server threads 处在不同NUMA节点 - Server threads (可能性大)做核心切换 (基于OS调度) -Client threads 处在不同的物理核心上 TPS: 34462, 34127, 34620 - Client+Server threads 处在不同NUMA节点 - Server threads (可能性小)执行核心切换. - Client threads 处在不同的物理核心上. TPS: 34438, 34379, 34419 - Client+Server threads 处在不同NUMA节点 - Server threads(可能性小)执行核心切换 (在同一物理内核上) - Client threads 处在不同的物理核心上. TPS: 34804,34453,34729 (Numa Node: 1, Physical Core: 6, vCPU: 12) - Client+Server threads 处在不同NUMA节点 - Server threads (可能性大)做核心切换 (基于OS调度) - Client threads处在相同的物理核心和vCPU上 TPS: 34989, 35162, 35245 - Client+Server threads 处在不同NUMA节点 - Server threads (可能性小)执行核心切换. - Client threads 处在相同的物理核心和vCPU上 TPS: 35503, 35455, 35632 - Client+Server threads 处在不同NUMA节点 - Server threads (可能性小)执行核心切换 (在同一物理内核上) - Client threads处在相同的物理核心和vCPU上 TPS: 35572, 35481, 35692 观察结果: 限制服务器线程的核心有助于稳定性能(减少抖动)。 操作系统核心交换成本很高(如果具有不同的可伸缩性，这可能不太可行，但是是一个很好理解的点)。 将客户端线程移动到不同的 NUMA 对性能有很大影响(40K-34K)。 我没有想到会这样，因为真正的工作是由服务器工作线程完成的，所以移动客户端线程不应该影响服务器性能到这个程度(17%)。 因此，从实验中我们了解到，如果客户机和服务器线程位于相同的 NUMA 上，并且使用一定工具减少OS核心交换(直到真的需要扩展核心数或者整体性能) ，则有助于实现最佳性能。 但是等等！ 我们的目标是在 NUMA 节点上平衡客户端和服务器线程的分布，以获得最佳性能。 跨 NUMA 平衡客户端和服务器的线程让我们应用上面获得的知识和数据来平衡 NUMA配置 client-threads server-threads tps remark Client-Threads bounded to vCPU: 0, 1, 12, 13 Server Thread bounded to vCPUs: (2-11, 14-23) 35188, 37426, 35140, 37640, 37625, 35574, 35709, 37680 多核心交换 Client thread bounded to specific vCPU across NUMA (0,12) Server Thread bounded to specific vCPU across NUMA (4,16) 30001, 36160, 24403, 24354 37708, 24478, 36323, 24579 限制核心交换 Oops，结果比预期的还要糟糕。波动增加了。让我们来看看到底出了什么问题 24K: OS 选择了threads倾斜的分布，其中 NUMA-x 运行客户端线程，而 NUMA-y 运行两个服务器线程 37K: OS 选择在每个 NUMA 运行1个客户端和1个服务器线程的情况下很好地平衡了线程分布 (所有其他数字都是排列组合测试得到的) 让我们尝试一个可能的提示。 平衡 NUMA。你可以在这里here了解更多 1echo 0 &gt; /proc/sys/kernel/numa_balancing client-threads server-threads tps remark Client thread bounded to specific vCPUs across NUMA (0,12) Server Thread bounded to specific vCPUs across NUMA (4,16) 33628, 34190, 35380, 37572 限制核心交换 + 禁用NUMA平衡。抖动仍然存在，但肯定比上面提到的24K 情况要好 如果我们将客户端线程绑定到特定的 NUMA上的核心并平衡服务器线程会怎样？ client-threads server-threads tps remark Client thread bounded to specific vCPU NUMA (0) Server Thread bounded to specific vCPUs across NUMA (4,16) 36742, 36326, 36701, 36570 限制核心交换 + 禁用NUMA平衡。 看起来很平均。 Client thread bounded to specific vCPU NUMA (12) Server Thread bounded to specific vCPUs across NUMA (4,16) 35440, 35667, 35748, 35578 限制核心交换 + 禁用NUMA平衡。看起来很平均。 总结通过上面的多个实验，我们看到了给定的测试用例如何因为运行客户机和服务器线程的位置和方式得到了从24K 到40K 不等的不同性能数据。 如果你的基准测试真的只关心较低的可伸缩性，那么你应该注意核心分配。 常用的降噪策略有运行测试 n 次的平均值、 n 次的中位数、 n 次的最优值等。但是如果方差是很大的话，没有一个是最有效的。 我倾向于使用平均 n 次最小时间运行测试的策略，因此概率上的数据趋于稳定。我不确定这是否是最好的方法，但似乎它有助于将噪音到一定的程度。 较小的样本(n 值较小)会增加噪声，所以我建议 n =9至少每次运行(60 + 10(tc-warmup))秒，所以630秒的测试用例运行时间足以减少抖动。 如果你有更好的方案，请与社区分享。 另外，随着 NUMA 节点的增加和 ARM 上核心的增加，情况变得更加复杂。如果有人研究过它，我会很乐意去理解它。 如果你有疑问，请让我知道，我会尽力回答。 Scheduling threads on NUMA enabled VM/MachineNUMA is often looked upon from a memory allocation perspective but the article tries to explore how booting thread on different vCPUs can affect performance in a big way. During our experiment we have seen performance swing upto 66%. MySQL has an option named innodb_numa_interleave that if enabled will try to uniformly allocate the buffer pool across the NUMA node. This is good but what about the worker threads. Are these worker threads too uniformly allocated across the NUMA node? Cross NUMA access is costlier and so having a worker thread closer to the data is always prefered but given the generic nature of these worker threads shouldn’t they be uniformly distributed. Say I am booting 12 worker threads on a 24 vCPU machine with 2 NUMA nodes then uniform distribution would expect 6 worker threads bound to vCPUs from NUMA-node-0 and remaining 6 to vCPUs from NUMA-node-1. The OS (Linux) scheduler doesn’t work it that way. It would try to exhaust vCPUs from one of the NUMA-nodes and then proceed to another. All this could affect performance big-way till your worker threads (scalability) &lt; number-of-cores. Even beyond this point one may see varying performances for the same test-case due to core-switches. Understanding the setup:Let’s now try to see how the throughput can change based on where the worker threads are located. I am using the same machine to run client (sysbench) and server so few cores are reserved for clients too. We also consider the position of client threads as it is an important aspect while running benchmark (unless you plan to use some dedicated machine for it). 24 vCPU/48 GB VM with 2 NUMA nodes. NUMA-1: 0-11 vCPU/24GB NUMA-2: 12-23 vCPU/24GB x86 (Intel(R) Xeon(R) Gold 6266C CPU @ 3.00GHz) VM has 2 threads per physical core so 24 vCPU = 12 physical cores. So we would also explore scenarios when both worker threads are located on different vCPU but have the same physical core. Test-Case: oltp-point-select with 2 threads. Purposely limiting it to 2 threads to keep other cores open to allow the OS to do core-switches (this has its own sweet effect). Also, all data is in-memory and using point-select means no IO being done so IO bottlenecks or background threads are mostly idle. All iterations are timed for 60 seconds. vCPUs/cores are bound to sysbench and mysqld using numactl (vs taskset) given the flexibility it provides. For server configuration please check here.Data-Size: 34G and BP: 36G. Complete data in memory and equally distributed so 50% of data on numa-0 and remaining 50% of numa-1. Sysbench uses range-type=uniform that should touch most of the varied parts of the table. client-threads server-threads tps Client-Threads bounded to vCPU: (0, 1, 12, 13) Server Thread bounded to vCPUs: (2-11, 14-23) 35188, 37426, 35140, 37640 37625, 35574, 35709, 37680 Naturally the tps is fluctuating. Some closer look revealed that OS continues to do core-switch that causes TPS to fluctuate (range of 7% is too high for small test-case like this). Also, OS continues to switch client threads cores too. That prompted me to explore more about server core binding. As part of completeness I also explored client thread positioning. Position of Client and Server Threads Server-Threads: (Numa Node: 0, Physical Core: 2-5, vCPU: 4-11) Server-Threads: (Numa Node: 0, Physical Core: 2, 3, vCPU: 4, 6) Server-Threads: (Numa Node: 0, Physical Core: 2, vCPU: 4, 5) Client Threads (Numa Node: 0, Physical Core: 0, vCPU: 0,1) - Client+Server threads on same NUMA - Server threads may do core-switch (OS-scheduler dependent) - Client threads on the same physical core TPS: 39570, 38656, 39633 - Client+Server threads on same NUMA - Server threads are less likely to do core-switch. - Client threads on the same physical core. TPS: 39395, 39481, 39814 - Client+Server threads on same NUMA - Server threads less likely to do core-switch (on same physical core) - Client threads on the same physical core. TPS: 39889, 40270, 40457 (Numa Node: 0, Physical Core: 0,1, vCPU: 0,2) - Client+Server threads on same NUMA - Server threads may do core-switch (OS-scheduler dependent) - Client threads on different physical core TPS: 39890, 38698, 40005 - Client+Server threads on same NUMA - Server threads are less likely to do core-switch. - Client threads on different physical core. TPS: 40068, 40309, 39961 - Client+Server threads on same NUMA - Server threads less likely to do core-switch (on same physical core) - Client threads on different same physical core. TPS: 40680, 40571, 40481 (Numa Node: 0, Physical Core: 0, vCPU: 0) - Client+Server threads on same NUMA - Server threads may do core-switch (OS-scheduler dependent) - Client threads on same physical core and same vCPU TPS: 37642, 39730, 35984 - Client+Server threads on same NUMA - Server threads are less likely to do core-switch. - Client threads on same physical core and same vCPU TPS: 40426, 40063, 40200 - Client+Server threads on same NUMA - Server threads less likely to do core-switch (on same physical core) - Client threads on same physical core and same vCPU TPS: 40292, 40158, 40125 (Numa Node: 1, Physical Core: 6, vCPU: 12,13) - Client+Server threads on different NUMA - Server threads may do core-switch (OS-scheduler dependent) -Client threads on the same physical core TPS: 34224, 34463, 34295 - Client+Server threads on different NUMA - Server threads are less likely to do core-switch. - Client threads on the same physical core. TPS: 34518, 34418, 34436 - Client+Server threads on different NUMA - Server threads less likely to do core-switch (on same physical core) - Client threads on the same physical core. TPS: 34282, 34512, 34583 (Numa Node: 1, Physical Core: 6,7, vCPU: 12,14) - Client+Server threads on different NUMA - Server threads may do core-switch (OS-scheduler dependent) -Client threads on different physical core TPS: 34462, 34127, 34620 - Client+Server threads on different NUMA - Server threads are less likely to do core-switch. - Client threads on different physical core. TPS: 34438, 34379, 34419 - Client+Server threads on different NUMA - Server threads less likely to do core-switch (on same physical core) - Client threads on different same physical core. TPS: 34804,34453,34729 (Numa Node: 1, Physical Core: 6, vCPU: 12) - Client+Server threads on different NUMA - Server threads may do core-switch (OS-scheduler dependent) - Client threads on same physical core and same vCPU TPS: 34989, 35162, 35245 - Client+Server threads on different NUMA - Server threads are less likely to do core-switch. - Client threads on same physical core and same vCPU TPS: 35503, 35455, 35632 - Client+Server threads on same NUMA - Server threads less likely to do core-switch (on same physical core) - Client threads on different physical core and same vCPU TPS: 35572, 35481, 35692 Observations: Limiting cores for server threads helps stabilize the performance (reduce jitter). OS-core switches are costly (with varying scalability this may not be feasible but a good parameter to understand). Moving client thread to different NUMA affects performance in a big way (40K -&gt; 34K). I was not expecting this since the real work is done by server worker threads so moving client threads should not affect server performance to this level (17%). So from the experiment we learned that client and server threads if co-located on the same NUMA and technique to reduce core-switch (till it is really needed with increased scalability) helps achieve optimal performance. But wait! Our goal is to have balance distribution of client and server threads across the NUMA node to get optimal performance. Balance Client and Server Threads across NUMALet’s apply the knowledge gained above to balance numa configuration client-threads server-threads tps remark Client-Threads bounded to vCPU: 0, 1, 12, 13 Server Thread bounded to vCPUs: (2-11, 14-23) 35188, 37426, 35140, 37640, 37625, 35574, 35709, 37680 Lot of core switches Client thread bounded to specific vCPU across NUMA (0,12) Server Thread bounded to specific vCPU across NUMA (4,16) 30001, 36160, 24403, 24354 37708, 24478, 36323, 24579 Limit core switches Oops it turned out to be worse than expected. Fluctuation increased. Let’s understand what went wrong 24K: OS opted for skewed distribution with NUMA-x running both client threads and NUMA-y running both server threads. 37K: OS opted for well balance distribution with each NUMA running 1 client and 1 server thread. (All other numbers are mix of combinations) Let’s try a possible hint. NUMA balancing. You can read more about it here 1echo 0 &gt; /proc/sys/kernel/numa_balancing client-threads server-threads tps remark Client thread bounded to specific vCPUs across NUMA (0,12) Server Thread bounded to specific vCPUs across NUMA (4,16) 33628, 34190, 35380, 37572 Limit core switches + NUMA balancing disabled. Jitter is still there but surely better than 24K case above. What if we bind client thread to specific numa cores and balance server threads client-threads server-threads tps remark Client thread bounded to specific vCPU NUMA (0) Server Thread bounded to specific vCPUs across NUMA (4,16) 36742, 36326, 36701, 36570 Limiting core switches + NUMA balancing disabled. Looks well balanced now. Client thread bounded to specific vCPU NUMA (12) Server Thread bounded to specific vCPUs across NUMA (4,16) 35440, 35667, 35748, 35578 Limit core switches + NUMA balancing disabled. Looks well balanced now. ConclusionThrough multiple experiments above we saw how the given test-case can help produce different results ranging from 24K -&gt; 40K based on where and how you run client and server threads. If your benchmark really cares about the lower scalability then you should watch out for the core allocation. Usual strategies to reduce noise are average of N runs, median of N runs, best of N runs, etc… But if the variance is that high none of them will work best. I tend to use strategy of averaging N smaller time runs so with probabilty things could stablize. Not sure if this is best approach but seems like it help reduce the noise to quite some level. Lesser sample (smaller value of N) would increase noise so I would recommend N = 9 at-least with each run of (60+10 (tc-warmup)) secs so 630 seconds run of test-case is good enough to reduce the jitter. If you have better alternative, please help share it with community. BTW, story is more complex with increasing NUMA nodes and more cores on ARM. Topic of future. If anyone has studied it, would love to understand it. If you have more questions/queries do let me know. Will try to answer them. .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); }","link":"/2020/04/28/pao-benchmark-dang-xin-ni-de-xin/"},{"title":"鲲鹏计算团队博客开张啦，欢迎投稿！","text":"中文 English 我们将在这里分享关于鲲鹏计算相关的技术、开源、生态的点滴。 欢迎关注！欢迎转发！欢迎投稿！ We are share something about technology, opensource and ecosystem of Kunpeng. Welcome to join us! .content .tabs ul { margin: 0; } .content .tabs ul li { margin: 0; } .tab-content { display: none; } function onTabClick (event) { var tabTitle = $(event.currentTarget).children('span:last-child').text(); $('.article .content .tab-content').css('display', 'none'); $('.article .content .tabs li').removeClass('is-active'); $('#' + tabTitle).css('display', 'block'); $(event.currentTarget).parent().addClass('is-active'); } 如何投稿？非常简单，仅需要两步： 点击这里，进入博客提交页面，我们使用Issue对博客进行管理，点击New进行投稿。 填写标题和内容，issue标题即为文章标题，issue内容即为文章内容，并发布请求。 好了，至此你的投稿已经完成，你可以在这里看到你的投稿，并进行迭代修改。 如何发布？等到管理员审核通过后，会将你issue打上publish标签，之后，你内容就会自动同步在博客中啦！ 来吧，还等什么？把你的干货分享起来！","link":"/2020/03/27/kun-peng-ji-suan-tuan-dui-bo-ke-kai-zhang-la-huan-ying-tou-gao/"}],"tags":[{"name":"虚拟化","slug":"虚拟化","link":"/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大数据","slug":"大数据","link":"/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"基础库","slug":"基础库","link":"/tags/%E5%9F%BA%E7%A1%80%E5%BA%93/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Packaging","slug":"Packaging","link":"/tags/Packaging/"},{"name":"会议","slug":"会议","link":"/tags/%E4%BC%9A%E8%AE%AE/"}],"categories":[{"name":"虚拟化","slug":"虚拟化","link":"/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"大数据","slug":"大数据","link":"/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"},{"name":"基础库","slug":"基础库","link":"/categories/%E5%9F%BA%E7%A1%80%E5%BA%93/"},{"name":"Web","slug":"Web","link":"/categories/Web/"}]}